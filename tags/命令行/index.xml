<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>命令行 on 低头沉思</title><link>https://deep-thinking.top/tags/%E5%91%BD%E4%BB%A4%E8%A1%8C/</link><description>Recent content in 命令行 on 低头沉思</description><generator>Hugo</generator><language>zh-CN</language><lastBuildDate>Fri, 18 Feb 2022 21:19:39 +0800</lastBuildDate><atom:link href="https://deep-thinking.top/tags/%E5%91%BD%E4%BB%A4%E8%A1%8C/index.xml" rel="self" type="application/rss+xml"/><item><title>Linux批量文件操作——基于find,xargs</title><link>https://deep-thinking.top/post/Linux%E6%89%B9%E9%87%8F%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E2%80%94%E2%80%94%E5%9F%BA%E4%BA%8Efind,xargs.html</link><pubDate>Fri, 18 Feb 2022 21:19:39 +0800</pubDate><guid>https://deep-thinking.top/post/Linux%E6%89%B9%E9%87%8F%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E2%80%94%E2%80%94%E5%9F%BA%E4%BA%8Efind,xargs.html</guid><description>&lt;h3 id="前言" class="relative group">前言 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e5%89%8d%e8%a8%80" aria-label="">#&lt;/a>&lt;/span>&lt;/h3>&lt;p>在项目初创阶段，经常会遇到各种文件操作，拷贝头文件，库，批量重命名等。文件结构一复杂，这就将是个无聊的工作。&lt;/p>
&lt;h3 id="查找文件" class="relative group">查找文件 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e6%9f%a5%e6%89%be%e6%96%87%e4%bb%b6" aria-label="">#&lt;/a>&lt;/span>&lt;/h3>&lt;p>&lt;code>find&lt;/code>可以在目录结构中搜索文件，这是它在&lt;code>man&lt;/code>里面的作用描述。那么怎么搜索呢？有多种方式，按文件时间，大小，按文件名，路径名，按文件类型，权限，按用户。而这些方式又可以通过与或非的逻辑相互组合，完成更苛刻的查找工作，简直是文件查找的福音。
通常介绍一种命令都会以命令形式开始，&lt;code>find&lt;/code>的格式如下&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">find &lt;span class="o">[&lt;/span>-H&lt;span class="o">]&lt;/span> &lt;span class="o">[&lt;/span>-L&lt;span class="o">]&lt;/span> &lt;span class="o">[&lt;/span>-P&lt;span class="o">]&lt;/span> &lt;span class="o">[&lt;/span>-D debugopts&lt;span class="o">]&lt;/span> &lt;span class="o">[&lt;/span>-Olevel&lt;span class="o">]&lt;/span> &lt;span class="o">[&lt;/span>starting-point...&lt;span class="o">]&lt;/span> &lt;span class="o">[&lt;/span>expression&lt;span class="o">]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>[-H] [-L] [-P] [-D debugopts] [-Olevel]这一些统统不重要，
[-H] [-L] [-P]是针对软连接的，不常用。[-D debugopts]是显示运行期间的额外信息，信息太乱太杂，用处不大。[-Olevel]则是用于优化查找的，默认的已经够用，所以也没必要深究。
&lt;code>find&lt;/code>的最大魔法在最后的&lt;code>[expression]&lt;/code>,下面将以实例的形式讲解这个&lt;code>[expression]&lt;/code>到底该怎么玩，原始的文件结构如下&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">├── alice.h
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">├── andy
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">│   ├── jack
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">│   │   └── mary.h
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">│   ├── mark.cpp
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">│   ├── mark.h
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">│   └── pony.txt
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">├── andy.c
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">├── bill.cpp
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">├── bill.h
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">├── mark.h
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">└── mary
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>现在，我想找到以&lt;code>andy&lt;/code>命名的文件，命令该怎么写呢。直觉告诉我们应该是&lt;/p></description></item></channel></rss>