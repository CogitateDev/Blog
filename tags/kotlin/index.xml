<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Kotlin on 低头沉思</title><link>https://hongui.github.io/tags/kotlin/</link><description>Recent content in Kotlin on 低头沉思</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Tue, 30 Mar 2021 19:10:30 +0800</lastBuildDate><atom:link href="https://hongui.github.io/tags/kotlin/index.xml" rel="self" type="application/rss+xml"/><item><title> Kotlin协程-从一到多</title><link>https://hongui.github.io/post/%20Kotlin%E5%8D%8F%E7%A8%8B-%E4%BB%8E%E4%B8%80%E5%88%B0%E5%A4%9A.html</link><pubDate>Tue, 30 Mar 2021 19:10:30 +0800</pubDate><guid>https://hongui.github.io/post/%20Kotlin%E5%8D%8F%E7%A8%8B-%E4%BB%8E%E4%B8%80%E5%88%B0%E5%A4%9A.html</guid><description>&lt;blockquote>
&lt;p>上一篇文章，我介绍了Kotlin协程的创建，使用，协作等内容。本篇将引入更多的使用场景，继续带你走进协程世界。&lt;/p>
&lt;/blockquote>
&lt;h1 id="使用协程处理异步数据流">使用协程处理异步数据流&lt;/h1>
&lt;p>常用编程语言都会内置对同一类型不同对象的数据集表示，我们通常称之为容器类。不同的容器类适用于不同的使用场景。Kotlin的&lt;code>Flow&lt;/code>就是在异步计算的需求下引入的，用于表示异步的数据流。&lt;/p>
&lt;h2 id="flow">Flow&lt;/h2>
&lt;p>“问渠哪得清如许，为有源头活水来”，异步数据流的基本就是以某种方式获得异步数据。Kotlin提供了多种种方式，比较常用的就是Kotlin协程包的&lt;code>asFlow&lt;/code>扩展和&lt;code>flow&lt;/code>构造器。前者是对普通数据集的&lt;code>Flow&lt;/code>化封装，没有更多可言，我们着重来看后者。
&lt;code>flow&lt;/code>构造器的主要目标就是产生一个异步数据流，它是一个泛型函数，参数是一个挂起函数，并且是&lt;code>FlowCollector&lt;/code>是扩展函数。这个接口只有一个&lt;code>emit&lt;/code>方法，就是为创建的&lt;code>Flow&lt;/code>提供异步计算的数据的，因为它是挂起函数，所以我们能在里面使用其他挂起函数计算异步值，然后通过&lt;code>emit&lt;/code>方法将值发送出去，如此反复就能为下游操作提供源源不断的数据流了。
事情还没完，上面的步骤我们只是规定了创建数据的方式，并没有真正执行，也就是建好了道路，但是还没有车上路。那么，怎样才能让车在路上跑呢，查看&lt;code>Flow&lt;/code>的接口会发现，它提供了&lt;code>collect&lt;/code>方法来处理数据。&lt;code>collect&lt;/code>接收一个挂起函数作为处理逻辑，但是同时，&lt;code>collect&lt;/code>方法本身也是挂起函数，所以，这个方法只能在挂起函数中运行。有了这些知识，我们就可以写出最简单的异步数据流了。&lt;/p>
&lt;div class="highlight">&lt;div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
&lt;table style="border-spacing:0;padding:0;margin:0;border:0;">&lt;tr>&lt;td style="vertical-align:top;padding:0;margin:0;border:0;">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">13
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">14
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">15
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">16
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#099">1u&lt;/span>spend &lt;span style="color:#000;font-weight:bold">fun&lt;/span> &lt;span style="color:#900;font-weight:bold">compute&lt;/span>():Int{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> delay(&lt;span style="color:#099">123&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">return&lt;/span> &lt;span style="color:#099">1024&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> viewModelScope.launch {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">val&lt;/span> flow=flow&amp;lt;Int&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> emit(&lt;span style="color:#099">9527&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> emit(compute())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> delay(&lt;span style="color:#099">256&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> emit(&lt;span style="color:#099">256&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> flow.collect {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#000;font-weight:bold">it&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在&lt;code>flow&lt;/code>构造器里面随意做各种操作，只要在必要的时候传递结果就行了，但是需要注意的是，&lt;code>emit&lt;/code>方法只能运行在同一个协程里。乍一看，这样分开写和写在一起并没有本质上的差别，但&lt;code>Flow&lt;/code>还能做到更多。&lt;/p>
&lt;h1 id="该给flow换个工作环境了">该给Flow换个工作环境了&lt;/h1>
&lt;p>上一节，我们那个简单的示例，假如把构造器里面的数据获取方法换成网络请求，应用就歇菜了。因为它们都是运行在主线程里面的。那么这个时候，看过上一篇文章的小伙伴马上就会反应过来，用&lt;code>withContext&lt;/code>方法在构造器里面切换线程就行了哇。思路是很对，因为&lt;code>Flow&lt;/code>的默认配置就是构造器和&lt;code>collect&lt;/code>方法工作在同一线程，既然现在主线程不让运行，那就把构造器的线程切换一下就行了呗。然后事实并不是这样，这样写出来的代码根本无法运行。因为官方提供了唯一的&lt;code>flowOn&lt;/code>方法来切换构造器的执行线程。使用也很简单，就是对创建好的&lt;code>Flow&lt;/code>对象配置一次&lt;code>flowOn&lt;/code>方法就行了。&lt;/p>
&lt;div class="highlight">&lt;div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
&lt;table style="border-spacing:0;padding:0;margin:0;border:0;">&lt;tr>&lt;td style="vertical-align:top;padding:0;margin:0;border:0;">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">5
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">6
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">val&lt;/span> flow=[&lt;span style="color:#d14">&amp;#34;1.jpg&amp;#34;&lt;/span>,&lt;span style="color:#d14">&amp;#34;2.jpg&amp;#34;&lt;/span>].asFlow()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>flow.map { decode(&lt;span style="color:#000;font-weight:bold">it&lt;/span>) }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .flowOn(Dispatchers.IO)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>viewModelScope.launch {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> flow.collect{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> adapter.add(&lt;span style="color:#000;font-weight:bold">it&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h1 id="有些中间处理逻辑">有些中间处理逻辑&lt;/h1>
&lt;p>熟悉RxJava的小伙伴可能有疑问了，这些操作RxJava也能完成，甚至还有更多的操作符来支持中间状态的处理，那么异步数据流能做到这些吗。毫无疑问，它可以。普通的数据集有&lt;code>map&lt;/code>,&lt;code>filter&lt;/code>等操作方法，对于异步数据流来说，这些方法同样适用。而且这些方法参数都是挂起函数，都可以执行异步操作。而且它还有个更灵活的&lt;code>transform&lt;/code>方法，这个方法可以定制自己的操作符，实现更灵活的数据操作。&lt;/p>
&lt;p>当然，上面那些操作符都只能实现单一异步流的操作，对于多数据流的支持，它也同样不在话下。&lt;code>zip&lt;/code>可以将两个两个数据源两两合并起来，合成的数据流长度为两个数据流中最短的那个数据流的长度。&lt;code>combine&lt;/code>则与&lt;code>zip&lt;/code>不同，它会将两个数据流最近的发送数据作为输入，也就是说，假如一块一慢的两个数据源，慢的数据源的元素可能会被多次取到，从而最终的数据流比最短的那个都长。&lt;/p>
&lt;div class="highlight">&lt;div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
&lt;table style="border-spacing:0;padding:0;margin:0;border:0;">&lt;tr>&lt;td style="vertical-align:top;padding:0;margin:0;border:0;">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">val&lt;/span> flow = flowOf(&lt;span style="color:#099">1&lt;/span>, &lt;span style="color:#099">2&lt;/span>).delayEach(&lt;span style="color:#099">10&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">val&lt;/span> flow2 = flowOf(&lt;span style="color:#d14">&amp;#34;a&amp;#34;&lt;/span>, &lt;span style="color:#d14">&amp;#34;b&amp;#34;&lt;/span>, &lt;span style="color:#d14">&amp;#34;c&amp;#34;&lt;/span>).delayEach(&lt;span style="color:#099">15&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>flow.combine(flow2) { i, s &lt;span style="color:#000;font-weight:bold">-&amp;gt;&lt;/span> i.toString() + s }.collect {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#000;font-weight:bold">it&lt;/span>) &lt;span style="color:#998;font-style:italic">// Will print &amp;#34;1a 2a 2b 2c&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#998;font-style:italic">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h1 id="结束状态跟踪">结束状态跟踪&lt;/h1>
&lt;p>上一节提到，由于数据源和处理逻辑不在同一个地方，所以很难确定最终的数据流大小，进而不知道数据流什么时候处理结束。而且中间操作也可能会改变数据流的大小，由此就更加难以确定数据处理结束的时机了。但是我们有的时候却需要在数据处理完成后做一些操作，该怎么办呢？这个时候当然是该&lt;code>onCompletion&lt;/code>方法上场了。这个方法有一个可为空的&lt;code>Throwable&lt;/code>类型参数，很显然，这可以同时指示两种处理结果，成功或者失败，失败就会将异常对象传递进来。&lt;/p>
&lt;h1 id="多个协程共同工作">多个协程共同工作&lt;/h1>
&lt;p>很多时候，避免不了让多个协程共同工作。对于返回单个值的协程，上一篇我们也提到过了，可以传递&lt;code>async&lt;/code>构造器的返回对象&lt;code>Deferred&lt;/code>，但是局限性就是这个对象只能传递一个值。针对多值传递的情况，Kotlin提供了&lt;code>Channel&lt;/code>的解决方法。&lt;code>Channel&lt;/code>类似于阻塞队列，数据通过&lt;code>send&lt;/code>方法发送出去，在另外的地方使用&lt;code>receive&lt;/code>方法接收。通过这种方法，我们可以极大提供协程的工作效率。利用它就可以轻松实现生产者和消费者模型。&lt;/p>
&lt;div class="highlight">&lt;div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
&lt;table style="border-spacing:0;padding:0;margin:0;border:0;">&lt;tr>&lt;td style="vertical-align:top;padding:0;margin:0;border:0;">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">val&lt;/span> chanel=Channel&amp;lt;Int&amp;gt;()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> viewModelScope.launch(Dispatchers.IO) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">for&lt;/span> (i &lt;span style="color:#000;font-weight:bold">in&lt;/span> &lt;span style="color:#099">1.&lt;/span>.&lt;span style="color:#099">5&lt;/span>){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> delay(&lt;span style="color:#099">1000&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> chanel.send(i)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> viewModelScope.launch {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">for&lt;/span> (i &lt;span style="color:#000;font-weight:bold">in&lt;/span> chanel){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#d14">&amp;#34;Handle &lt;/span>&lt;span style="color:#d14">${i}&lt;/span>&lt;span style="color:#d14">&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>当然，这只是最简单的用法，还可以加入更多的生产者，或者不再需要数据时取消，甚至还有专门的&lt;code>product&lt;/code>构造器，直接获得返回多个值的协程对象。&lt;/p>
&lt;h1 id="总结">总结&lt;/h1>
&lt;p>Kotlin协程有很多有用的API，这些API覆盖了大部分异步使用的场景。所以在使用协程的时候，我们首先需要明确使用场景，再根据使用场景确定使用哪一套API，这可以使我们避免陷入API恐惧症。为此，我根据这两篇文章的内容，整理出了一份情景表格，实际开发中可以参照使用。
Kotlin协程构造器&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>API&lt;/th>
&lt;th>使用场景&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>launch&lt;/td>
&lt;td>执行耗时操作，不需要返回值&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>async&lt;/td>
&lt;td>需要获取耗时操作的单个返回值&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>produce&lt;/td>
&lt;td>需要获取耗时操作的多个返回值&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>Kotlin协程协同工具&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>API&lt;/th>
&lt;th>使用场景&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Flow&lt;/td>
&lt;td>操作异步数据流&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Channel&lt;/td>
&lt;td>协程间通信&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>青山不改，绿水长流，咱们下期见！&lt;/p></description></item><item><title>用纯HTML，JS，CSS实现横向滚动标签页</title><link>https://hongui.github.io/post/Kotlin%E5%8D%8F%E7%A8%8B-%E4%BB%8E%E7%90%86%E8%AE%BA%E5%88%B0%E5%AE%9E%E6%88%98.html</link><pubDate>Sat, 27 Mar 2021 19:02:30 +0800</pubDate><guid>https://hongui.github.io/post/Kotlin%E5%8D%8F%E7%A8%8B-%E4%BB%8E%E7%90%86%E8%AE%BA%E5%88%B0%E5%AE%9E%E6%88%98.html</guid><description>&lt;blockquote>
&lt;p>上一篇文章从理论上对Kotlin协程进行了部分说明，本文将在上一篇的基础上，从实战出发，继续协程之旅。&lt;/p>
&lt;/blockquote>
&lt;h1 id="从源头说起">从源头说起&lt;/h1>
&lt;p>在Kotlin中，要想使用协程，首先需要使用协程创建器创建，但还有个前提——协程作用域(&lt;code>CoroutineScope&lt;/code>)。在早期的Kotlin实现中，协程创建器是一等函数，也就是说我们随时随地可以通过协程创建器创建协程。但在协程正式发布以后，协程创建器需要在协程作用域对象上才能创建了，Kotlin添加了协程作用域来实现结构化并发。什么是结构化并发呢，通俗地说就是正确实施多个协程监控、管理的能力。在实际业务中，我们可能需要创建多个协程对象来完成不同的工作。为了对这些不相关的协程管理起来，Kotlin引入了协程作用域，通过某个协程作用域创建的协程都会被它管理着，在条件满足的时候，执行每个协程的取消工作或者结束自己。&lt;/p>
&lt;p>为了方便我们直接上手，官方提供了&lt;code>MainScope&lt;/code>和&lt;code>GlobalScope&lt;/code>供我们使用。正如名字那样，他们分别有不同的应用场景，前者比较适合用在UI相关的类中，而后者适用于在整个应用生命周期中都需要存活的类中。当然，对于Android开发者，其实我们有更好的选择——使用&lt;code>ViewModel&lt;/code>的Kotlin扩展，它不仅有着全部的协程作用域功能，开箱即用，而且还在&lt;code>onCleared&lt;/code>方法中实现了自动取消。&lt;/p>
&lt;h1 id="创建协程">创建协程&lt;/h1>
&lt;p>有了协程作用域，那我们来创建一个最简单的协程吧。&lt;/p>
&lt;div class="highlight">&lt;div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
&lt;table style="border-spacing:0;padding:0;margin:0;border:0;">&lt;tr>&lt;td style="vertical-align:top;padding:0;margin:0;border:0;">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>viewModelScope.launch{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#998;font-style:italic">//这里就是协程代码啦啦啦啦
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#998;font-style:italic">&lt;/span> delay(&lt;span style="color:#099">2000&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#000;font-weight:bold">out&lt;/span>.println(&lt;span style="color:#d14">&amp;#34;Hello World&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;code>launch&lt;/code>创建并启动了一个协程，协程启动两秒后，在控制抬打印了Hello World，然后协程就结束了（协程是有完整生命周期的）。这个协程完成的工作有限，我们可以使用线程完成相同的功能:&lt;/p>
&lt;div class="highlight">&lt;div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
&lt;table style="border-spacing:0;padding:0;margin:0;border:0;">&lt;tr>&lt;td style="vertical-align:top;padding:0;margin:0;border:0;">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>thread {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Thread.sleep(&lt;span style="color:#099">2000&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#000;font-weight:bold">out&lt;/span>.println(&lt;span style="color:#d14">&amp;#34;Hello World&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>我们可以看到，除去构建函数，两段代码唯一的区别就是延迟函数——&lt;code>delay&lt;/code>和&lt;code>Thread.sleep&lt;/code>.从功能上看他们都是让后面的代码延迟执行，但是效果却是不一样的，前者不会阻塞线程。这段代码其实是放在主线程里面执行的，但是它不会影响到UI的绘制，而后者假如把它放在主线程执行的话，应用会出现两秒的无响应。Kotlin把这种不会阻塞当前线程执行的函数称之为挂起函数，挂起函数可以在挂起点断开与当前线程的联系，让线程空闲下来完成其他的操作，当条件满足后，挂起函数重新在挂起点恢复，接着往下执行后面的代码。&lt;/p>
&lt;p>还有个小问题没有解决，在上一篇文章中，我曾经说过，挂起函数只能在挂起函数中执行，既然&lt;code>delay&lt;/code>是挂起函数，那么反推，我们的代码块也应该是个挂起函数，而这个挂起函数就是所谓的协程体。&lt;/p>
&lt;h1 id="让协程跨线程工作">让协程跨线程工作&lt;/h1>
&lt;p>如果你看到上面的代码，然后转手在协程体里面写个网络请求的话，你会发现，你的应用崩溃了，这是怎么回事呢？因为协程虽然不会阻塞主线程，但是主线程是不允许进行网络请求的。如果这时你就急着下了协程没啥用的结论，那么你就肤浅了。让我们稍微改一改上面的代码，让它运行在子线程吧。&lt;/p>
&lt;div class="highlight">&lt;div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
&lt;table style="border-spacing:0;padding:0;margin:0;border:0;">&lt;tr>&lt;td style="vertical-align:top;padding:0;margin:0;border:0;">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>viewModelScope.launch (Dispatchers.IO){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#998;font-style:italic">//这里就是协程代码啦啦啦啦
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#998;font-style:italic">&lt;/span> delay(&lt;span style="color:#099">2000&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#000;font-weight:bold">out&lt;/span>.println(&lt;span style="color:#d14">&amp;#34;Hello World&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>很好，现在协程体里面的网络请求可以顺利执行了，但是很快有读者就会发现新问题了——我怎么把网络请求的结果传回主线程呢，难不成还搞个&lt;code>Handler&lt;/code>,那和直接使用线程有什么区别，辣鸡协程。嘿，别急，这个协程其实也为客官处理好了。让我们再次改造一下代码：&lt;/p>
&lt;div class="highlight">&lt;div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
&lt;table style="border-spacing:0;padding:0;margin:0;border:0;">&lt;tr>&lt;td style="vertical-align:top;padding:0;margin:0;border:0;">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">5
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">6
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">7
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">8
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>viewModelScope.launch (Dispatchers.IO){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#998;font-style:italic">//这里就是协程代码啦啦啦啦，这里是在子线程执行的代码哦
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#998;font-style:italic">&lt;/span> &lt;span style="color:#998;font-style:italic">//假装这个是网络请求吧
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#998;font-style:italic">&lt;/span> delay(&lt;span style="color:#099">2000&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> withContext(Dispatchers.Main) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#998;font-style:italic">//哦豁豁，这里竟然运行在主线程哦
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#998;font-style:italic">&lt;/span> System.&lt;span style="color:#000;font-weight:bold">out&lt;/span>.println(&lt;span style="color:#d14">&amp;#34;Hello World&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>很好，我们可以愉快地使用协程处理网络请求了，那么这些魔法是怎么发生的呢，停下脚步，我们来重新审视一下上面的代码。&lt;/p>
&lt;p>首先，相比于最开始的代码，我们的代码里多了两个对象，一个方法调用。首先我们来看那两个对象，从名字中我们不难猜到它就是调度线程的。
Kotlin提供了四个常用的实现&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>Default&lt;/code>,它是标准协程构建者默认使用的调度器，使用共享的线程池工作，适用于计算型的任务；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>Main&lt;/code>,它是代表UI线程的调度器，通常来说只有一个线程，使用这个调度器就可以直接在协程中操作UI;&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>Unconfined&lt;/code>,它没有限定线程范围，它在哪个线程中被调用就会在哪个线程里执行完初始的代码，直到遇到挂起函数，随后它会使用挂起函数指定的调度器恢复，这个过程可以一直持续下去。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>IO&lt;/code>,是用来承载阻塞的IO操作的，如文件读写，网络连接等，是我们比较常用的调度器。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>所以那两个调度器对象是让协程切换工作环境的魔法。接下来还有一个方法调用没有解释。&lt;code>withContext&lt;/code>的作用是将当前的协程调度器切换到指定的调度器上，用这个调度器接着执行构建块中的代码。同时它也是一个挂起函数。提到挂起函数，我们就该想到，它是可恢复的。所以当这个挂起函数的代码块执行完成之后，它会自动恢复成原来的调度器，接着往下执行。&lt;/p>
&lt;h1 id="用协程串联两个异步操作">用协程串联两个异步操作&lt;/h1>
&lt;p>在项目开发中，还有一种常见的应用场景，客户端需要先请求一些配置信息，然后利用配置信息再请求真正的内容信息。这个过程描述起来是串行的，但是代码写起来却是割裂的，需要在第一个网络请求的回调中处理和发起第二个请求，然后在第二个回调中获取真正需要展示的数据，可能这个过程还会加个存库，或者触发另外请求的工作，那么完了，这代码没法看了。这放在以前，这种情况通常会使用RxJava，但是RxJava的代码可读性也还是差点意思。那么Kotlin协程可以写成什么样呢？&lt;/p>
&lt;div class="highlight">&lt;div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
&lt;table style="border-spacing:0;padding:0;margin:0;border:0;">&lt;tr>&lt;td style="vertical-align:top;padding:0;margin:0;border:0;">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">5
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">6
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">7
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">8
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>viewModelScope.launch(Dispatchers.IO) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">val&lt;/span> retrofit=Retrofit.Builder().build()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">val&lt;/span> apiUser=retrofit.create(APIUser&lt;span style="color:#000;font-weight:bold">::&lt;/span>&lt;span style="color:#000;font-weight:bold">class&lt;/span>.java)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">val&lt;/span> user=api.current()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">val&lt;/span> detail=api.userDetail(user.id)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> withContext(Dispatchers.Main) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> userLiveData.&lt;span style="color:#000;font-weight:bold">value&lt;/span>=detail
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这和我们写一般的同步代码一摸一样，没有回调，也不需要付出其他代价，这个过程甚至可以一直加下去。其实我觉得这个才是协程的真正威力。&lt;/p>
&lt;h1 id="让多个协程一起工作">让多个协程一起工作&lt;/h1>
&lt;p>我们继续复杂化使用场景——我在做一个多端使用的笔记App，现在用户打开了某一个已存在的笔记，为了让用户能快速浏览到上一次的操作信息，一方面我需要从文件中读取上一次操作的结果，另一方面我要拉取远程的操作结果，然后对两个结果合并，决定最终的展示数据。考虑到这两个操作其实是并行的，上面我们让协程串联起来的思路已经不适用了，因为协程里面的操作都是串行的。既然一个协程解决不了，我们再加一个协程可不可以呢？看着好像是可以，但是，协程操作的结果我们怎么获取到呢？查阅API，我找到了另一个协程构建器&lt;code>async&lt;/code>。它会返回一个协程对象，然后通过&lt;code>await&lt;/code>方法获取到协程的计算结果。思路来了，我们马上动手&lt;/p>
&lt;div class="highlight">&lt;div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
&lt;table style="border-spacing:0;padding:0;margin:0;border:0;">&lt;tr>&lt;td style="vertical-align:top;padding:0;margin:0;border:0;">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">13
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">14
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">15
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">val&lt;/span> fileResult=viewModelScope.async(Dispatchers.IO) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#998;font-style:italic">//假装是读文件的代码吧
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#998;font-style:italic">&lt;/span> &lt;span style="color:#099">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">val&lt;/span> networkResult=viewModelScope.async(Dispatchers.IO) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#998;font-style:italic">//也是假装是网络请求的代码
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#998;font-style:italic">&lt;/span> &lt;span style="color:#099">2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">val&lt;/span> fResult=fileResult.await()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">val&lt;/span> rResult=networkResult.await()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">val&lt;/span> result=&lt;span style="color:#000;font-weight:bold">if&lt;/span>(fResult&amp;gt;rResult){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fResult
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}&lt;span style="color:#000;font-weight:bold">else&lt;/span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> networkResult
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>然后你就会发现报错了，&lt;code>await&lt;/code>是挂起函数。看来两个协程还完成不了，要三个，所以，让我们创建第三个协程吧&lt;/p>
&lt;div class="highlight">&lt;div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
&lt;table style="border-spacing:0;padding:0;margin:0;border:0;">&lt;tr>&lt;td style="vertical-align:top;padding:0;margin:0;border:0;">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#998;font-style:italic">//前面的两个协程不变
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#998;font-style:italic">&lt;/span> viewModelScope.launch {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">val&lt;/span> fResult=fileResult.await()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">val&lt;/span> rResult=networkResult.await()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">val&lt;/span> result=&lt;span style="color:#000;font-weight:bold">if&lt;/span>(fResult&amp;gt;rResult){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fResult
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }&lt;span style="color:#000;font-weight:bold">else&lt;/span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> networkResult
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这就是协程间通信的基本写法啦，从这个基础之上，甚至还能衍生出更复杂的版本，但是万变不离其宗，都可以参考这种思路完成。&lt;/p>
&lt;h1 id="协程的取消">协程的取消&lt;/h1>
&lt;p>正如之前提到的一样，协程有着类似于线程的完整生命周期，包括创建，激活，完成中（取消中），已完成（已取消），刚才我们的示例都是正常状态，协程完成工作后会自动结束，但协程的另一条取消流程我们还没有提到。协程有自己的取消API——&lt;code>cancel&lt;/code>可供使用，我们只需要保存好协程创建者返回的协程对象就行了。当然更常见的还是文章开篇提到的使用协程作用域取消。这个操作会取消所有的协程。&lt;/p>
&lt;h1 id="总结">总结&lt;/h1>
&lt;p>本篇文章从协程创建开始，讲到了怎样用协程写出异步代码，怎么让多个协程共同工作，虽然覆盖了很大一部分使用场景，但是依然还有遗漏。由于篇幅限制，遗漏部分将在下一篇博文中继续讲解，希望大家持续关注。&lt;/p>
&lt;p>青山不改，绿水长流，咱们下期见！&lt;/p></description></item><item><title>Kotlin协程-那些理不清乱不明的关系</title><link>https://hongui.github.io/post/Kotlin%E5%8D%8F%E7%A8%8B-%E9%82%A3%E4%BA%9B%E7%90%86%E4%B8%8D%E6%B8%85%E4%B9%B1%E4%B8%8D%E6%98%8E%E7%9A%84%E5%85%B3%E7%B3%BB.html</link><pubDate>Fri, 26 Mar 2021 18:50:29 +0800</pubDate><guid>https://hongui.github.io/post/Kotlin%E5%8D%8F%E7%A8%8B-%E9%82%A3%E4%BA%9B%E7%90%86%E4%B8%8D%E6%B8%85%E4%B9%B1%E4%B8%8D%E6%98%8E%E7%9A%84%E5%85%B3%E7%B3%BB.html</guid><description>&lt;blockquote>
&lt;p>Kotlin的协程自推出以来，受到了越来越多Android开发者的追捧。另一方面由于它庞大的API，也将相当一部分开发者拒之门外。本篇试图从协程的几个重要概念入手，在复杂API中还原出它本来的面目，以全新的角度带读者走进Kotlin协程世界。&lt;/p>
&lt;/blockquote>
&lt;h1 id="什么是协程">什么是协程&lt;/h1>
&lt;p>在很多有关协程的文章中，描述协程通常会用这样的一句描述——协程比线程更加轻量，是可取消的。这句话没有错，这两个都是协程的优点，但是并不是特点，它并没有解释协程是什么。那么什么是协程的特点呢，我觉得可以先用线程做个类比，&lt;em>&lt;strong>解释一个概念最好的办法就是类比。&lt;/strong>&lt;/em> 我不打算使用科学严谨的描述，我想给线程一个我自己的定义——线程是一个可供CPU调度的执行单元，它有自己的执行块，可以独立地执行逻辑。我特意将线程的三个关键特征列举出来了：&lt;/p>
&lt;ul>
&lt;li>线程由CPU调度&lt;/li>
&lt;li>线程拥有自己的代码块&lt;/li>
&lt;li>代码块需要才能调度执行&lt;/li>
&lt;/ul>
&lt;p>这是我对线程的直观感受，并且这些特点是能从代码上体现出来的。如Java中的&lt;code>Thread&lt;/code>，它是线程的同时，也是一个实体对象，能通过API来认识它，使用它。而它的特别之处就是我上面列举的三点，这些都是线程特有的。我试着用相同的思路来给协程下一个自己的定义——协程是由线程调度执行的执行单元，它也有自己的执行块，可以独立或者协同执行逻辑。其实Kotlin中的协程也有自己对应实体和操作API，甚至和线程的还很像(如生命周期），但是由于Kotlin对协程的封装过于彻底，很多API没有暴露出来，以至于我对协程的认识一直处于盲人摸象的状态。另外，其实协程是有多种实现方式的，以下我的观点仅针对Kotlin的协程实现，可能与其他语言的实现不一致。&lt;/p>
&lt;p>&lt;em>&lt;strong>Kotlin中的协程对象本质上来讲就是个可执行的代码块，&lt;/strong>&lt;/em> 执行的代码就是创建协程传递进去的。除此之外它还有个最大的特点——协程是不和线程绑定的。它可以在某个时刻断开当前的线程，然后在其他时候，附着到其他线程上。也就是说，它像一个乒乓球，线程就好比是球拍，它可以在球拍间反复横跳。所以，结合这两个特点，官方给协程的定义是 &lt;em>&lt;strong>一个可挂起的计算实体&lt;/strong>&lt;/em>。我觉得这个定义不算精确，它只体现了挂起这个概念，没有体现恢复的概念。我给它一个我自己的定义——&lt;em>&lt;strong>一个可被调度的计算实体&lt;/strong>&lt;/em>。&lt;/p>
&lt;h1 id="协程中几个关键概念">协程中几个关键概念&lt;/h1>
&lt;p>明白了协程是什么还不够，因为Kotlin的协程还涉及到很多方面，有几个关键概念需要理解。&lt;/p>
&lt;h2 id="挂起函数">挂起函数&lt;/h2>
&lt;p>提到Kotlin的协程就不得不提到挂起函数，这是Kotlin协程实现的最重要的概念之一。简单来说，&lt;em>&lt;strong>挂起函数是一种异步实现方案，它是一个普通函数的前提下，还具备挂起和恢复的特性。&lt;/strong>&lt;/em> 它是解决耗时计算和结果传递的一种方案。那么它和我们常见的基于回调的方案相比，有什么不同呢。在基于回调的方案中，计算过程和结果没有关系，结果需要通过另一个对象，在计算完成后由计算过程手动传递，而这一过程是可能被反复嵌套的，从而导致，一些本该是串行化的代码，被割裂成几个部分，分散到不同的代码块中。如以下读写文件的代码&lt;/p>
&lt;div class="highlight">&lt;div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
&lt;table style="border-spacing:0;padding:0;margin:0;border:0;">&lt;tr>&lt;td style="vertical-align:top;padding:0;margin:0;border:0;">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">13
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">14
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">15
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">16
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#998;font-style:italic">// asynchronously read into `buf`, and when done run the lambda
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#998;font-style:italic">&lt;/span> inChannel.read(buf) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#998;font-style:italic">// this lambda is executed when the reading completes
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#998;font-style:italic">&lt;/span> bytesRead &lt;span style="color:#000;font-weight:bold">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">..&lt;/span>.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">..&lt;/span>.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> process(buf, bytesRead)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#998;font-style:italic">// asynchronously write from `buf`, and when done run the lambda
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#998;font-style:italic">&lt;/span> outChannel.write(buf) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#998;font-style:italic">// this lambda is executed when the writing completes
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#998;font-style:italic">&lt;/span> &lt;span style="color:#000;font-weight:bold">..&lt;/span>.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">..&lt;/span>.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> outFile.close()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>同样的逻辑，将&lt;code>read&lt;/code>和&lt;code>write&lt;/code>实现为挂起函数后，能写成什么样呢？&lt;/p>
&lt;div class="highlight">&lt;div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
&lt;table style="border-spacing:0;padding:0;margin:0;border:0;">&lt;tr>&lt;td style="vertical-align:top;padding:0;margin:0;border:0;">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">13
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">14
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span> launch {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#998;font-style:italic">// suspend while asynchronously reading
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#998;font-style:italic">&lt;/span> &lt;span style="color:#000;font-weight:bold">val&lt;/span> bytesRead = inChannel.aRead(buf)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#998;font-style:italic">// we only get to this line when reading completes
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#998;font-style:italic">&lt;/span> &lt;span style="color:#000;font-weight:bold">..&lt;/span>.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">..&lt;/span>.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> process(buf, bytesRead)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#998;font-style:italic">// suspend while asynchronously writing
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#998;font-style:italic">&lt;/span> outChannel.aWrite(buf)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#998;font-style:italic">// we only get to this line when writing completes
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#998;font-style:italic">&lt;/span> &lt;span style="color:#000;font-weight:bold">..&lt;/span>.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">..&lt;/span>.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> outFile.close()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这是Kotlin官方给的一个例子，可以看出挂起函数的实现非常符合直觉，是和思考过程保持一致的，同时还减少了大量的嵌套。&lt;/p>
&lt;p>为了更好地解释挂起函数，我还需要引入了一个新的概念——挂起点。
挂起点是一个分界点，代表着从这个时刻之后，执行过程可能会转移到其他地方执行，然后在某个时刻，再从这个点恢复，继续往下执行。这个过程中，当前线程不会被阻塞。所以 &lt;em>&lt;strong>挂起函数其实实现了异步非阻塞的通信模式。&lt;/strong>&lt;/em>&lt;/p>
&lt;p>一句话总结，挂起函数是一种不阻塞当前线程，并能返回异步计算结果的函数。&lt;/p>
&lt;h2 id="协程创建者">协程创建者&lt;/h2>
&lt;p>前面提到的挂起函数虽然好，但是有个限制，普通方法是不能调用挂起函数的，只能通过挂起函数调用。那么就出现了先有鸡还是先有蛋的问题。解决这个问题的方法就是协程创建者。&lt;code>launch&lt;/code>, &lt;code>future&lt;/code>, &lt;code>sequence&lt;/code>都是协程创建者。顾名思义，协程创建者是用来创建协程对象的，除此之外和普通函数没有区别。它们就是通往协程世界和挂起函数的大门。在这个大门里，我们可以尽情地使用挂起函数，简化我们的计算过程。当然，这些都不是固定不变的，这些函数都有多个配置参数，其中最重要的就是&lt;code>CoroutineContext&lt;/code>。&lt;/p>
&lt;h2 id="coroutinecontext">&lt;code>CoroutineContext&lt;/code>&lt;/h2>
&lt;p>&lt;code>CoroutineContext&lt;/code>的作用是提供协程的各种配置信息，&lt;em>&lt;strong>本质上就是保存非重复元素的容器(Set)&lt;/strong>&lt;/em>，里面的元素可以根据Key获取到（如调度器），称之为元素（Element）。这里，我忍不住想把它的接口定义放出来，因为实在是太美了。&lt;/p>
&lt;div class="highlight">&lt;div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
&lt;table style="border-spacing:0;padding:0;margin:0;border:0;">&lt;tr>&lt;td style="vertical-align:top;padding:0;margin:0;border:0;">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">interface&lt;/span> &lt;span style="color:#458;font-weight:bold">CoroutineContext&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">operator&lt;/span> &lt;span style="color:#000;font-weight:bold">fun&lt;/span> &amp;lt;&lt;span style="color:#458;font-weight:bold">E&lt;/span> : &lt;span style="color:#458;font-weight:bold">Element&lt;/span>&amp;gt; &lt;span style="color:#900;font-weight:bold">get&lt;/span>(key: Key&amp;lt;E&amp;gt;): E?
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">fun&lt;/span> &amp;lt;&lt;span style="color:#458;font-weight:bold">R&lt;/span>&amp;gt; &lt;span style="color:#900;font-weight:bold">fold&lt;/span>(initial: R, operation: (R, Element) &lt;span style="color:#000;font-weight:bold">-&amp;gt;&lt;/span> R): R
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">operator&lt;/span> &lt;span style="color:#000;font-weight:bold">fun&lt;/span> &lt;span style="color:#900;font-weight:bold">plus&lt;/span>(context: CoroutineContext): CoroutineContext
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">fun&lt;/span> &lt;span style="color:#900;font-weight:bold">minusKey&lt;/span>(key: Key&amp;lt;*&amp;gt;): CoroutineContext
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">interface&lt;/span> &lt;span style="color:#458;font-weight:bold">Element&lt;/span> : CoroutineContext {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">val&lt;/span> key: Key&amp;lt;*&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">interface&lt;/span> &lt;span style="color:#458;font-weight:bold">Key&lt;/span>&amp;lt;E : Element&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>以上就是Kotlin中对&lt;code>CoroutineContext&lt;/code>的定义，这些API每个都有其巧妙的用途，让人叹服&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>get&lt;/code>目的是根据Key获取对应的对象，这个方法的奇特之处就是查询参数。利用这个方法在执行某个操作之前判断&lt;code>CoroutineContext&lt;/code>是否有某个配置对象，从而实现一种权限认证。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>fold&lt;/code>其实就是一种迭代算法，可以对全部元素进行检查。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>plus&lt;/code>这就很有意思了，它可以让两个对象合并起来，并且当&lt;code>key&lt;/code>相同时使用右侧的对象覆盖左侧的对象。这在我们的协程使用中绝对是最灵活的API了。我们可以使用+替换调原本的调度器，使用我们给定的调度器，而且看起来是那么自然。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>minusKey&lt;/code>返回不包含指定&lt;code>key&lt;/code>的&lt;code>context&lt;/code>，相当于一种取反操作，这在某些情境下非常有用。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>我觉得这应该算得上是对抽象的极致体现了，这个接口用简单的API抽象了增删改查四个操作，并且保留了强大的扩展性。在最开始接触协程的时候，我常常对协程复杂的工作机制和简单的参数配置产生了深深的怀疑，直到我看到了这个定义，我才明白它真正的强大之处，它不仅可以用系统默认的工作配置完成工作，还允许用户实现自己的&lt;code>CoroutineContext&lt;/code>来随时替换掉默认配置，完成自己定制化的任务。&lt;/p>
&lt;h2 id="continuation">&lt;code>Continuation&lt;/code>&lt;/h2>
&lt;p>&lt;code>Continuation&lt;/code>不是Kotlin特有的概念，它在维基上的解释是一种控制状态的抽象表示。而在Kotlin中，它是对协程在挂起点的一个状态抽象，这可能不太好理解，我们可以通过具体的API来将这个概念具体化。&lt;/p>
&lt;div class="highlight">&lt;div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
&lt;table style="border-spacing:0;padding:0;margin:0;border:0;">&lt;tr>&lt;td style="vertical-align:top;padding:0;margin:0;border:0;">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">interface&lt;/span> &lt;span style="color:#458;font-weight:bold">Continuation&lt;/span>&amp;lt;&lt;span style="color:#000;font-weight:bold">in&lt;/span> T&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">val&lt;/span> context: CoroutineContext
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">fun&lt;/span> &lt;span style="color:#900;font-weight:bold">resumeWith&lt;/span>(result: Result&amp;lt;T&amp;gt;)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>它有个关键的函数——resumeWith，它表示在挂起状态之后的某个时刻，通过这个状态对象从原来的位置恢复过来。这是挂起函数实现的关键。而这里面的控制状态就是由参数体现了，成功或者失败，所以它还有两个扩展方法：&lt;/p>
&lt;div class="highlight">&lt;div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
&lt;table style="border-spacing:0;padding:0;margin:0;border:0;">&lt;tr>&lt;td style="vertical-align:top;padding:0;margin:0;border:0;">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">fun&lt;/span> &amp;lt;&lt;span style="color:#458;font-weight:bold">T&lt;/span>&amp;gt; &lt;span style="color:#900;font-weight:bold">Continuation&lt;/span>&amp;lt;T&amp;gt;.resume(&lt;span style="color:#000;font-weight:bold">value&lt;/span>: T)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">fun&lt;/span> &amp;lt;&lt;span style="color:#458;font-weight:bold">T&lt;/span>&amp;gt; &lt;span style="color:#900;font-weight:bold">Continuation&lt;/span>&amp;lt;T&amp;gt;.resumeWithException(exception: Throwable)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h1 id="总结">总结&lt;/h1>
&lt;p>协程是一个可被调度的计算实体，可通过协程创建者创建，在协程的代码块里可以使用挂起函数，它能必要的时候挂起，然后在条件满足后恢复，完成异步代码的串行化编程。&lt;/p>
&lt;p>以上就是理解协程的关键概念，在实际使用协程的过程中可能用不到很多，但是却会对我们理解其运作过程很有帮助，也是写出标准协程代码的关键。Kotlin协程并没有很多黑魔法，只是为了适用多种不同的使用场景，有了庞大的API，本篇文章就是对这些API的一个概括解释，后面将会针对各种场景再进行详细梳理，希望大家喜欢。&lt;/p>
&lt;p>青山不改，绿水长流，咱们下期见！&lt;/p></description></item></channel></rss>