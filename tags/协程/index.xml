<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>协程 on 低头沉思</title><link>https://hongui.github.io/tags/%E5%8D%8F%E7%A8%8B/</link><description>Recent content in 协程 on 低头沉思</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Tue, 30 Mar 2021 19:10:30 +0800</lastBuildDate><atom:link href="https://hongui.github.io/tags/%E5%8D%8F%E7%A8%8B/index.xml" rel="self" type="application/rss+xml"/><item><title> Kotlin协程-从一到多</title><link>https://hongui.github.io/post/%20Kotlin%E5%8D%8F%E7%A8%8B-%E4%BB%8E%E4%B8%80%E5%88%B0%E5%A4%9A.html</link><pubDate>Tue, 30 Mar 2021 19:10:30 +0800</pubDate><guid>https://hongui.github.io/post/%20Kotlin%E5%8D%8F%E7%A8%8B-%E4%BB%8E%E4%B8%80%E5%88%B0%E5%A4%9A.html</guid><description>上一篇文章，我介绍了Kotlin协程的创建，使用，协作等内容。本篇将引入更多的使用场景，继续带你走进协程世界。
使用协程处理异步数据流 常用编程语言都会内置对同一类型不同对象的数据集表示，我们通常称之为容器类。不同的容器类适用于不同的使用场景。Kotlin的Flow就是在异步计算的需求下引入的，用于表示异步的数据流。
Flow “问渠哪得清如许，为有源头活水来”，异步数据流的基本就是以某种方式获得异步数据。Kotlin提供了多种种方式，比较常用的就是Kotlin协程包的asFlow扩展和flow构造器。前者是对普通数据集的Flow化封装，没有更多可言，我们着重来看后者。 flow构造器的主要目标就是产生一个异步数据流，它是一个泛型函数，参数是一个挂起函数，并且是FlowCollector是扩展函数。这个接口只有一个emit方法，就是为创建的Flow提供异步计算的数据的，因为它是挂起函数，所以我们能在里面使用其他挂起函数计算异步值，然后通过emit方法将值发送出去，如此反复就能为下游操作提供源源不断的数据流了。 事情还没完，上面的步骤我们只是规定了创建数据的方式，并没有真正执行，也就是建好了道路，但是还没有车上路。那么，怎样才能让车在路上跑呢，查看Flow的接口会发现，它提供了collect方法来处理数据。collect接收一个挂起函数作为处理逻辑，但是同时，collect方法本身也是挂起函数，所以，这个方法只能在挂起函数中运行。有了这些知识，我们就可以写出最简单的异步数据流了。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 1uspend fun compute():Int{ delay(123) return 1024 } viewModelScope.launch { val flow=flow&amp;lt;Int&amp;gt; { emit(9527) emit(compute()) delay(256) emit(256) } flow.collect { println(it) } } 在flow构造器里面随意做各种操作，只要在必要的时候传递结果就行了，但是需要注意的是，emit方法只能运行在同一个协程里。乍一看，这样分开写和写在一起并没有本质上的差别，但Flow还能做到更多。
该给Flow换个工作环境了 上一节，我们那个简单的示例，假如把构造器里面的数据获取方法换成网络请求，应用就歇菜了。因为它们都是运行在主线程里面的。那么这个时候，看过上一篇文章的小伙伴马上就会反应过来，用withContext方法在构造器里面切换线程就行了哇。思路是很对，因为Flow的默认配置就是构造器和collect方法工作在同一线程，既然现在主线程不让运行，那就把构造器的线程切换一下就行了呗。然后事实并不是这样，这样写出来的代码根本无法运行。因为官方提供了唯一的flowOn方法来切换构造器的执行线程。使用也很简单，就是对创建好的Flow对象配置一次flowOn方法就行了。
1 2 3 4 5 6 7 val flow=[&amp;#34;1.jpg&amp;#34;,&amp;#34;2.jpg&amp;#34;].asFlow() flow.map { decode(it) } .flowOn(Dispatchers.IO) viewModelScope.launch { flow.collect{ adapter.add(it) } 有些中间处理逻辑 熟悉RxJava的小伙伴可能有疑问了，这些操作RxJava也能完成，甚至还有更多的操作符来支持中间状态的处理，那么异步数据流能做到这些吗。毫无疑问，它可以。普通的数据集有map,filter等操作方法，对于异步数据流来说，这些方法同样适用。而且这些方法参数都是挂起函数，都可以执行异步操作。而且它还有个更灵活的transform方法，这个方法可以定制自己的操作符，实现更灵活的数据操作。</description></item><item><title>用纯HTML，JS，CSS实现横向滚动标签页</title><link>https://hongui.github.io/post/Kotlin%E5%8D%8F%E7%A8%8B-%E4%BB%8E%E7%90%86%E8%AE%BA%E5%88%B0%E5%AE%9E%E6%88%98.html</link><pubDate>Sat, 27 Mar 2021 19:02:30 +0800</pubDate><guid>https://hongui.github.io/post/Kotlin%E5%8D%8F%E7%A8%8B-%E4%BB%8E%E7%90%86%E8%AE%BA%E5%88%B0%E5%AE%9E%E6%88%98.html</guid><description>上一篇文章从理论上对Kotlin协程进行了部分说明，本文将在上一篇的基础上，从实战出发，继续协程之旅。
从源头说起 在Kotlin中，要想使用协程，首先需要使用协程创建器创建，但还有个前提——协程作用域(CoroutineScope)。在早期的Kotlin实现中，协程创建器是一等函数，也就是说我们随时随地可以通过协程创建器创建协程。但在协程正式发布以后，协程创建器需要在协程作用域对象上才能创建了，Kotlin添加了协程作用域来实现结构化并发。什么是结构化并发呢，通俗地说就是正确实施多个协程监控、管理的能力。在实际业务中，我们可能需要创建多个协程对象来完成不同的工作。为了对这些不相关的协程管理起来，Kotlin引入了协程作用域，通过某个协程作用域创建的协程都会被它管理着，在条件满足的时候，执行每个协程的取消工作或者结束自己。
为了方便我们直接上手，官方提供了MainScope和GlobalScope供我们使用。正如名字那样，他们分别有不同的应用场景，前者比较适合用在UI相关的类中，而后者适用于在整个应用生命周期中都需要存活的类中。当然，对于Android开发者，其实我们有更好的选择——使用ViewModel的Kotlin扩展，它不仅有着全部的协程作用域功能，开箱即用，而且还在onCleared方法中实现了自动取消。
创建协程 有了协程作用域，那我们来创建一个最简单的协程吧。
1 2 3 4 5 viewModelScope.launch{ //这里就是协程代码啦啦啦啦 delay(2000) System.out.println(&amp;#34;Hello World&amp;#34;) } launch创建并启动了一个协程，协程启动两秒后，在控制抬打印了Hello World，然后协程就结束了（协程是有完整生命周期的）。这个协程完成的工作有限，我们可以使用线程完成相同的功能:
1 2 3 4 thread { Thread.sleep(2000) System.out.println(&amp;#34;Hello World&amp;#34;) } 我们可以看到，除去构建函数，两段代码唯一的区别就是延迟函数——delay和Thread.sleep.从功能上看他们都是让后面的代码延迟执行，但是效果却是不一样的，前者不会阻塞线程。这段代码其实是放在主线程里面执行的，但是它不会影响到UI的绘制，而后者假如把它放在主线程执行的话，应用会出现两秒的无响应。Kotlin把这种不会阻塞当前线程执行的函数称之为挂起函数，挂起函数可以在挂起点断开与当前线程的联系，让线程空闲下来完成其他的操作，当条件满足后，挂起函数重新在挂起点恢复，接着往下执行后面的代码。
还有个小问题没有解决，在上一篇文章中，我曾经说过，挂起函数只能在挂起函数中执行，既然delay是挂起函数，那么反推，我们的代码块也应该是个挂起函数，而这个挂起函数就是所谓的协程体。
让协程跨线程工作 如果你看到上面的代码，然后转手在协程体里面写个网络请求的话，你会发现，你的应用崩溃了，这是怎么回事呢？因为协程虽然不会阻塞主线程，但是主线程是不允许进行网络请求的。如果这时你就急着下了协程没啥用的结论，那么你就肤浅了。让我们稍微改一改上面的代码，让它运行在子线程吧。
1 2 3 4 5 viewModelScope.launch (Dispatchers.IO){ //这里就是协程代码啦啦啦啦 delay(2000) System.out.println(&amp;#34;Hello World&amp;#34;) } 很好，现在协程体里面的网络请求可以顺利执行了，但是很快有读者就会发现新问题了——我怎么把网络请求的结果传回主线程呢，难不成还搞个Handler,那和直接使用线程有什么区别，辣鸡协程。嘿，别急，这个协程其实也为客官处理好了。让我们再次改造一下代码：
1 2 3 4 5 6 7 8 9 viewModelScope.launch (Dispatchers.IO){ //这里就是协程代码啦啦啦啦，这里是在子线程执行的代码哦 //假装这个是网络请求吧 delay(2000) withContext(Dispatchers.Main) { //哦豁豁，这里竟然运行在主线程哦 System.out.println(&amp;#34;Hello World&amp;#34;) } } 很好，我们可以愉快地使用协程处理网络请求了，那么这些魔法是怎么发生的呢，停下脚步，我们来重新审视一下上面的代码。
首先，相比于最开始的代码，我们的代码里多了两个对象，一个方法调用。首先我们来看那两个对象，从名字中我们不难猜到它就是调度线程的。 Kotlin提供了四个常用的实现</description></item><item><title>Kotlin协程-那些理不清乱不明的关系</title><link>https://hongui.github.io/post/Kotlin%E5%8D%8F%E7%A8%8B-%E9%82%A3%E4%BA%9B%E7%90%86%E4%B8%8D%E6%B8%85%E4%B9%B1%E4%B8%8D%E6%98%8E%E7%9A%84%E5%85%B3%E7%B3%BB.html</link><pubDate>Fri, 26 Mar 2021 18:50:29 +0800</pubDate><guid>https://hongui.github.io/post/Kotlin%E5%8D%8F%E7%A8%8B-%E9%82%A3%E4%BA%9B%E7%90%86%E4%B8%8D%E6%B8%85%E4%B9%B1%E4%B8%8D%E6%98%8E%E7%9A%84%E5%85%B3%E7%B3%BB.html</guid><description>Kotlin的协程自推出以来，受到了越来越多Android开发者的追捧。另一方面由于它庞大的API，也将相当一部分开发者拒之门外。本篇试图从协程的几个重要概念入手，在复杂API中还原出它本来的面目，以全新的角度带读者走进Kotlin协程世界。
什么是协程 在很多有关协程的文章中，描述协程通常会用这样的一句描述——协程比线程更加轻量，是可取消的。这句话没有错，这两个都是协程的优点，但是并不是特点，它并没有解释协程是什么。那么什么是协程的特点呢，我觉得可以先用线程做个类比，解释一个概念最好的办法就是类比。 我不打算使用科学严谨的描述，我想给线程一个我自己的定义——线程是一个可供CPU调度的执行单元，它有自己的执行块，可以独立地执行逻辑。我特意将线程的三个关键特征列举出来了：
线程由CPU调度 线程拥有自己的代码块 代码块需要才能调度执行 这是我对线程的直观感受，并且这些特点是能从代码上体现出来的。如Java中的Thread，它是线程的同时，也是一个实体对象，能通过API来认识它，使用它。而它的特别之处就是我上面列举的三点，这些都是线程特有的。我试着用相同的思路来给协程下一个自己的定义——协程是由线程调度执行的执行单元，它也有自己的执行块，可以独立或者协同执行逻辑。其实Kotlin中的协程也有自己对应实体和操作API，甚至和线程的还很像(如生命周期），但是由于Kotlin对协程的封装过于彻底，很多API没有暴露出来，以至于我对协程的认识一直处于盲人摸象的状态。另外，其实协程是有多种实现方式的，以下我的观点仅针对Kotlin的协程实现，可能与其他语言的实现不一致。
Kotlin中的协程对象本质上来讲就是个可执行的代码块， 执行的代码就是创建协程传递进去的。除此之外它还有个最大的特点——协程是不和线程绑定的。它可以在某个时刻断开当前的线程，然后在其他时候，附着到其他线程上。也就是说，它像一个乒乓球，线程就好比是球拍，它可以在球拍间反复横跳。所以，结合这两个特点，官方给协程的定义是 一个可挂起的计算实体。我觉得这个定义不算精确，它只体现了挂起这个概念，没有体现恢复的概念。我给它一个我自己的定义——一个可被调度的计算实体。
协程中几个关键概念 明白了协程是什么还不够，因为Kotlin的协程还涉及到很多方面，有几个关键概念需要理解。
挂起函数 提到Kotlin的协程就不得不提到挂起函数，这是Kotlin协程实现的最重要的概念之一。简单来说，挂起函数是一种异步实现方案，它是一个普通函数的前提下，还具备挂起和恢复的特性。 它是解决耗时计算和结果传递的一种方案。那么它和我们常见的基于回调的方案相比，有什么不同呢。在基于回调的方案中，计算过程和结果没有关系，结果需要通过另一个对象，在计算完成后由计算过程手动传递，而这一过程是可能被反复嵌套的，从而导致，一些本该是串行化的代码，被割裂成几个部分，分散到不同的代码块中。如以下读写文件的代码
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // asynchronously read into `buf`, and when done run the lambda inChannel.read(buf) { // this lambda is executed when the reading completes bytesRead -&amp;gt; ... ... process(buf, bytesRead) // asynchronously write from `buf`, and when done run the lambda outChannel.</description></item></channel></rss>