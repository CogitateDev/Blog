<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>学习指南 on 低头沉思</title><link>https://bravebuffalo.cc/tags/%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/</link><description>Recent content in 学习指南 on 低头沉思</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Tue, 09 May 2023 22:14:38 +0800</lastBuildDate><atom:link href="https://bravebuffalo.cc/tags/%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/index.xml" rel="self" type="application/rss+xml"/><item><title>Android-OpenGLES学习-画个颜色</title><link>https://bravebuffalo.cc/post/Android-OpenGLES%E5%AD%A6%E4%B9%A0-%E7%94%BB%E4%B8%AA%E9%A2%9C%E8%89%B2.html</link><pubDate>Tue, 09 May 2023 22:14:38 +0800</pubDate><guid>https://bravebuffalo.cc/post/Android-OpenGLES%E5%AD%A6%E4%B9%A0-%E7%94%BB%E4%B8%AA%E9%A2%9C%E8%89%B2.html</guid><description>我们知道屏幕显示出内容是靠一个一个发光的RGB灯珠，而决定灯珠亮度的是一块内存区域，通过往这一块内存区域写入数据，我们就能在屏幕上观察到数据显示效果。这是个复杂又灵活的工作，为了方便完成这项工作，先驱们制定出了OpenGL标准，我们的故事也将从这里开始。
OpenGL ES #OpenGL ES是OpenGL的精简版本，Android平台从发行伊始就提供了OpenGL ES的支持，只是不同的版本，支持的OpenGL ES版本不同，目前主流的版本还是2.0和3.0。OpenGL ES是一组API，为开发者提供配置数据，传输数据，绘制内容的能力。它的工作是和绘制严格相关的，所以光是OpenGL ES不会造成很大的理解障碍，问题出在配置OpenGL ES的配置环境上。为什么要将OpenGL ES API和配置环境分开呢，因为OpenGL ES是跨平台的API，但是实际运行的时候需要和特定平台绑定，如Android。平台间准备OpenGL ES环境所需要的条件不同，为了保证OpenGL ES的跨平台能力，就需要将配置环境单独拿出来和特定平台绑定。在Android上这个配置环境就是EGL。明确OpenGL ES API和配置OpenGL ES环境的区别不仅对理解这两个关键概念有很大帮助，更是对后期调试代码，排错帮助极大。
工作流程 #明确了一些基本概念之后，我们接下来最重要的任务是理清OpenGL ES的工作流程。很多教程一上来就列举一大堆名词或者直接上实例，我觉得是不妥的。只有熟悉了工作流程，我们在写代码的时候才能做到心中有数，才能在排错过程中更快更准确地定位问题。
准备环境 #OpenGL ES是由一系列API组成的，但是不代表可以在任何时机下调用这些API，而是需要运行环境进行一些设置，这就是准备环境。准备环境通常是做一些显存分配，窗口配置的工作，很繁琐却必不可少。
准备着色器 #着色器很重要，但是对于初学者来说不需要用太多的精力来关注它，很多效果直接可以在网上找到现成的代码，但是怎样将这些代码组装成一个完整可运行的程序却不一定有。我们只需要明确着色器是OpenGL ES开发中的重要一环，这一环这一是魔法发生的地方。
准备程序 #着色器虽然重要，但是也不能独立运行，需要由一个程序管理。这里说的程序是一个OpenGL ES对象，它负责将着色器组装在一起。在运行大部分OpenGL ES API前都需要先使用到这个对像。
渲染 #渲染环节其实也是在准备数据，我们需要将着色器中用到的一些数据赋值，然后调用绘制API，完成最后的绘制工作。GPU会将数据传递给着色器，着色器经过流水线，将数据转换成最终的显示数据存储在显存中。
上屏 #渲染不代表就是将数据显示出来了，而是说数据计算好了。计算好的数据要想在屏幕上看到，可能需要调用OpenGL ES环境配置工具中的某个函数，如交换缓冲或者切换显示对象。
清理 #和内存一样，我们使用OpenGL ES API也会申请到一些资源，在渲染结束后，我们应该主动将资源释放，以便后续程序使用。很多时候我们正常申请资源没有成功，可能是前面有资源没有释放的原因。
以上就是开发OpenGL ES应用的大致流程。由于OpenGL ES开发不好排错，所以在发现问题时最有效的定位方法是确定出错环节，然后再针对性地处理。所以熟悉流程很重要。
实例上手 #由于OpenGLES相关概念很多，为了尽可能减少相关概念的干扰，本文打算只将上述流程中的第一步拿出来着重讲解。同时利用涉及到的知识点，实现一个最小的示例——将窗口染成红色。
下面开始讲解第一个概念——EGL。
EGL #OpenGL ES只是对绘图的抽象，没有提供运行环境的抽象。如要申请显存，显存在哪里，需要明确，图像计算好了，显示在哪里，也需要指定。EGL就是对这些环境抽象的集合，为了通俗地解释相关概念，我们可以玩一下角色扮演——假如让我们设计相关标准，我们该如何做。</description></item><item><title>现代C++学习指南 模板</title><link>https://bravebuffalo.cc/post/%E7%8E%B0%E4%BB%A3C++%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97%20%E6%A8%A1%E6%9D%BF.html</link><pubDate>Mon, 31 Oct 2022 21:33:38 +0800</pubDate><guid>https://bravebuffalo.cc/post/%E7%8E%B0%E4%BB%A3C++%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97%20%E6%A8%A1%E6%9D%BF.html</guid><description>模板作为C++重要的特性，一直有着举足轻重的地位，是编写高度抽象代码的利器。
什么是模板 #模板在现实生活中就是范例：把都一样的部分固定起来，把变动的部分空出来，使用时将两部分合起来组成有效的东西。如申请书，Word模板都是这种形式。C++中的模板也是如此，不过更明确的是C++中的模板，变动的部分是一个代指类型的东西，称之为泛型参数。
我们先从一个例子来看一看模板是怎样发展而来的。如我们需要计算两个对象相加的结果，该如何写代码呢？在写代码前，我们有几个问题需要讨论清楚： 首先我们需要确定的是这两个对象是什么类型，毕竟C++是强类型的编程语言，变量，函数，类都是要明确指定类型是什么的，不确定的类型编译就不能通过。我们先假设这两个类型是整型。确定了类型之后，还需要确定这两个对象需要怎样加起来，根据我们假设的整型，我们知道可以直接调用运算符+。最后我们需要确定，两个对象相加后的结果类型是什么，整型相加的结果也是整型。综上，这个例子的代码看起来可能是这样的
int sum(int left,int right){ return left + right; } 这个例子很简单，简单到甚至都不需要单独写成一个函数。如果我们需要计算的数据不是两个数，而是一个数组的和呢？基于前面的分析和假设，我们也能很快实现相应的代码
int sum(const int data[], const std::size_t length) { int result{}; for (int i = 0; i &amp;lt; length;++i) { result += *(data + i); } return result; } 同样很简单。但是遗憾的是，这个函数通用性不强，它只能计算整型的数组和，假如我们需要计算带有小数点的数组和，它就不灵了，因为第一个参数类型不匹配，尽管我们知道sum的代码几乎都能复用，除了第一行的int需要替换成double。但是不能！我们只能复制一份，然后把int的地方改成double。
double sum(const double data[], const std::size_t length) { double result{}; for (int i = 0; i &amp;lt; length;++i) { result += *(data + i); } return result; } 这时你就会发现问题了，这个过程，我们仅仅改变了类型信息。这样的问题还会继续增加，我们可能又需要求float的数组和，上面那个double的数组和同样匹配不了，因为float，double是两个类型。正是因为数据类型不一样，所以很多时候我们需要为不同的数据提供相似的代码，这在数据类型膨胀的情况下是很痛苦的，当对算法进行修改的时候我们需要保证所有的数据类型都被修改到，并且要逐个进行测试，这无疑会增加工作量，并放大错误率。但是实际有效的代码都是要明确类型的，如果类型不明确，编译器就没法确定代码是否合法，不确定的事情编译器就要报错，所以按照普通的思路，这个问题是无解的。 但是其实很多时候，这些相似的代码仅仅是数据类型不一样而已，对付这种重复的工作应该让给计算机来完成，也就是编译器。所以我们需要一种技术，让编译器先不管具体类型是什么，而是用一种特殊的类型来替换，这个类型可以替换成任何类型，用这个特殊的类型完成具体的算法，在使用的时候根据实际的需求，将类型信息提供给算法，让编译器生成满足所提供类型的具体算法，而这就是模板。这和生活中的模板思想上是共通的。算法是固定的部分，数据类型是可变的部分，两个合起来就是合法的C++代码。也就是利用模板，我们可以只写一个算法，借助编译器生成所有类型的算法，这些算法之间唯一不同的就是类型。 当然光有模板还不够，上面只解决了类型的问题，没有解决算法实现的问题。怎么说呢，如我们有一个需求，需要将数据先排序，再查找最大值。这对于数字（int,float,double等）类型是有效的，直接使用比较运算符（&amp;lt;,&amp;gt;）就可以完成了，但是假如想让这个算法适用于自定义类型呢？直接在模板实现中写比较运算符对自定义类型是无效的，因为自定义类型没有实现相对应的比较运算函数。解决方法也很简单，自定义类型实现相对应的比较运算符就行了。诸如此类的问题，在模板中会经常遇到，因为我们对类型的信息一无所知，但是又要确保几乎所有的类型都能正常运作，这就不得不运用各种技术对类型进行限定或者检测，这其实才是模板问题的精髓。所以模板问题不仅仅是类型问题，还是其他C++问题的综合体，需要对C++特性有着较为完整的理解，才能写出有用高效的代码。 C++中通常将模板分为函数模板和模板类，我们先从比较简单的函数模板开始认识。</description></item><item><title>现代C++学习指南-标准库</title><link>https://bravebuffalo.cc/post/%E7%8E%B0%E4%BB%A3C++%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97-%E6%A0%87%E5%87%86%E5%BA%93.html</link><pubDate>Wed, 20 Jul 2022 22:15:05 +0800</pubDate><guid>https://bravebuffalo.cc/post/%E7%8E%B0%E4%BB%A3C++%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97-%E6%A0%87%E5%87%86%E5%BA%93.html</guid><description>&lt;blockquote>
&lt;p>在[上一章](&lt;a href="https://www.yuque.com/docs/share/adb5b1e4-f3c6-46fd-ba4b-4dabce9b4f2a?#" target="_blank" rel="noreferrer">https://www.yuque.com/docs/share/adb5b1e4-f3c6-46fd-ba4b-4dabce9b4f2a?#&lt;/a> 《现代C++学习指南-类型系统》)我们探讨了C++的类型系统，并提出了从低到高，又从高到低的学习思路，本文就是一篇从高到低的学习指南，希望能提供一种新的视角。&lt;/p>
&lt;/blockquote></description></item><item><title>现代C++学习指南-类型系统</title><link>https://bravebuffalo.cc/post/%E7%8E%B0%E4%BB%A3C++%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97-%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F.html</link><pubDate>Sun, 26 Jun 2022 11:11:59 +0800</pubDate><guid>https://bravebuffalo.cc/post/%E7%8E%B0%E4%BB%A3C++%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97-%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F.html</guid><description>在前一篇，我们提供了一个方向性的指南，但是学什么，怎么学却没有详细展开。本篇将在前文的基础上，着重介绍下怎样学习C++的类型系统。
写在前面 #在进入类型系统之前，我们应该先达成一项共识——尽可能使用C++的现代语法。众所周知，出于兼容性的考虑，C++中很多语法都是合法的。但是随着新版本的推出，有些语法可能是不推荐或者是需要避免使用的。所以本篇也尽可能采用推荐的语法形式（基于C++11或以上版本），这也是现代C++标题的含义。
采用现代语法有两点好处。其一，现代语法可以编译出更快更健壮的代码。编译器也是随着语言的发展而发展的，现代语法可以在一定程度上帮助编译器做更好的优化。其二，现代语法通常更简洁，更直观，也更统一，有助于增强可读性和可维护性。 明确了这点后，让我们一起踏入现代C++的大门吧。
类型系统 #程序是一种计算工具，根据输入，和预定义的计算方法，产生计算结果。当程序运行起来后，这三者都需要在内存中表示成合适的值才能让程序正常工作，负责解释的这套工具就是类型系统。数字，字符串，键盘鼠标事件等都是数据，而且在内存中实际存在的形式也是一样的，但是按我们人类的眼光来看的话，对它们的处理是不一样的。数字能进行加减乘除等算术运算，但是对字符串进行算术运算就没有意义，而键盘鼠标的值通常只是读取，不进行计算的。正是由于这些差异，编程语言的第一个任务就是需要定义一套类型系统，告诉计算机怎样处理内存中的数据。 为了让编程语言尽可能简单，编程语言一般把类型系统分为两步实现，一部分是编译器，另一部分是类型。编译器那部分负责将开发者的代码解释成合适的形式，以便可以高效，准确在内存中表示。类型部分则定义一些编译器能处理的类型，以便开发者可以找到合适的数据来完成输入输出的表示和计算方法的描述。这两者相辅相成，相互成就。 类型作为类型系统的重要表现形式，在编程语言中的重要性也就不言而喻了。如果把写程序看成是搭积木的话，那么程序的积木就是类型系统。类型系统是开发者能操作的最小单位，它限制了开发者的操作规则，但是提供了无限的可能。C++有着比积木更灵活的类型系统。
类型 #:::info 类型是编程语言的最小单位，任何一句代码都是一种内存使用形式。 ::: 而谈到C++的类型也就不得不谈到它的三种类型表现形式——普通类型，指针，引用。它们是三种不同的内存使用和解释形式，也是C++的最基础的形式。和大部分编程语言不同，C++对内置类型没有做特权处理，只要开发者愿意，所有的类型都可以有一致的语法形式（通过运算符重载），所以下面关于类型的举例适合所有的类型。 普通类型就是没有修饰的类型，如int,long,double等。它们是按值传递的，也就是赋值和函数传参是拷贝一份值，对拷贝后的值进行操作，不会再影响到老值。
int a=1; //老值,存在地址1 int b=a; //新值，存在地址2 b=2; //改变新值，改变地址2 //此时a还是1，b变成了2 那假如我们需要修改老值呢，有两种途径，一种是指针，另一种则是引用。 指针是C/C++里面的魔法，一切皆可指针。指针包含两个方面，一方面它是指一块内存，另一方面它可以指允许对这块内存进行的操作。指针的值是一块内存地址，操作指针，操作的是它指向的那块地址。
int a=1; //老值,存在地址1 int* b=&amp;amp;a; //&amp;amp;代表取地址，从右往左读，取a的地址——地址1，存在地址2 *b=2; //*是解引用，意思是把存在地址2(b)的值取出来，并把那个地址（地址1）的值改成2 //此时a，*b变成了2 引用则是指针的改进版，引用能避免无效引用，不过引用不能重设，比指针缺少一定的灵活性。
int a=1; //老值,存在地址1 int&amp;amp; b=a; //&amp;amp;出现在变量声明的位置，代表该变量是引用变量，引用变量必须在声明时初始化 b=2; //可以像普通变量一样操作引用变量，同时，对它的操作也会反应到原始对象上 //此时a，b变成了2 变量定义 #类型仅仅是一种语法定义，而要真正使用这种定义，我们需要用类型来定义变量，即变量定义。 C++变量定义是以下形式：
type name[{initial_value}] 这里的关键在于type。type是类型和限定符的组合。看下面的例子：</description></item><item><title>现代C++学习指南-方向篇</title><link>https://bravebuffalo.cc/post/%E7%8E%B0%E4%BB%A3C++%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97-%E6%96%B9%E5%90%91%E7%AF%87.html</link><pubDate>Sat, 25 Jun 2022 08:51:01 +0800</pubDate><guid>https://bravebuffalo.cc/post/%E7%8E%B0%E4%BB%A3C++%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97-%E6%96%B9%E5%90%91%E7%AF%87.html</guid><description>&lt;p>C++是一门有着四十年历史的语言，先后经历过四次版本大升级（诞生、98、11、17（20），14算小升级）。每次升级都是很多问题和解决方案的取舍。了解这些历史，能更好地帮助我们理清语言的发展脉络。所以接下来我将借它的发展历程，谈一谈我对它的理解，最后给出我认为比较合理的学习路线指南。&lt;/p></description></item></channel></rss>