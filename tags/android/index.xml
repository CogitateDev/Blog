<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Android on 低头沉思</title><link>https://hongui.github.io/tags/android/</link><description>Recent content in Android on 低头沉思</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Sun, 06 Mar 2022 11:30:40 +0800</lastBuildDate><atom:link href="https://hongui.github.io/tags/android/index.xml" rel="self" type="application/rss+xml"/><item><title>Android-NDk开发——基本概念</title><link>https://hongui.github.io/post/Android-NDk%E5%BC%80%E5%8F%91%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5.html</link><pubDate>Sun, 06 Mar 2022 11:30:40 +0800</pubDate><guid>https://hongui.github.io/post/Android-NDk%E5%BC%80%E5%8F%91%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5.html</guid><description>&lt;p>在Android开发中,有时候出于安全，性能，代码共用的考虑，需要使用C/C++编写的库。虽然在现代化工具链的支持下，这个工作的难度已经大大降低，但是毕竟万事开头难，初学者往往还是会遇到很多不可预测的问题。本篇就是基于此背景下写的一份简陋指南，希望能对刚开始编写C/C++库的读者有所帮助。同时为了尽可能减少认知断层，本篇将试着从一个最简单的功能开始，逐步添加工具链，直到实现最终功能，真正做到知其然且之所以然。&lt;/p>
&lt;h1 id="目标">目标&lt;/h1>
&lt;p>本篇的目标很简单，就是能在Android应用中调用到C/C++的函数——接收两个整型值，返回两者相加后的值，暂定这个函数为&lt;code>plus&lt;/code>。&lt;/p>
&lt;h1 id="从c源文件开始">从C++源文件开始&lt;/h1>
&lt;p>为了从我们最熟悉的地方开始,我们先不用复杂工具,先从最原始的C++源文件开始.&lt;/p>
&lt;p>打开你喜欢的任何一个文本编辑器，VS Code，Notpad++，记事本都行，新建一个文本文件，并另存为&lt;code>math.cpp&lt;/code>。接下来,就可以在这个文件中编写代码了.&lt;/p>
&lt;p>前面我们的目标已经说得很清楚,实现个&lt;code>plus&lt;/code>函数，接收两个整型值，返回两者之和，所以它可能是下面这样&lt;/p>
&lt;div class="highlight">&lt;div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
&lt;table style="border-spacing:0;padding:0;margin:0;border:0;">&lt;tr>&lt;td style="vertical-align:top;padding:0;margin:0;border:0;">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c++" data-lang="c++">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#458;font-weight:bold">int&lt;/span> &lt;span style="color:#900;font-weight:bold">plus&lt;/span>(&lt;span style="color:#458;font-weight:bold">int&lt;/span> left,&lt;span style="color:#458;font-weight:bold">int&lt;/span> right)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">return&lt;/span> left &lt;span style="color:#000;font-weight:bold">+&lt;/span> right;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>我们的源文件就这样完成了，是不是很简单。&lt;/p>
&lt;p>但是仅仅有源文件是不够的，因为这个只是给人看的，机器看不懂。所以我们就需要第一个工具——编译器。编译器能帮我们把人看得懂的转化成机器也能看得懂的东西。&lt;/p>
&lt;h1 id="编译器">编译器&lt;/h1>
&lt;p>编译器是个复杂工程，但是都是服务于两个基本功能&lt;/p>
&lt;ol>
&lt;li>理解源文件的内容（人能看懂的）——检查出源文件中的语法错误&lt;/li>
&lt;li>理解二进制的内容（机器能看懂的）——生成二进制的机器码。&lt;/li>
&lt;/ol>
&lt;p>基于这两个朴素的功能，编译器却是挠断了头。难点在于功能2。基于这个难点编译器分成了很多种，常见的像Windows平台的VS，Linux平台的G++,Apple的Clang。而对于Android来说，情况略有不同，前面这些编译器都是运行在特定系统上的，编译出来的程序通常也只能运行在对应的系统上。以我现在的机器为例，我现在是在Deepin上写的C++代码，但是我们的目标是让代码跑在Android手机上，是两个不同的平台。更悲观的是，目前为止，还没有一款可以在手机上运行的编译器。那我们是不是就不能在手机上运行C++代码了？当然不是，因为有交叉编译。&lt;/p>
&lt;p>交叉编译就是在一个平台上将代码生成另一个平台可执行对象的技术。它和普通编译最大的不同是在链接上。因为一般的链接直接可以去系统库找到合适的库文件，而交叉编译不行，因为当前的平台不是最终运行代码的平台。所以交叉编译还需要有目标平台的常用库。当然，这些Google都替我们准备好了，称为NDK。&lt;/p>
&lt;h1 id="ndk">NDK&lt;/h1>
&lt;p>NDK全称是Native Development Kit，里面有很多工具，编译器，链接器，标准库，共享库。这些都是交叉编译必不可少的部分。为了理解方便，我们首先来看看它的文件结构。以我这台机器上的版本为例——&lt;code>/home/Andy/Android/Sdk/ndk/21.4.7075529&lt;/code>（Windows上默认位置则是&lt;code>c:\Users\xxx\AppData\Local\Android\Sdk\&lt;/code>）。 NDK就保存在Sdk目录下，以&lt;code>ndk&lt;/code>命名，并且使用版本号作为该版本的根目录，如示例中，我安装的NDK版本就是&lt;code>21.4.7075529&lt;/code>。同时该示例还是&lt;code>ANDROID_NDK&lt;/code>这个环境变量的值。也就是说，在确定环境变量前，我们需要先确定选用的NDK版本，并且路径的值取到版本号目录。&lt;/p>
&lt;p>了解了它的存储位置，接下来我们需要认识两个重要的目录&lt;/p>
&lt;ul>
&lt;li>&lt;code>build/cmake/&lt;/code>，这个文件夹，稍后我们再展开。&lt;/li>
&lt;li>&lt;code>toolchains/llvm/prebuild/linux-x86_64&lt;/code>，最后的&lt;code>linux-x86_64&lt;/code>根据平台不同，名称也不同，如Windows平台上就是以Windows开头，但是一般不会找错，因为这个路径下就一个文件夹，并且前面都是一样的。这里有我们心心念念的编译器，链接器，库，文件头等。如编译器就存在这个路径下的&lt;code>bin&lt;/code>目录里，它们都是以&lt;code>clang&lt;/code>和&lt;code>clang++&lt;/code>结尾的，如&lt;code>aarch64-linux-android21-clang++&lt;/code>&lt;/li>
&lt;/ul>
&lt;ol>
&lt;li>
&lt;p>&lt;code>aarch64&lt;/code>代表着这个编译器能生成用在&lt;code>arm64&lt;/code>架构机器上的二进制文件，其他对应的还有&lt;code>armv7a&lt;/code>，&lt;code>x86_64&lt;/code>等。不同的平台要使用相匹配的编译器。它就是交叉编译中所说的目标平台。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>linux&lt;/code>代表我们执行编译这个操作发生在&lt;code>linux&lt;/code>机器上，它就是交叉编译中所说的主机平台。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>android21&lt;/code>这个显然就是目标系统版本了&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>clang++&lt;/code>代表它是个C++编译器，对应的C编译器是&lt;code>clang&lt;/code>。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>可以看到，对于Android来说，不同的主机，不同的指令集，不同的Android版本，都对应着一个编译器。
了解了这么多，终于到激动人性的时刻啦，接下来，我们来编译一下前面的C++文件看看。&lt;/p>
&lt;h1 id="编译">编译&lt;/h1>
&lt;p>通过&lt;code>aarch64-linux-android21-clang++ --help&lt;/code>查看参数，会发现它有很多参数和选项，现在我们只想验证下我们的C++源文件有没有语法错误，所以就不管那些复杂的东西，直接一个&lt;code>aarch64-linux-android21-clang++ -c math.cpp&lt;/code>执行编译。&lt;/p>
&lt;p>命令执行完后，假如一切顺利，就会在&lt;code>math.cpp&lt;/code>相同目录下生成&lt;code>math.o&lt;/code>对象文件，说明我们的源码没有语法错误，可进行到下一步的链接。&lt;/p>
&lt;p>不过，在此之前，先打断一下。通常我们的项目会包含很多源文件，引用一些第三方库，每次都用手工的形式编译，链接显然是低效且容易出错的。在工具已经很成熟的现在，我们应该尽量使用成熟的工具，将重心放在我们的业务逻辑上来，&lt;code>CMake&lt;/code>就是这样的一个工具。&lt;/p>
&lt;h1 id="cmake">CMake&lt;/h1>
&lt;p>CMake是个跨平台的项目构建工具。怎么理解呢？编写C++代码时，有时候需要引用其他目录的文件头，但是在编译阶段，编译器是不知道该去哪里查找文件头的，所以需要一种配置告诉编译器文件头的查找位置。再者，分布在不同目录的源码，需要根据一定的需求打包成不同的库。又或者，项目中引用了第三方库，需要在链接阶段告诉链接器从哪个位置查找库，种种这些都是需要配置的东西。&lt;/p>
&lt;p>而不同的系统，不同的IDE对于上述配置的支持是不尽相同的，如Windows上的Visual Studio就是需要在项目的属性里面配置。在开发者使用同样的工具时，问题还不是很大。但是一旦涉及到多平台，多IDE的情况，协同开发就会花费大把的时间在配置上。CMake就是为了解决这些问题应运而生的。&lt;/p>
&lt;p>CMake的配置信息都是写在名为&lt;code>CMakeLists.txt&lt;/code>的文件中。如前面提到头文件引用，源码依赖，库依赖等等，只需要在&lt;code>CmakeLists.txt&lt;/code>中写一次，就可以在Windows，MacOS，Linux平台上的主流IDE上无缝使用。如我在Windows的Visual Studio上创建了一个CMake的项目，配置好了依赖信息,传给同事。同事用MacOS开发，他可以在一点不修改的情况下，马上完成编译，打包，测试等工作。这就是CMake跨平台的威力——简洁，高效，灵活。&lt;/p>
&lt;h1 id="使用cmake管理项目">使用CMake管理项目&lt;/h1>
&lt;h2 id="建cmake项目">建CMake项目&lt;/h2>
&lt;p>我们前面已经有了&lt;code>math.cpp&lt;/code>，又有了CMake，现在就把他们结合一下。&lt;/p>
&lt;p>怎样建立一个CMake项目呢？一共分三步：&lt;/p>
&lt;ol>
&lt;li>建一个文件夹&lt;/li>
&lt;/ol>
&lt;p>示例中我们就建一个&lt;code>math&lt;/code>的文件夹吧。&lt;/p>
&lt;ol start="2">
&lt;li>
&lt;p>在新建的文件夹里新建&lt;code>CMakeLists.txt&lt;/code>文本文件。注意，这里的文件名不能变。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>在新建的&lt;code>CMakeLists.txt&lt;/code>文件里配置项目信息。
最简单的CMake项目信息需要包括至少三个东西
1）、支持的最低CMake版本&lt;/p>
&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
&lt;table style="border-spacing:0;padding:0;margin:0;border:0;">&lt;tr>&lt;td style="vertical-align:top;padding:0;margin:0;border:0;">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cmake" data-lang="cmake">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#0086b3">cmake_minimum_required&lt;/span>(&lt;span style="color:#d14">VERSION&lt;/span> &lt;span style="color:#d14">3.18。1&lt;/span>)&lt;span style="color:#a61717;background-color:#e3d2d2">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>2）、项目名称&lt;/p>
&lt;div class="highlight">&lt;div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
&lt;table style="border-spacing:0;padding:0;margin:0;border:0;">&lt;tr>&lt;td style="vertical-align:top;padding:0;margin:0;border:0;">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cmake" data-lang="cmake">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#0086b3">project&lt;/span>(&lt;span style="color:#d14">math&lt;/span>)&lt;span style="color:#a61717;background-color:#e3d2d2">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>3）、生成物——生成物可能是可执行文件，也可能是库。因为我们要生成Android上的库，所以这里是的生成物是库。&lt;/p>
&lt;div class="highlight">&lt;div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
&lt;table style="border-spacing:0;padding:0;margin:0;border:0;">&lt;tr>&lt;td style="vertical-align:top;padding:0;margin:0;border:0;">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cmake" data-lang="cmake">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#0086b3">add_library&lt;/span>(&lt;span style="color:#000;font-weight:bold">${&lt;/span>&lt;span style="color:#008080">PROJECT_NAME&lt;/span>&lt;span style="color:#000;font-weight:bold">}&lt;/span> &lt;span style="color:#d14">SHARED&lt;/span> &lt;span style="color:#d14">math.cpp&lt;/span>)&lt;span style="color:#a61717;background-color:#e3d2d2">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>经过这三步，CMake项目就建成了。下一步我们来试试用CMake来编译项目。&lt;/p>
&lt;h2 id="编译cmake项目">编译CMake项目&lt;/h2>
&lt;p>在执行真正的编译前，CMake有个准备阶段，这个阶段CMake会收集必要的信息，然后生成满足条件的工程项目，然后才能执行编译。&lt;/p>
&lt;p>那么什么是必要的信息呢？CMake为了尽可能降低复杂性，会自己猜测收集一些信息。&lt;/p>
&lt;p>如我们在Windows上执行生成操作，CMake会默认目标平台就是Windows，默认生成VS的工程，所以在Windows上编译Windows上的库就几乎是零配置的。&lt;/p>
&lt;ol>
&lt;li>
&lt;p>在&lt;code>math&lt;/code>目录下新建一个&lt;code>build&lt;/code>的目录，然后把工作目录切换到&lt;code>build&lt;/code>目录。&lt;/p>
&lt;div class="highlight">&lt;div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
&lt;table style="border-spacing:0;padding:0;margin:0;border:0;">&lt;tr>&lt;td style="vertical-align:top;padding:0;margin:0;border:0;">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#0086b3">cd&lt;/span> build
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>cmake ..
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在命令执行之后，就能在&lt;code>build&lt;/code>目录下找到VS的工程，可以直接使用VS打开，无错误地完成编译。当然，更快的方法还是直接使用CMake编译.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>使用CMake编译&lt;/p>
&lt;div class="highlight">&lt;div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
&lt;table style="border-spacing:0;padding:0;margin:0;border:0;">&lt;tr>&lt;td style="vertical-align:top;padding:0;margin:0;border:0;">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>cmake --build .
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>注意前面的&lt;code>..&lt;/code>代表父目录，也就是&lt;code>CMakeLists.txt&lt;/code>文件存在的&lt;code>math&lt;/code>目录，而&lt;code>.&lt;/code>则代表当前目录，即&lt;code>build&lt;/code>这个目录。假如这两步都顺利执行了，我们就能在build目录下收获一个库文件。Windows平台上可能叫&lt;code>math.dll&lt;/code>，而Linux平台上可能叫&lt;code>math.so&lt;/code>，但是都是动态库，因为我们在&lt;code>CMakelists.txt&lt;/code>文件里配置的就是动态库。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>从上面的流程来看，CMake的工作流程不复杂。但是我们使用的是默认配置，也就是最终生成的库只能用在编译的平台上。要使用CMake编译Android库，我们就需要在生成工程时，手动告诉CMake一些配置，而不是让CMake去猜。&lt;/p>
&lt;h1 id="cmake的交叉编译">CMake的交叉编译&lt;/h1>
&lt;h2 id="配置参数从哪来">配置参数从哪来&lt;/h2>
&lt;p>虽然我们不知道完成交叉编译的最少配置是什么，但是我们可以猜一下。&lt;/p>
&lt;p>首先要完成源码的编译，编译器和链接器少不了，前面也知道了,Android平台上有专门的编译器和链接器，所以至少有个配置应该是告诉CMake用哪一个编译器和链接器。&lt;/p>
&lt;p>其次Android的系统版本和架构也是必不可少的，毕竟对于Android开发来说，这个对于Android应用都很重要。&lt;/p>
&lt;p>还能想到其他参数吗，好像想不到了。不过，好消息是，Google替我们想好了，那就是直接使用&lt;code>CMAKE——TOOLCHAIIIN_FILE&lt;/code>。这个选项是CMake 提供的，使用的时候把配置文件路径设置为它的值就可以了，CMake会通过这个路径查找到目标文件，使用目标文件里面的配置代替它的自己靠猜的参数。而这个配置文件，就是刚才提到过的两个重要文件夹之一的&lt;code>build/camke&lt;/code>,我们的配置文件就是该文件夹下面的&lt;code>android.toolchain.cmake&lt;/code>。&lt;/p>
&lt;h2 id="google的cmake配置文件">Google的CMake配置文件&lt;/h2>
&lt;p>&lt;code>android.toolchain.cmake&lt;/code>扮演了一个包装器的作用，它会利用提供给它的参数，和默认的配置，共同完成CMake的配置工作。其实这个文件还是个很好的CMake学习资料，可以学到很多CMake的技巧。现在，我们先不学CMake相关的，先来看看我们可用的参数有哪些。在文件的开头，Google就把可配置的参数都列举出来了&lt;/p>
&lt;div class="highlight">&lt;div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
&lt;table style="border-spacing:0;padding:0;margin:0;border:0;">&lt;tr>&lt;td style="vertical-align:top;padding:0;margin:0;border:0;">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cmake" data-lang="cmake">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a61717;background-color:#e3d2d2">ANDROID_TOOLCHAIN
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a61717;background-color:#e3d2d2">ANDROID_ABI
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a61717;background-color:#e3d2d2">ANDROID_PLATFORM
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a61717;background-color:#e3d2d2">ANDROID_STL
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a61717;background-color:#e3d2d2">ANDROID_PIE
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a61717;background-color:#e3d2d2">ANDROID_CPP_FEATURES
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a61717;background-color:#e3d2d2">ANDROID_ALLOW_UNDEFINED_SYMBOLS
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a61717;background-color:#e3d2d2">ANDROID_ARM_MODE
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a61717;background-color:#e3d2d2">ANDROID_ARM_NEON
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a61717;background-color:#e3d2d2">ANDROID_DISABLE_FORMAT_STRING_CHECKS
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a61717;background-color:#e3d2d2">ANDROID_CCACHE
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这些参数其实不是CMake的参数，在配置文件被执行的过程中，这些参数会被转换成真正的CMake参数。我们可以通过指定这些参数的值，让CMake完成不同的构建需求。假如都不指定，则会使用默认值，不同的NDK版本，默认值可能会不一样。&lt;/p>
&lt;p>我们来着重看看最关键的&lt;code>ANDROID_ABI&lt;/code>和&lt;code>ANDROID_PLATFORM&lt;/code>。前面这个是指当前构建的包运行的CPU指令集是哪一个，可选的值有&lt;code>arneabi-v7a&lt;/code>，&lt;code>arn64-v8a&lt;/code>，&lt;code>x86&lt;/code>，&lt;code>x86_64&lt;/code>，&lt;code>mips&lt;/code>，&lt;code>mips64&lt;/code>。后一个则是指构建包的Android版本。它的值有两种形式，一种就是直接&lt;code>android-[version]&lt;/code>的形式&lt;code>[version]&lt;/code>在使用时替换成具体的系统版本，如&lt;code>android-23&lt;/code>，代表最低支持的系统版本是Android 23。另一种形式是字符串&lt;code>latest&lt;/code>。这个值就如这个单词的意思一样，用最新的。&lt;/p>
&lt;p>那么我们怎么知道哪个参数可以取哪些值呢，有个简单方法：先在文件头确定要查看的参数，然后全局搜索，看&lt;code>set&lt;/code>和&lt;code>if&lt;/code>相关的语句就能确定它支持的参数形式了。&lt;/p>
&lt;h2 id="使用配置文件完成交叉编译">使用配置文件完成交叉编译&lt;/h2>
&lt;p>说了那么一大堆，回到最开始的例子上来。现在我们有了&lt;code>CMakelists.txt&lt;/code>，还有了&lt;code>math.cpp&lt;/code>，又找到了针对Android的配置文件&lt;code>android.toolchin.cmake&lt;/code>。那么怎样才能把三者结合起来呢，这就不得不提到CMake的参数配置了。&lt;/p>
&lt;p>在前面，我们直接使用&lt;/p>
&lt;div class="highlight">&lt;div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
&lt;table style="border-spacing:0;padding:0;margin:0;border:0;">&lt;tr>&lt;td style="vertical-align:top;padding:0;margin:0;border:0;">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>cmake ..
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>就完成了工程文件的生成配置，但是其实它是可以传递参数的。***CMake的参数都是以&lt;code>-D&lt;/code>开头，用空白符分割的键值对。***而CMake缺省的参数都是以&lt;code>CMAKE&lt;/code>为开头的，所以大部分情况下参数的形式都是&lt;code>-DCMAKE_XXX&lt;/code>这种。如给CMake传递&lt;code>toolchain&lt;/code>文件的形式就是&lt;/p>
&lt;div class="highlight">&lt;div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
&lt;table style="border-spacing:0;padding:0;margin:0;border:0;">&lt;tr>&lt;td style="vertical-align:top;padding:0;margin:0;border:0;">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>cmake -DCMAKE_TOOLCHAIN_FILE&lt;span style="color:#000;font-weight:bold">=&lt;/span>/home/Andy/Android/Sdk/ndk/21.4.7075529/build/cmake/android.toolchain.cmake
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这个参数的意思就是告诉CMake，使用&lt;code>=&lt;/code>后面指定的文件来配置CMake的参数。&lt;/p>
&lt;p>然而，完成交叉编译，我们还少一个选项——&lt;code>-G&lt;/code>。这个选项是交叉编译必需的。因为交叉编译CMake不知道该生成什么形式的工程，所以需要使用这个选项指定生成工程的类型。一种是传统形式的Make工程，指定形式是&lt;/p>
&lt;div class="highlight">&lt;div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
&lt;table style="border-spacing:0;padding:0;margin:0;border:0;">&lt;tr>&lt;td style="vertical-align:top;padding:0;margin:0;border:0;">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>cmake -G &lt;span style="color:#d14">&amp;#34;Unix Makefiles&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>可以看出，这种形式是基于Unix平台下的Make工程的，它使用&lt;code>make&lt;/code>作为构建工具，所以指定这种形式以后，还需要指定&lt;code>make&lt;/code>的路径，工程才能顺利完成编译。而另一种Google推荐的方式是&lt;code>Ninja&lt;/code>，这种方式更简单，因为不需要单独指定&lt;code>Ninja&lt;/code>的路径，它默认就随CMake安装在同一个目录下，所以可以减少一个传参。&lt;code>Ninja&lt;/code>也是一种构建工具，但是专注速度，所以我们这一次就使用&lt;code>Ninja&lt;/code>。它的指定方式是这样的&lt;/p>
&lt;div class="highlight">&lt;div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
&lt;table style="border-spacing:0;padding:0;margin:0;border:0;">&lt;tr>&lt;td style="vertical-align:top;padding:0;margin:0;border:0;">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>cmake -G Ninja
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>结合以上两个参数，就可以得到最终的编译命令&lt;/p>
&lt;div class="highlight">&lt;div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
&lt;table style="border-spacing:0;padding:0;margin:0;border:0;">&lt;tr>&lt;td style="vertical-align:top;padding:0;margin:0;border:0;">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>cmake -GNinja -DCMAKE_TOOLCHAIN_FILE&lt;span style="color:#000;font-weight:bold">=&lt;/span>/home/Andy/Android/Sdk/ndk/21.4.7075529/build/cmake/android.toolchain.cmake ..
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>生成工程后再执行编译&lt;/p>
&lt;div class="highlight">&lt;div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
&lt;table style="border-spacing:0;padding:0;margin:0;border:0;">&lt;tr>&lt;td style="vertical-align:top;padding:0;margin:0;border:0;">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>cmake --build .
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>我们就得到了最终能运行在Android上的动态库了。用我这个NDK版本编译出来的动态库支持的Android版本是21,指令集是armeabi-v7a。当然根据前面的描述我们可以像前面传递&lt;code>toolchain&lt;/code>文件一下传递期望的参数，如以最新版的Android版本构建&lt;code>x86&lt;/code>的库，就可以这样写&lt;/p>
&lt;div class="highlight">&lt;div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
&lt;table style="border-spacing:0;padding:0;margin:0;border:0;">&lt;tr>&lt;td style="vertical-align:top;padding:0;margin:0;border:0;">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>cmake -GNinja -DCMAKE_TOOLCHAIN_FILE&lt;span style="color:#000;font-weight:bold">=&lt;/span>/home/Andy/Android/Sdk/ndk/21.4.7075529/build/cmake/android.toolchain.cmake -DANDROID_PLATFORM&lt;span style="color:#000;font-weight:bold">=&lt;/span>latest -DANDROID_ABI&lt;span style="color:#000;font-weight:bold">=&lt;/span>x86 ..
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这就给我们个思路，假如有些第三方库没有提供编译指南，但是是用CMake管理的，我们就可以直接套用上面的公式来编译这个第三方库。&lt;/p>
&lt;h1 id="jni">JNI&lt;/h1>
&lt;p>前面在CMake的帮助下，我们已经得到了&lt;code>libmath.so&lt;/code>动态库,但是这个库还是不能被Android应用直接使用，因为Android应用是用Java（Kotlin）语言开发的，而它们都是JVM语言，代码都是跑在JVM上的。要想使用这个库，还需要想办法让库加载到JVM中，然后才有可能访问得到。它碰巧的是，JVM还真有这个能力，它就是JNI。&lt;/p>
&lt;h2 id="jni基本思想">JNI基本思想&lt;/h2>
&lt;p>JNI能提供Java到C/C++的双向访问，也就是可以在Java代码里访问C/C++的方法或者数据，反过来也一样支持，这过程中JVM功不可没。所以要理解JNI技术，需要我们以JVM的角度思考问题。&lt;/p>
&lt;p>JVM好比一个货物集散中心，无论是去哪个地方的货物都需要先来到这个集散中心，再通过它把货物分发到目的地。这里的货物就可以是Java方法或者C/C++函数。但是和普通的快递不一样的是，这里的货物不知道自己的目的地是哪里，需要集散中心自己去找。那么找的依据从哪里来呢，也就是怎样保证集散中心查找结果的唯一性呢，最简单的方法当然就是货物自己标识自己，并且保证它的唯一性。&lt;/p>
&lt;p>显然对于Java来说，这个问题很好解决。Java有着层层保证唯一性的机制。&lt;/p>
&lt;ol>
&lt;li>包名可以保证类名的唯一性；&lt;/li>
&lt;li>类名可以保证同一包名下类的唯一性；&lt;/li>
&lt;li>同一个类下可以用方法名保证唯一性；&lt;/li>
&lt;li>方法发生重载的时候可以用参数类型和个数确定类的唯一性。&lt;/li>
&lt;/ol>
&lt;p>而对于C/C++来说，没有包名和类名，那么用方法名和方法参数可以确定唯一性吗？答案是可以，只要我们把包名和类名作为一种限定条件。&lt;/p>
&lt;p>而添加限定条件的方式有两种，一种就是简单粗暴，直接把包名类名作为函数名的一部分，这样JVM也不用看其他的东西，直接粗暴地将包名，类名，函数名和参数这些对应起来就能确定对端对应的方法了。这种方法叫做静态注册。其实这和Android里面的广播特别像：广播的静态注册就是直接粗暴地在&lt;code>AndroidManifest&lt;/code>文件中写死了，不用在代码里配置，一写了就生效。对应于静态注册，肯定还有个动态注册的方法。动态注册就是用写代码的方式告诉JVM函数间的对应关系，而不是让它在函数调用时再去查找。显然这种方式的优势就是调用速度更快一点，毕竟我们只需要一次注册，就可以在后续调用中直接访问到对端，不再需要查找操作。但是同样和Android中广播的动态注册一样，动态注册要繁琐得多，而且动态注册还要注意把握好注册时机，不然容易造成调用失败。我们继续以前面的&lt;code>libmath.so&lt;/code>为例讲解。&lt;/p>
&lt;h2 id="java使用本地库">Java使用本地库&lt;/h2>
&lt;p>Java端访问C/C++函数很简单，一共分三步：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>Java调用&lt;code>System.loadLibrary()&lt;/code>方法载入库&lt;/p>
&lt;div class="highlight">&lt;div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
&lt;table style="border-spacing:0;padding:0;margin:0;border:0;">&lt;tr>&lt;td style="vertical-align:top;padding:0;margin:0;border:0;">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>System&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#008080">loadlibrary&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#d14">&amp;#34;math.so&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这里有个值得注意的地方，CMake生成的动态库是&lt;code>libmath.so&lt;/code>，但是这里只写了&lt;code>math.so&lt;/code>，也就是说不需要传递&lt;code>lib&lt;/code>这个前缀。这一步执行完后，JVM就知道有个&lt;code>plus&lt;/code>函数了。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Java声明一个和C++函数对应的&lt;code>native&lt;/code>方法。这里对应指的是参数列表和返回值要保持一致，方法名则可以不一致。&lt;/p>
&lt;div class="highlight">&lt;div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
&lt;table style="border-spacing:0;padding:0;margin:0;border:0;">&lt;tr>&lt;td style="vertical-align:top;padding:0;margin:0;border:0;">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">public&lt;/span> &lt;span style="color:#000;font-weight:bold">native&lt;/span> &lt;span style="color:#458;font-weight:bold">int&lt;/span> &lt;span style="color:#900;font-weight:bold">nativePlus&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#458;font-weight:bold">int&lt;/span> left&lt;span style="color:#000;font-weight:bold">,&lt;/span>&lt;span style="color:#458;font-weight:bold">int&lt;/span> right&lt;span style="color:#000;font-weight:bold">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>通常，习惯将&lt;code>native&lt;/code>方法添加&lt;code>native&lt;/code>的前缀。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>在需要的地方直接调用这个&lt;code>native&lt;/code>方法。调用方法和普通的Java方法是一致的，传递匹配的参数，用匹配的类型接收返回值。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>把这几布融合到一个类里面就是这样&lt;/p>
&lt;div class="highlight">&lt;div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
&lt;table style="border-spacing:0;padding:0;margin:0;border:0;">&lt;tr>&lt;td style="vertical-align:top;padding:0;margin:0;border:0;">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">13
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">14
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">15
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">16
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">17
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">18
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">19
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">20
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">21
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">22
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">23
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">24
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">25
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">26
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">27
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">28
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">29
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">30
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">package&lt;/span> &lt;span style="color:#555">hongui.me&lt;/span>&lt;span style="color:#000;font-weight:bold">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">import&lt;/span> &lt;span style="color:#555">android.os.Bundle&lt;/span>&lt;span style="color:#000;font-weight:bold">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">import&lt;/span> &lt;span style="color:#555">androidx.annotation.Nullable&lt;/span>&lt;span style="color:#000;font-weight:bold">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">import&lt;/span> &lt;span style="color:#555">androidx.appcompat.app.AppCompatActivity&lt;/span>&lt;span style="color:#000;font-weight:bold">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">import&lt;/span> &lt;span style="color:#555">hongui.me.databinding.ActivityMainBinding&lt;/span>&lt;span style="color:#000;font-weight:bold">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">public&lt;/span> &lt;span style="color:#000;font-weight:bold">class&lt;/span> &lt;span style="color:#458;font-weight:bold">MainActivity&lt;/span> &lt;span style="color:#000;font-weight:bold">extends&lt;/span> AppCompatActivity &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">static&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#008080">loadLibrary&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#d14">&amp;#34;me&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ActivityMainBinding binding&lt;span style="color:#000;font-weight:bold">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">private&lt;/span> &lt;span style="color:#000;font-weight:bold">native&lt;/span> &lt;span style="color:#458;font-weight:bold">int&lt;/span> &lt;span style="color:#900;font-weight:bold">nativePlus&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#458;font-weight:bold">int&lt;/span> left&lt;span style="color:#000;font-weight:bold">,&lt;/span>&lt;span style="color:#458;font-weight:bold">int&lt;/span> right&lt;span style="color:#000;font-weight:bold">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#3c5d5d;font-weight:bold">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">protected&lt;/span> &lt;span style="color:#458;font-weight:bold">void&lt;/span> &lt;span style="color:#900;font-weight:bold">onCreate&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#3c5d5d;font-weight:bold">@Nullable&lt;/span> Bundle savedInstanceState&lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">super&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#008080">onCreate&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>savedInstanceState&lt;span style="color:#000;font-weight:bold">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> binding &lt;span style="color:#000;font-weight:bold">=&lt;/span> ActivityMainBinding&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#008080">inflate&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>getLayoutInflater&lt;span style="color:#000;font-weight:bold">());&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> setContentView&lt;span style="color:#000;font-weight:bold">(&lt;/span>binding&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#008080">getRoot&lt;/span>&lt;span style="color:#000;font-weight:bold">());&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#998;font-style:italic">// Example of a call to a native method
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#998;font-style:italic">&lt;/span> binding&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#008080">sampleText&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#008080">setText&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#d14">&amp;#34;1 + 1 = &amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">+&lt;/span>nativePlus&lt;span style="color:#000;font-weight:bold">(&lt;/span>1&lt;span style="color:#000;font-weight:bold">,&lt;/span>1&lt;span style="color:#000;font-weight:bold">));&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="cc端引入jni">C/C++端引入JNI&lt;/h2>
&lt;p>JNI其实对于C/C++来说是一层适配层，在这一层主要做函数转换的工作，不做具体的功能实现，所以，通常来说我们会新建一个源文件，用来专门处理JNI层的问题，而JNI层最主要的问题当然就是前面提到的方法注册问题了。&lt;/p>
&lt;h3 id="静态注册">静态注册&lt;/h3>
&lt;p>静态注册的基本思路就是根据现有的Java &lt;code>native&lt;/code>方法写一个与之对应的C/C++函数签名，具体来说分四步。&lt;/p>
&lt;ol>
&lt;li>先写出和Java &lt;code>native&lt;/code>函数一模一样的函数签名&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
&lt;table style="border-spacing:0;padding:0;margin:0;border:0;">&lt;tr>&lt;td style="vertical-align:top;padding:0;margin:0;border:0;">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c++" data-lang="c++">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#458;font-weight:bold">int&lt;/span> nativePlus(&lt;span style="color:#458;font-weight:bold">int&lt;/span> left,&lt;span style="color:#458;font-weight:bold">int&lt;/span> right)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ol start="2">
&lt;li>在函数名前面添加包名和类名。因为包名在Java中是用&lt;code>.&lt;/code>分割的，而C/C++中点通常是用作函数调用，为了避免编译错误，需要把&lt;code>.&lt;/code>替换成&lt;code>_&lt;/code>。&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
&lt;table style="border-spacing:0;padding:0;margin:0;border:0;">&lt;tr>&lt;td style="vertical-align:top;padding:0;margin:0;border:0;">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c++" data-lang="c++">&lt;span style="display:flex;">&lt;span>hongui_me_MainActivity_nativePlus(&lt;span style="color:#458;font-weight:bold">int&lt;/span> left,&lt;span style="color:#458;font-weight:bold">int&lt;/span> right)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ol start="3">
&lt;li>转换函数参数。前面提到过所有的操作都是基于JVM的，在Java中，这些是自然而然的，但是在C/C++中就没有JVM环境，提供JVM
环境的形式就只能是添加参数。为了达到这个目的，任何JNI的函数都要在参数列表开头添加两个参数。而Java里面的最小环境是线程，所以第一个参数就是代表调用这个函数时，调用方的线程环境对象&lt;code>JNIEnv&lt;/code>，这个对象是C/C++访问Java的唯一通道。第二个则是调用对象。因为Java中不能直接调用方法，需要通过类名或者某个类来调用方法，第二个参数就代表那个对象或者那个类，它的类型是&lt;code>jobjet&lt;/code>。从第三个参数开始，参数列表就和Java端一一对应了，但是也只是对应，毕竟有些类型在C/C++端是没有的，这就是JNI中的类型系统了，对于我们当前的例子来说Java里面的&lt;code>int&lt;/code>值对应着JNI里面的&lt;code>jint&lt;/code>,所以后两个参数都是&lt;code>jint&lt;/code>类型。这一步至关重要，任何一个参数转换失败都可能造成程序崩溃。&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
&lt;table style="border-spacing:0;padding:0;margin:0;border:0;">&lt;tr>&lt;td style="vertical-align:top;padding:0;margin:0;border:0;">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c++" data-lang="c++">&lt;span style="display:flex;">&lt;span>hongui_me_MainActivity_nativePlus(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> JNIEnv&lt;span style="color:#000;font-weight:bold">*&lt;/span> env,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> jobject &lt;span style="color:#998;font-style:italic">/* this */&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> jint left,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> jint right)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ol start="4">
&lt;li>添加必要前缀。这一步会很容易被忽略，因为这一部分不是那么自然而然。首先我们的函数名还得加一个前缀&lt;code>Java&lt;/code>,现在的函数名变成了这样&lt;code>Java_hongui_me_MainActivity_nativePlus&lt;/code>。其次在返回值两头需要添加&lt;code>JNIEXPORT&lt;/code>和&lt;code>JNICALL&lt;/code>，这里返回值是&lt;code>jint&lt;/code>，所以添加完这两个宏之后是这样&lt;code>JNIEXPORT jint JNICALL&lt;/code>。最后还要在最开头添加&lt;code>extern &amp;quot;C&amp;quot; &lt;/code>的兼容指令。至于为啥要添加这一步，感兴趣的读者可以去详细了解，简单概括就是这是JNI的规范。&lt;/li>
&lt;/ol>
&lt;p>经过这四步，最终静态方法找函数的C/C++函数签名变成了这样&lt;/p>
&lt;div class="highlight">&lt;div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
&lt;table style="border-spacing:0;padding:0;margin:0;border:0;">&lt;tr>&lt;td style="vertical-align:top;padding:0;margin:0;border:0;">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c++" data-lang="c++">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#999;font-weight:bold;font-style:italic">#include&lt;/span> &lt;span style="color:#999;font-weight:bold;font-style:italic">&amp;#34;math.h&amp;#34;&lt;/span>&lt;span style="color:#999;font-weight:bold;font-style:italic">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#999;font-weight:bold;font-style:italic">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">extern&lt;/span> &lt;span style="color:#d14">&amp;#34;C&amp;#34;&lt;/span> JNIEXPORT jint JNICALL
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Java_hongui_me_MainActivity_nativePlus(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> JNIEnv&lt;span style="color:#000;font-weight:bold">*&lt;/span> env,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> jobject &lt;span style="color:#998;font-style:italic">/* this */&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> jint left,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> jint right){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">return&lt;/span> &lt;span style="color:#900;font-weight:bold">plus&lt;/span>(left,right);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>注意到，这里我把前面的&lt;code>math.cpp&lt;/code>改成了&lt;code>math.h&lt;/code>，并在JNI适配文件（文件名是&lt;code>native_jni.cpp&lt;/code>）中调用了这个函数。所以现在有两个源文件了，需要更新一下&lt;code>CMakeList.txt&lt;/code>。&lt;/p>
&lt;div class="highlight">&lt;div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
&lt;table style="border-spacing:0;padding:0;margin:0;border:0;">&lt;tr>&lt;td style="vertical-align:top;padding:0;margin:0;border:0;">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cmake" data-lang="cmake">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#0086b3">cmake_minimum_required&lt;/span>(&lt;span style="color:#d14">VERSION&lt;/span> &lt;span style="color:#d14">3.18。1&lt;/span>)&lt;span style="color:#a61717;background-color:#e3d2d2">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a61717;background-color:#e3d2d2">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a61717;background-color:#e3d2d2">&lt;/span>&lt;span style="color:#0086b3">project&lt;/span>(&lt;span style="color:#d14">math&lt;/span>)&lt;span style="color:#a61717;background-color:#e3d2d2">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a61717;background-color:#e3d2d2">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a61717;background-color:#e3d2d2">&lt;/span>&lt;span style="color:#0086b3">add_library&lt;/span>(&lt;span style="color:#000;font-weight:bold">${&lt;/span>&lt;span style="color:#008080">PROJECT_NAME&lt;/span>&lt;span style="color:#000;font-weight:bold">}&lt;/span> &lt;span style="color:#d14">SHARED&lt;/span> &lt;span style="color:#d14">native_jni.cpp&lt;/span>)&lt;span style="color:#a61717;background-color:#e3d2d2">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>可以看到这里我们只把最后一行的文件名改了，因为&lt;code>CMakeLists.txt&lt;/code>当前所在的目录也是&lt;code>include&lt;/code>的查找目录，所以不需要给它单独设置值，假如需要添加其他位置的头文件则可以使用&lt;code>include_directories(dir)&lt;/code>添加。&lt;/p>
&lt;p>现在使用CMake重新编译，生成动态库，这次Java就能直接不报错运行了。&lt;/p>
&lt;h3 id="动态注册">动态注册&lt;/h3>
&lt;p>前面提到过动态注册需要注意注册时机，那么什么算是好时机呢？在前面Java使用本地库这一节，我们知道，要想使用库，必须先载入，载入成功后就可以调用JNI方法了。那么动态注册必然要发生在载入之后，使用之前。JNI很人性化的想到了这一点，在库载入完成以后会马上调用&lt;code>jint JNI_OnLoad(JavaVM *vm, void *reserved)&lt;/code>这个函数，这个方法还提供了一个关键的&lt;code>JavaVM&lt;/code>对象，简直就是动态注册的最佳入口了。确定了注册时机，现在我们来实操一下。***注意：动态注册和静态注册都是C/C++端实现JNI函数的一种方式，同一个函数一般只采用一种注册方式。***所以，接下来的步骤是和静态注册平行的，并不是先后关系。&lt;/p>
&lt;p>动态注册分六步&lt;/p>
&lt;ol>
&lt;li>新建&lt;code>native_jni.cpp&lt;/code>文件，添加&lt;code>JNI_OnLoad()&lt;/code>函数的实现。&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
&lt;table style="border-spacing:0;padding:0;margin:0;border:0;">&lt;tr>&lt;td style="vertical-align:top;padding:0;margin:0;border:0;">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c++" data-lang="c++">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">extern&lt;/span> &lt;span style="color:#d14">&amp;#34;C&amp;#34;&lt;/span> JNIEXPORT jint JNICALL
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>JNI_OnLoad(JavaVM &lt;span style="color:#000;font-weight:bold">*&lt;/span>vm, &lt;span style="color:#458;font-weight:bold">void&lt;/span> &lt;span style="color:#000;font-weight:bold">*&lt;/span>reserved) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">return&lt;/span> JNI_VERSION_1_6;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这就是这个函数的标准形式和实现，前面那一串都是JNI函数的标准形式，关键点在于函数名和参数以及返回值。要想这个函数在库载入后自动调用，函数名必须是这个，而且参数形式也不能变，并且用最后的返回值告诉JVM当前JNI的版本。也就是说，这些都是模板，直接搬就行。&lt;/p>
&lt;ol start="2">
&lt;li>得到&lt;code>JNIEnv&lt;/code>对象&lt;/li>
&lt;/ol>
&lt;p>前面提到过，所有的JNI相关的操作都是通过&lt;code>JNIEnv&lt;/code>对象完成的，但是现在我们只有个&lt;code>JavaVM&lt;/code>对象，显然秘诀就在&lt;code>JavaVM&lt;/code>身上。
通过它的&lt;code>GetEnv&lt;/code>方法就可以得到&lt;code>JNIEnv&lt;/code>对象&lt;/p>
&lt;div class="highlight">&lt;div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
&lt;table style="border-spacing:0;padding:0;margin:0;border:0;">&lt;tr>&lt;td style="vertical-align:top;padding:0;margin:0;border:0;">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c++" data-lang="c++">&lt;span style="display:flex;">&lt;span>JNIEnv &lt;span style="color:#000;font-weight:bold">*&lt;/span>env &lt;span style="color:#000;font-weight:bold">=&lt;/span> &lt;span style="color:#000;font-weight:bold">nullptr&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>vm&lt;span style="color:#000;font-weight:bold">-&amp;gt;&lt;/span>GetEnv(env, JNI_VERSION_1_6);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ol start="3">
&lt;li>找到目标类&lt;/li>
&lt;/ol>
&lt;p>前面说过，动态注册和静态注册都是要有包名和类名最限定的，只是使用方式不一样而已。所以动态注册我们也还是要使用到包名和类名，不过这次的形式又不一样了。静态注册包名类名用&lt;code>_&lt;/code>代替&lt;code>.&lt;/code>，这一次要用&lt;code>/&lt;/code>代替&lt;code>.&lt;/code>。所以我们最终的类形式是&lt;code>hongui/me/MainActivity&lt;/code>。这是一个字符串形式，怎样将它转换成JNI中的&lt;code>jclass&lt;/code>类型呢，这就该第二步的&lt;code>JNIEnv&lt;/code>出场了。&lt;/p>
&lt;div class="highlight">&lt;div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
&lt;table style="border-spacing:0;padding:0;margin:0;border:0;">&lt;tr>&lt;td style="vertical-align:top;padding:0;margin:0;border:0;">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c++" data-lang="c++">&lt;span style="display:flex;">&lt;span>jclass cls&lt;span style="color:#000;font-weight:bold">=&lt;/span>env&lt;span style="color:#000;font-weight:bold">-&amp;gt;&lt;/span>FindClass(&lt;span style="color:#d14">&amp;#34;hongui/me/MainActivity&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这个&lt;code>cls&lt;/code>对象就和Java里面那个&lt;code>MainActivity&lt;/code>是一一对应的了。有了类对象下一步当然就是方法了。&lt;/p>
&lt;ol start="4">
&lt;li>生成JNI函数对象数组。&lt;/li>
&lt;/ol>
&lt;p>因为动态注册可以同时注册一个类的多个方法，所以注册参数是数组形式的，而数组的类型是&lt;code>JNINativeMethod&lt;/code>。这个类型的作用就是把Java端的&lt;code>native&lt;/code>方法和JNI方法联系在一起，怎么做的呢，看它结构。&lt;/p>
&lt;div class="highlight">&lt;div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
&lt;table style="border-spacing:0;padding:0;margin:0;border:0;">&lt;tr>&lt;td style="vertical-align:top;padding:0;margin:0;border:0;">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">typedef&lt;/span> &lt;span style="color:#000;font-weight:bold">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">const&lt;/span> &lt;span style="color:#458;font-weight:bold">char&lt;/span>&lt;span style="color:#000;font-weight:bold">*&lt;/span> name;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">const&lt;/span> &lt;span style="color:#458;font-weight:bold">char&lt;/span>&lt;span style="color:#000;font-weight:bold">*&lt;/span> signature;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#458;font-weight:bold">void&lt;/span>&lt;span style="color:#000;font-weight:bold">*&lt;/span> fnPtr;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>} JNINativeMethod;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ul>
&lt;li>&lt;code>name&lt;/code>对应Java端那个&lt;code>native&lt;/code>的方法名，所以这个值应该是&lt;code>nativePlus&lt;/code>。&lt;/li>
&lt;li>&lt;code>signature&lt;/code>对应着这个&lt;code>native&lt;/code>方法的参数列表外加函数类型的签名。&lt;/li>
&lt;/ul>
&lt;p>什么是签名呢，就是类型简写。在Java中有八大基本类型，还有方法，对象，类。数组等，这些东西都有一套对应的字符串形式，好比是一张哈希表，键是类型的字符串表示，值是对应的Java类型。如&lt;code>jint&lt;/code>是真正的JNI类型，它的类型签名是&lt;code>I&lt;/code>，也就是&lt;code>int&lt;/code>的首字母大写。&lt;/p>
&lt;p>函数也有自己的类型签名&lt;code>(paramType)returnType&lt;/code>这里的&lt;code>paramType&lt;/code>和&lt;code>returnType&lt;/code>都需要是JNI类型签名，类型间不需要任何分隔符。&lt;/p>
&lt;p>综上，&lt;code>nativePlus&lt;/code>的类型签名是&lt;code>(II)I&lt;/code>。两个整型参数，返回另一个整型。&lt;/p>
&lt;ul>
&lt;li>&lt;code>fnPtr&lt;/code>正如它名字一样，它是一个函数指针，值就是我们真正的&lt;code>nativePlus&lt;/code>实现了（这里我们还没有实现，所以先假定是&lt;code>jni_plus&lt;/code>）。&lt;/li>
&lt;/ul>
&lt;p>综上，最终函数对象数组应该是下面这样&lt;/p>
&lt;div class="highlight">&lt;div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
&lt;table style="border-spacing:0;padding:0;margin:0;border:0;">&lt;tr>&lt;td style="vertical-align:top;padding:0;margin:0;border:0;">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c++" data-lang="c++">&lt;span style="display:flex;">&lt;span> JNINativeMethod methods[] &lt;span style="color:#000;font-weight:bold">=&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {&lt;span style="color:#d14">&amp;#34;nativePlus&amp;#34;&lt;/span>,&lt;span style="color:#d14">&amp;#34;(II)I&amp;#34;&lt;/span>,&lt;span style="color:#000;font-weight:bold">reinterpret_cast&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#458;font-weight:bold">void&lt;/span> &lt;span style="color:#000;font-weight:bold">*&amp;gt;&lt;/span>(jni_plus)}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> };
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ol start="5">
&lt;li>注册&lt;/li>
&lt;/ol>
&lt;p>现在有了代表类的&lt;code>jclass&lt;/code>对象，还有了代表方法的&lt;code>JNINativeMethod&lt;/code>数组，还有&lt;code>JNIEnv&lt;/code>对象，把它们结合起来就可以完成注册了&lt;/p>
&lt;div class="highlight">&lt;div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
&lt;table style="border-spacing:0;padding:0;margin:0;border:0;">&lt;tr>&lt;td style="vertical-align:top;padding:0;margin:0;border:0;">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c++" data-lang="c++">&lt;span style="display:flex;">&lt;span>env&lt;span style="color:#000;font-weight:bold">-&amp;gt;&lt;/span>RegisterNatives(cls,methods,&lt;span style="color:#000;font-weight:bold">sizeof&lt;/span>(methods)&lt;span style="color:#000;font-weight:bold">/&lt;/span>&lt;span style="color:#000;font-weight:bold">sizeof&lt;/span>(methods[&lt;span style="color:#099">0&lt;/span>]));
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这里第三个参数是代表方法的个数，我们使用了&lt;code>sizeof&lt;/code>操作法得出了所有的&lt;code>methods&lt;/code>的大小，再用&lt;code>sizeof&lt;/code>得出第一个元素的大小，就可以得到&lt;code>methods&lt;/code>的个数。当然，这里直接手动填入1也是可以的。&lt;/p>
&lt;ol start="6">
&lt;li>实现JNI函数&lt;/li>
&lt;/ol>
&lt;p>在第4步，我们用了个&lt;code>jni_plus&lt;/code>来代表&lt;code>nativePlus&lt;/code>的本地实现，但是这个函数实际上还没有创建，我们需要在源文件中定义。现在这个函数名就可以随便起了，不用像静态注册那样那么长还不能随便命名，只要保持最终的函数名和注册时用的那个名字一致就可以了。但是这里还是要加上&lt;code>extern &amp;quot;C&amp;quot;&lt;/code>的前缀，避免编译器对函数名进行特殊处理。参数列表和静态注册完全一致。所以，我们最终的函数实现如下。&lt;/p>
&lt;div class="highlight">&lt;div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
&lt;table style="border-spacing:0;padding:0;margin:0;border:0;">&lt;tr>&lt;td style="vertical-align:top;padding:0;margin:0;border:0;">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">5
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">6
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">7
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">8
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c++" data-lang="c++">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#999;font-weight:bold;font-style:italic">#include&lt;/span> &lt;span style="color:#999;font-weight:bold;font-style:italic">&amp;#34;math.h&amp;#34;&lt;/span>&lt;span style="color:#999;font-weight:bold;font-style:italic">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#999;font-weight:bold;font-style:italic">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">extern&lt;/span> &lt;span style="color:#d14">&amp;#34;C&amp;#34;&lt;/span> jint jni_plus(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> JNIEnv&lt;span style="color:#000;font-weight:bold">*&lt;/span> env,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> jobject &lt;span style="color:#998;font-style:italic">/* this */&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> jint left,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> jint right){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">return&lt;/span> &lt;span style="color:#900;font-weight:bold">plus&lt;/span>(left,right);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>好了，动态注册的实现形式也完成了，CMake编译后你会发现结果和静态注册完全一致。所以这两种注册方式完全取决于个人喜好和需求，当需要频繁调用&lt;code>native&lt;/code>方法时，我觉得动态注册是有优势的，但是假如调用次数很少，完全可以直接用静态注册，查找消耗完全可以忽略不记。&lt;/p>
&lt;h1 id="one-more-thing">One more thing&lt;/h1>
&lt;p>前面我提到CMake是管理C/C++项目的高手，但是对于Android开发来说，Gradle才是YYDS。这一点Google也意识到了，所以gradle的插件上直接提供了CMake和Gradle无缝衔接的丝滑配置。在&lt;code>android&lt;/code>这个构建块下，可以直接配置&lt;code>CMakeLists.txt&lt;/code>的路径和版本信息。&lt;/p>
&lt;div class="highlight">&lt;div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
&lt;table style="border-spacing:0;padding:0;margin:0;border:0;">&lt;tr>&lt;td style="vertical-align:top;padding:0;margin:0;border:0;">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">5
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-groovy" data-lang="groovy">&lt;span style="display:flex;">&lt;span>externalNativeBuild &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cmake &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> path &lt;span style="color:#900;font-weight:bold">file&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#d14">&amp;#39;src/main/cpp/CMakeLists.txt&amp;#39;&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> version &lt;span style="color:#d14">&amp;#39;3.20.5&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这样，后面无论是修改了C/C++代码，还是修改了Java代码，都可以直接点击运行，gradle会帮助我们编译好相应的库并拷贝到最终目录里，完全不再需要我们手动编译和拷贝库文件了。当然假如你对它的默认行为还不满意，还可以通过&lt;code>defaultConfig&lt;/code>配置默认行为，它的大概配置可以是这样&lt;/p>
&lt;div class="highlight">&lt;div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
&lt;table style="border-spacing:0;padding:0;margin:0;border:0;">&lt;tr>&lt;td style="vertical-align:top;padding:0;margin:0;border:0;">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">13
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">14
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">15
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">16
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">17
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">18
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">19
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-groovy" data-lang="groovy">&lt;span style="display:flex;">&lt;span>android &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> compileSdkVersion &lt;span style="color:#099">29&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> defaultConfig &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> minSdkVersion &lt;span style="color:#099">21&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> targetSdkVersion &lt;span style="color:#099">29&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> testInstrumentationRunner &lt;span style="color:#d14">&amp;#34;androidx.test.runner.AndroidJUnitRunner&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> consumerProguardFiles &lt;span style="color:#d14">&amp;#39;consumer-rules.pro&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> externalNativeBuild &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cmake &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cppFlags &lt;span style="color:#000;font-weight:bold">+=&lt;/span> &lt;span style="color:#d14">&amp;#34;-std=c++1z&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> arguments &lt;span style="color:#d14">&amp;#39;-DANDROID_STL=c++_shared&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> abiFilters &lt;span style="color:#d14">&amp;#39;armeabi-v7a&amp;#39;&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#d14">&amp;#39;arm64-v8a&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这里&lt;code>cppFlags&lt;/code>是指定C++相关参数的，对应的还有个&lt;code>cFlags&lt;/code>用来指定C相关参数。&lt;code>arguments&lt;/code>则是指定CMake的编译参数，最后一个就是我们熟悉的库最终要编译生成几个架构包了，我们这里只是生成两个。&lt;/p>
&lt;p>有了这些配置，Android Studio开发NDK完全就像开发Java一样，都有智能提示，都可以即时编译，即时运行，纵享丝滑。&lt;/p>
&lt;h1 id="总结">总结&lt;/h1>
&lt;p>NDK开发其实应该分为两部分，C++开发和JNI开发。
C++开发和PC上的C++开发完全一致，可以使用标准库，可以引用第三方库，随着项目规模的扩大，引入了CMake来管理项目，这对于跨平台项目来说优势明显，还可以无缝衔接到Gradle中。
而JNI开发则更多的是关注C/C++端和Java端的对应关系，每一个Java端的&lt;code>native&lt;/code>方法都要有一个对应的C/C++函数与之对应，JNI提供
静态注册和动态注册两种方式来完成这一工作，但其核心都是利用包名，类名，函数名，参数列表来确定唯一性。静态注册将包名，类名体现在函数名上，动态注册则是使用类对象，本地方法对象，&lt;code>JNIENV&lt;/code>的注册方法来实现唯一性。
NDK则是后面的大BOSS，它提供编译器，链接器等工具完成交叉编译，还有一些系统自带的库，如&lt;code>log&lt;/code>,&lt;code>z&lt;/code>,&lt;code>opengl&lt;/code>等等供我们直接使用。&lt;/p></description></item><item><title>Android-JNI开发概论</title><link>https://hongui.github.io/post/Android-JNI%E5%BC%80%E5%8F%91%E6%A6%82%E8%AE%BA.html</link><pubDate>Sun, 12 Sep 2021 21:34:45 +0800</pubDate><guid>https://hongui.github.io/post/Android-JNI%E5%BC%80%E5%8F%91%E6%A6%82%E8%AE%BA.html</guid><description>&lt;h1 id="什么是jni开发">什么是JNI开发&lt;/h1>
&lt;p>JNI的全称是Java Native Interface，顾名思义，这是一种解决Java和C/C++相互调用的编程方式。&lt;em>&lt;strong>它其实只解决两个方面的问题，怎么找到和怎么访问。&lt;/strong>&lt;/em> 弄清楚这两个话题，我们就学会了JNI开发。&lt;em>&lt;strong>需要注意的是，JNI开发只涉及到一小部分C/C++开发知识，遇到问题的时候我们首先要判断是C/C++的问题还是JNI的问题，这可以节省很多搜索和定位的时间。&lt;/strong>&lt;/em>&lt;/p>
&lt;h1 id="用jvm的眼光看函数调用">用JVM的眼光看函数调用&lt;/h1>
&lt;p>我们知道Java程序是不能单独运行的，它需要运行在JVM上的，而JVM却又需要跑在物理机上，所以它的任务很重，既要处理Java代码，又要处理各种操作系统，硬件等问题。可以说了解了JVM，就了解了Java的全部，当然包括JNI。所以我们先以JVM的身份来看看Java代码是怎样跑起来的吧（只是粗略的内容，省去了很多步骤，为了突出我们在意的部分）。&lt;/p>
&lt;p>运行Java代码前，会先启动一个JVM。在JVM启动后，会加载一些必要的类，这些类中包含一个叫主类的类，也就是含有一个静态成员函数，函数签名为&lt;code>public static void main(String[] args)&lt;/code>的方法。资源加载完成后，JVM就会调用主类的&lt;code>main&lt;/code>方法，开始执行Java代码。随着代码的执行，一个类依赖另一个类，层层依赖，共同完成了程序功能。这就是JVM的大概工作流程，可以说JVM就好比一座大桥，连接着Java大山和native大山。&lt;/p>
&lt;p>现在问题来了，在Java程序中，某个类需要通过JNI技术访问JVM以外的东西，那么它需要怎样告诉我（我现在是JVM）呢？需要一种方法　把普通的Java方法标记成特殊，这个标记就是&lt;code>native&lt;/code>关键字（使用Kotlin时虽然也可以使用这个关键字，但是Kotlin有自己的关键字&lt;code>external&lt;/code>）。当我执行到这个方法时，看到它不一样的标记，我就会从其他地方而不是Class里面寻找执行体，这就是一次JNI调用。也就是说对于Java程序来说，只需要将一个方法标记为&lt;code>native&lt;/code>，在需要的地方调用这个方法，就可以完成JNI调用了。但是对于我，该怎样处理这一次JNI调用呢？&lt;em>&lt;strong>其实上面的寻找执行体的过程是一个跳转问题，在C/C++的世界，跳转问题就是指针问题。那么这个指针它应该指向哪里呢？&lt;/strong>&lt;/em>&lt;/p>
&lt;p>C/C++代码是一个个函数（下文会将Java方法直接用方法简称，而C/C++函数直接用函数简称）组合起来的，每一个函数都是一个指针，这个特性恰好满足我的需要。但是对于我，外面世界那么大，我并&lt;code>不知道从哪里，找什么东西&lt;/code>，给我的信息还是不够。为了限定范围，我规定，只有通过&lt;code>System.loadLibrary(“xxx”)&lt;/code>加载的函数，我才会查找，其余的我直接罢工（抛错）。这一下子减轻了我的工作量，至少我知道从哪里找了。&lt;/p>
&lt;p>确定了范围，下一步就是在这个范围里确定真正的目标了。Java世界里怎样唯一标识一个类呢，有的人会脱口而出——类名，其实不全对，因为类名可能会重名，我们需要全限定的类名，也就是包名加类名，如&lt;code>String&lt;/code>的全限定类名就是&lt;code>java.lang.String&lt;/code>。但是这和我们查找native的方法有什么联系呢。当然有联系，既然一个全限定的类名是唯一的，那么它的方法也是唯一的，那么假如我规定以这个类的全限定类名加上方法名作为native函数的函数名，这样我是不是就可以通过函数名的方式找到native的函数看呢，答案是肯定的，但是有瑕疵，因为Java系统支持方法重载，也就是一个类里面，同名的方法可能有多个。那么构成重载的条件是什么呢，是参数列表不同。所以，结果就很显然了，我在前面的基础上再加上参数列表，组合成查找条件，我是不是就可以唯一确定某一个native函数了呢，这就是JNI的静态注册。&lt;/p>
&lt;p>不过，既然我只需要确定指针的指向，那么我能不能直接给指针赋值，而不是每次都去查找呢，虽然我不知道累，但是还是很耗费时间的。对于这种需求，我当然也是满足的啦，你直接告诉我，我就不找了，我还乐意呢。而且，既然你都给我找到了，我就不需要下那么多规定了，都放开，你说是我就相信你它是。这就是JNI的动态注册。&lt;/p>
&lt;h1 id="jni的函数注册">JNI的函数注册&lt;/h1>
&lt;p>上一节我们通过化身JVM的方式了解了JNI函数注册的渊源，并且引出了两种函数注册方式。从例子上，我们也可以总结出两种注册方式的特点&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>注册类型&lt;/th>
&lt;th>优点&lt;/th>
&lt;th>缺点&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>静态注册&lt;/td>
&lt;td>JVM自动查找 &lt;/br> 实现简单&lt;/td>
&lt;td>函数名贼长，限制较多 &lt;/br> 查找耗时&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>动态注册&lt;/td>
&lt;td>运行快 &lt;/br>对函数名无限制&lt;/td>
&lt;td>实现复杂&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>那么具体怎么做呢？我们接着往下说。&lt;/p>
&lt;h2 id="静态注册">静态注册&lt;/h2>
&lt;p>虽然静态注册限制比较多，但是都是一些浅显的规则，更容易实施，所以先从静态注册开始讲解。&lt;/p>
&lt;p>静态注册有着明确的开发步骤&lt;/p>
&lt;ol>
&lt;li>编写Java类，声明&lt;code>native&lt;/code>方法;&lt;/li>
&lt;li>使用&lt;code>java xxx.java&lt;/code>将Java源文件编译为class文件&lt;/li>
&lt;li>使用&lt;code>javah xxx&lt;/code>生成对应的&lt;code>.h&lt;/code>文件&lt;/li>
&lt;li>构建工具中引入&lt;code>.h&lt;/code>文件&lt;/li>
&lt;li>实现&lt;code>.h&lt;/code>文件中的函数&lt;/li>
&lt;/ol>
&lt;p>上面的这个步骤是静态开发的基本步骤，但是其实在如今强大的IDE面前，这些都不需要我们手动完成了，在Android Studio中，定义好&lt;code>native&lt;/code>方法后，在方法上按&lt;code>alt + enter&lt;/code>就可以生成正确的函数签名，直接写函数逻辑就可以了。但是学习一门学问，我们还是要抱着求真，求实的态度，所以我用一个例子来阐述一下这些规则，以加深读者的理解。&lt;/p>
&lt;p>&lt;code>Test.java&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
&lt;table style="border-spacing:0;padding:0;margin:0;border:0;">&lt;tr>&lt;td style="vertical-align:top;padding:0;margin:0;border:0;">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">package&lt;/span> &lt;span style="color:#555">me.hongui.demo&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">public&lt;/span> &lt;span style="color:#000;font-weight:bold">class&lt;/span> &lt;span style="color:#458;font-weight:bold">Test&lt;/span>&lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">native&lt;/span> String &lt;span style="color:#900;font-weight:bold">jniString&lt;/span>&lt;span style="color:#000;font-weight:bold">();&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;code>native-lib.cpp&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
&lt;table style="border-spacing:0;padding:0;margin:0;border:0;">&lt;tr>&lt;td style="vertical-align:top;padding:0;margin:0;border:0;">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#999;font-weight:bold;font-style:italic">#include&lt;/span> &lt;span style="color:#999;font-weight:bold;font-style:italic">&amp;lt;jni.h&amp;gt;&lt;/span>&lt;span style="color:#999;font-weight:bold;font-style:italic">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#999;font-weight:bold;font-style:italic">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">extern&lt;/span> &lt;span style="color:#d14">&amp;#34;C&amp;#34;&lt;/span> jstring Java_me_hongui_demo_Test_jniString(JNIEnv &lt;span style="color:#000;font-weight:bold">*&lt;/span>env, jobject thiz) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#998;font-style:italic">// TODO: implement jniString()
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#998;font-style:italic">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>上面就是一个JNI函数在两端声明的例子，不难发现&lt;/p>
&lt;ol>
&lt;li>函数签名以&lt;code>Java_&lt;/code>为前缀&lt;/li>
&lt;li>前缀后面跟着类的全路径，也就是包含包名和类名&lt;/li>
&lt;li>以&lt;code>_&lt;/code>作为路径分隔符&lt;/li>
&lt;li>函数的第一个参数永远是&lt;code>JNIEnv *&lt;/code>类型，第二个参数根据函数类型的不同而不同，&lt;code>static&lt;/code>类型的方法，对应的是&lt;code>jclass&lt;/code>类型，否则对应的是&lt;code>jobject&lt;/code>类型。类型系统后面会详细展开。&lt;/li>
&lt;/ol>
&lt;p>为什么Java方法对应到C/C++函数后，会多两个参数呢。我们知道JVM是多线程的，而我们的JNI方法可以在任何线程调用，那么怎样保证调用前后JVM能找到对应的线程呢，这就是函数第一个参数的作用，它是对线程环境的一种封装，和线程一一对应，也就是说不能用一个线程的&lt;code>JNIEnv&lt;/code>对象在另一个线程里使用。另外，它是一个C/C++访问Java世界的窗口，JNI开发的绝大部分时间都是和&lt;code>JNIEnv&lt;/code>打交道。&lt;/p>
&lt;h2 id="动态注册">动态注册&lt;/h2>
&lt;p>同样按照开发过程，我们一步一步来完成。
我们把前面的&lt;code>Java_me_hongui_demo_Test_jniString&lt;/code>函数名改成&lt;code>jniString&lt;/code>（当然不改也可以，毕竟没限制），参数列表保持不变，这时，我们就会发现Java文件报错了，说本地方法未实现。其实我们是实现了的，只是JVM找不到。为了让JVM能找到，我们需要向JVM注册。
那么怎么注册，在哪注册呢，似乎哪里都可以，又似乎都不可以。
前面说过，JVM只会查找通过&lt;code>System.loadLibrary(“xxx”); &lt;/code>加载的库，所以要想使用native方法，首先要先加载包含该方法的库文件，之后，才可使用。加载了库，说明Java程序要开始使用本地方法了。在加载库之后，调用方法之前，理论上都是可以注册方法的，但是时机怎么确定呢，JNI早就给我们安排好了。JVM在把库加载进虚拟机后，会调用函数&lt;code>jint JNI_OnLoad(JavaVM *vm, void *reserved)&lt;/code>，以确认JNI的版本，版本信息会以返回值的形式传递给JVM，目前可选的值有&lt;code>JNI_VERSION_1_1&lt;/code>,&lt;code>JNI_VERSION_1_2&lt;/code>,&lt;code>JNI_VERSION_1_4&lt;/code>,&lt;code>JNI_VERSION_1_6&lt;/code>。假如库没有定义这个函数，那么默认返回的是&lt;code>JNI_VERSION_1_1&lt;/code>，库将会加载失败，所以，为了支持最新的特性我们通常返回较高的版本。既然有了这么好的注册时机，那么下一步就是实现注册了。&lt;/p>
&lt;p>但事情并没有这么简单。由&lt;code>JNI_OnLoad&lt;/code>函数参数列表可知，目前，可供使用的只有JVM，但是查阅JVM的API，我们并没有发现注册的函数——注册函数是写在&lt;code>JNIEnv&lt;/code>类里面的。恰巧的是，JVM提供了获取&lt;code>JNIEnv&lt;/code>对象的函数。&lt;/p>
&lt;p>JVM有多个和&lt;code>JNIEnv&lt;/code>相关的函数，在Android开发中，我们需要使用&lt;code>AttachCurrentThread&lt;/code>来获取&lt;code>JNIEnv&lt;/code>对象，这个函数会返回执行状态，当返回值等于&lt;code>JNI_OK&lt;/code>的时候，说明获取成功。有了&lt;code>JNIEnv&lt;/code>对象，我们就可以注册函数了。&lt;/p>
&lt;p>先来看看注册函数的声明——&lt;code>jint RegisterNatives(jclass clazz, const JNINativeMethod* methods,jint nMethods&lt;/code>。返回值不用多说，和&lt;code>AttachCurrentThread&lt;/code>一样，指示执行状态。难点在参数上，第一个参数是&lt;code>jclass&lt;/code>类型，第二个是&lt;code>JNINativeMethod&lt;/code>指针，都是没见过的主。&lt;/p>
&lt;p>为什么需要这么多参数呢，JVM不只需要一个函数指针吗。还是唯一性的问题，记得前面的静态注册吗，静态注册用全限定类型和方法，参数列表，返回值的组合确定了函数的唯一性。但是对于动态注册，这些都是未知的，但是又是必须的。为了确定这些值，只能通过其他的方式。&lt;code>jclass&lt;/code>就是限定方法的存在范围，获取&lt;code>jclass&lt;/code>对象的方式也很简单，使用&lt;code>JNIEnv&lt;/code>的&lt;code>jclass FindClass(const char* name)&lt;/code>函数。参数需要串全限定符的类名，并且把&lt;code>.&lt;/code>换成&lt;code>/&lt;/code>，也就是类似&lt;code>me/hongui/demo/Test&lt;/code>的形式，为啥这样写，后面会单独拿一节出来细说。&lt;/p>
&lt;p>第二个和第三个参数组合起来就是常见的数组参数形式。先来看看&lt;code>JNINativeMethod&lt;/code>的定义。&lt;/p>
&lt;div class="highlight">&lt;div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
&lt;table style="border-spacing:0;padding:0;margin:0;border:0;">&lt;tr>&lt;td style="vertical-align:top;padding:0;margin:0;border:0;">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">5
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">typedef&lt;/span> &lt;span style="color:#000;font-weight:bold">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#458;font-weight:bold">char&lt;/span> &lt;span style="color:#000;font-weight:bold">*&lt;/span>name;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#458;font-weight:bold">char&lt;/span> &lt;span style="color:#000;font-weight:bold">*&lt;/span>signature;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#458;font-weight:bold">void&lt;/span> &lt;span style="color:#000;font-weight:bold">*&lt;/span>fnPtr;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>} JNINativeMethod;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>有个编写诀窍，按定义顺序，相关性是从Java端转到C/C++端，怎么理解呢？&lt;code>name&lt;/code>是只的Java端对应的&lt;code>native&lt;/code>函数的名字，这是纯Java那边的事，Java那边取啥名，这里就是啥名。第二个&lt;code>signature&lt;/code>代表函数签名，签名信息由参数列表和返回值组成，形如&lt;code>(I)Ljava/lang/String;&lt;/code>,这个签名就是和两边都有关系了。首先Java那边的&lt;code>native&lt;/code>方法定义了参数列表和返回值的类型，也就是限定了签名的形式。其次Java的数据类型对应C/C++的转换需要在这里完成，也就是参数列表和返回值要写成C/C++端的形式，这就是和C/C++相关了。最后一个&lt;code>fnPtr&lt;/code>由名字也可得知它是一个函数指针，这个函数指针就是纯C/C++的内容了，代表着Java端的&lt;code>native&lt;/code>方法在C/C++对应的实现，也就是前文所说的跳转指针的。知道了这些，其实我们还是写不出代码，因为，我们还有JNI的核心没有说到，那就是类型系统。&lt;/p>
&lt;h1 id="jni的类型系统">JNI的类型系统&lt;/h1>
&lt;p>由于涉及到Java和C/C++两个语言体系，JNI的类型系统很乱，但并非无迹可寻。首先需要明确的是，两端都有自己的类型系统，Java里的&lt;code>boolean&lt;/code>，&lt;code>int&lt;/code>，&lt;code>String&lt;/code>,C/C++的&lt;code>bool&lt;/code>,&lt;code>int&lt;/code>,&lt;code>string&lt;/code>等等，遗憾的是，它们并不一一对应。也就是说C/C++不能识别Java的类型。既然类型不兼容，谈何调用呢。这也就是JNI欲处理的问题。&lt;/p>
&lt;h2 id="jni类型映射">JNI类型映射&lt;/h2>
&lt;p>为了解决类型不兼容的问题，JNI引入了自己的类型系统，类型系统里定义了和C/C++兼容的类型，并且还对Java到C/C++的类型转换关系做了规定。怎么转换的呢，这里有个表&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Java类型&lt;/th>
&lt;th>C/C++类型&lt;/th>
&lt;th>描述&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>boolean&lt;/td>
&lt;td>jboolean&lt;/td>
&lt;td>unsigned 8 bits&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>byte&lt;/td>
&lt;td>jbyte&lt;/td>
&lt;td>signed 8 bits&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>char&lt;/td>
&lt;td>jchar&lt;/td>
&lt;td>unsigned 16 bits&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>short&lt;/td>
&lt;td>jshort&lt;/td>
&lt;td>signed 16 bits&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>int&lt;/td>
&lt;td>jint&lt;/td>
&lt;td>signed 32 bits&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>long&lt;/td>
&lt;td>jlong&lt;/td>
&lt;td>signed 64 bits&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>float&lt;/td>
&lt;td>jfloat&lt;/td>
&lt;td>32 bits&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>double&lt;/td>
&lt;td>jdouble&lt;/td>
&lt;td>64 bits&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>void&lt;/td>
&lt;td>void&lt;/td>
&lt;td>N/A&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>乍一看，没什么特别的，不过就是加了&lt;code>j&lt;/code>前缀（除了&lt;code>void&lt;/code>)，但是，这只是基本类型，我们应该没忘记Java是纯面向对象的语言吧。各种复杂对象才是Java的主战场啊。而对于复杂对象，情况就复杂起来了。我们知道在Java中，任何对象都是&lt;code>Object&lt;/code>类的子类。那么我们是否可以把除上面的基本类型以外的所有复杂类型都当作&lt;code>Object&lt;/code>类的对象来处理呢，可是可以，但是不方便,像数组，字符串，异常等常用类，假如不做转换使用起来比较繁琐。为了方便我们开发，JNI又将复杂类型分为下面这几种情况&lt;/p>
&lt;pre tabindex="0">&lt;code>jobject (所有的Java对象)
|
|--jclass (java.lang.Class)
|--jstring (java.lang.String)
|--jarray (数组)
| |
| |-- jobjectArray (Object数组)
| |-- jbooleanArray (boolean数组)
| |-- jbyteArray (byte数组)
| |-- jcharArray (char数组)
| |-- jshortArray (short数组)
| |-- jintArray (int数组)
| |-- jlongArray (long数组)
| |-- jfloatArray (float数组)
| |-- jdoubleArray (double数组)
|--jthrowable (java.lang.Throwable异常)
&lt;/code>&lt;/pre>&lt;p>两个表合起来就是Java端到C/C++的类型转换关系了。也就是说，当我们在Java里声明&lt;code>native&lt;/code>代码时，&lt;code>native&lt;/code>函数参数和返回值的对应关系，也是C/C++调用Java代码参数传递的对应关系。但是毕竟两套系统还是割裂的，类型系统只定义了兼容方式，并没有定义转换方式，双方的参数还是不能相互识别，所以，JNI又搞了个类型签名，欲处理类型的自动转换问题。&lt;/p>
&lt;h2 id="jni的类型签名">JNI的类型签名&lt;/h2>
&lt;p>类型签名和类类型映射类似，也有对应关系，我们先来看个对应关系表&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>类型签名&lt;/th>
&lt;th>Java类型&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Z&lt;/td>
&lt;td>boolean&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>B&lt;/td>
&lt;td>byte&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>C&lt;/td>
&lt;td>char&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>S&lt;/td>
&lt;td>short&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>I&lt;/td>
&lt;td>int&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>J&lt;/td>
&lt;td>long&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>F&lt;/td>
&lt;td>float&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>D&lt;/td>
&lt;td>double&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>L fully-qualified-class ;&lt;/td>
&lt;td>fully-qualified-class&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>[type&lt;/td>
&lt;td>type[]&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>(arg-types)ret-type&lt;/td>
&lt;td>method type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>对于基本类型，也很简单，就是取了首字母，除了&lt;code>boolean&lt;/code>(首字母被&lt;code>byte&lt;/code>占用了)，&lt;code>long&lt;/code>（字母被用作了符合对象的前缀标识符）。
着重需要注意的是复合类型，也就是某个类的情况。&lt;em>&lt;strong>它的签名包含三部分，前缀&lt;code>L&lt;/code>，中间是类型的全限定名称，跟上后缀&lt;code>;&lt;/code>,三者缺一不可,并且限定符的分隔符要用/替换, 。 注意，类型签名和类型系统不是一个概念。类型通常是纯字符串的，用在函数注册等地方，被JVM使用的。类型系统是和普通类型一样的，可以定义变量，作为参数列表，被用户使用的。 另外，数组对象也有自己的类型签名，也是有着类型前缀&lt;code>[&lt;/code>，后面跟着类型的签名。最后的方法类型，也就是接下来我们着重要讲的地方，它也是由三部分组成&lt;code>()&lt;/code>和包含在&lt;code>()&lt;/code>里面的参数列表，&lt;code>()&lt;/code>后面的返回值。这里用到的所有类型，都是指类型签名。&lt;/strong>&lt;/em>&lt;/p>
&lt;p>我们来看个例子&lt;/p>
&lt;div class="highlight">&lt;div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
&lt;table style="border-spacing:0;padding:0;margin:0;border:0;">&lt;tr>&lt;td style="vertical-align:top;padding:0;margin:0;border:0;">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#458;font-weight:bold">long&lt;/span> &lt;span style="color:#900;font-weight:bold">f&lt;/span> (&lt;span style="color:#458;font-weight:bold">int&lt;/span> n, String s, boolean[] arr);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>它的类型签名怎么写呢？我们来一步一步分析&lt;/p>
&lt;ol>
&lt;li>确定它在Java里面的类型，在表中找出对应关系，确定签名形式。&lt;/li>
&lt;li>用步骤1的方法确定它的组成部分的类型。&lt;/li>
&lt;li>将确定好的签名组合在一起&lt;/li>
&lt;/ol>
&lt;p>此例是方法类型，对应表中最后一项，所以签名形式为&lt;code>(参数)返回值&lt;/code>。该方法有三个参数，我们按照步骤1的方式逐一确定。&lt;/p>
&lt;ol>
&lt;li>&lt;code>int n&lt;/code>对应&lt;code>int&lt;/code>类型，签名是&lt;code>I&lt;/code>;&lt;/li>
&lt;li>&lt;code>String s&lt;/code>对应&lt;code>String&lt;/code>类型，是复合类型，对应表中倒数第三项，所以它的基本签名形式是&lt;code>L全限定名;&lt;/code>。而&lt;code>String&lt;/code>的全限定名&lt;code>java.lang.String&lt;/code>，用&lt;code>/&lt;/code>替换&lt;code>,&lt;/code>后变成&lt;code>java/lang/String&lt;/code>。按步骤3，将它们组合在一起就是&lt;code>Ljava/lang/String;&lt;/code>;&lt;/li>
&lt;li>&lt;code>boolean[] arr&lt;/code>对应数组类型，签名形式是&lt;code>[类型&lt;/code>，&lt;code>boolean&lt;/code>的签名是&lt;code>Z&lt;/code>。组合在一起就是&lt;code>[Z&lt;/code>;&lt;/li>
&lt;li>最后来看返回值，返回值是&lt;code>long&lt;/code>类型，签名形式是&lt;code>J&lt;/code>。&lt;/li>
&lt;/ol>
&lt;p>按照签名形式将这些信息组合起来就是&lt;code>(ILjava/lang/String;[Z)J&lt;/code>，&lt;em>&lt;strong>注意类型签名和签名之间没有任何分割符，也不需要，类型签名是紧密排列的&lt;/strong>&lt;/em>。&lt;/p>
&lt;h1 id="再看动态注册">再看动态注册&lt;/h1>
&lt;p>有了JNI的类型系统的支持，回过头来接着看动态注册的例子，让我们接着完善它。&lt;/p>
&lt;ol>
&lt;li>用JVM对象获取&lt;code>JNIEnv&lt;/code>对象，即&lt;code>auto status=vm-&amp;gt;AttachCurrentThread(&amp;amp;jniEnv, nullptr);&lt;/code>&lt;/li>
&lt;li>用步骤1获取的&lt;code>JNIEnv&lt;/code>对象获取&lt;code>jclass&lt;/code>对象，即&lt;code>auto cls=jniEnv-&amp;gt;FindClass(&amp;quot;me/hongui/demo/Test&amp;quot;);&lt;/code>&lt;/li>
&lt;li>定义&lt;code>JNINativeMethod&lt;/code>数组，即&lt;code>JNINativeMethod methods[]={{&amp;quot;jniString&amp;quot;, &amp;quot;()Ljava/lang/String;&amp;quot;,reinterpret_cast&amp;lt;void *&amp;gt;(jniString)}};&lt;/code>，这里的方法签名可以参看上一节。&lt;/li>
&lt;li>调用&lt;code>JNIEnv&lt;/code>的&lt;code>RegisterNatives&lt;/code>函数。即&lt;code>status=jniEnv-&amp;gt;RegisterNatives(cls,methods,sizeof(methods)/sizeof(methods[0]));&lt;/code>。&lt;/li>
&lt;li>当然，别忘了实现对应的&lt;code>native&lt;/code>函数，即这里的&lt;code>jniString&lt;/code>——&lt;code>JNINativeMethod&lt;/code>的第三个参数。&lt;/li>
&lt;/ol>
&lt;p>这五步就是动态注册中&lt;code>JNI_OnLoad&lt;/code>函数的实现模板了，主要的变动还是来自&lt;code>jclass&lt;/code>的获取参数和&lt;code>JNINativeMethod&lt;/code>的签名等，必须做到严格的一一对应。如下面的例子&lt;/p>
&lt;div class="highlight">&lt;div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
&lt;table style="border-spacing:0;padding:0;margin:0;border:0;">&lt;tr>&lt;td style="vertical-align:top;padding:0;margin:0;border:0;">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">13
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">extern&lt;/span> &lt;span style="color:#d14">&amp;#34;C&amp;#34;&lt;/span> jint JNI_OnLoad(JavaVM &lt;span style="color:#000;font-weight:bold">*&lt;/span>vm, &lt;span style="color:#458;font-weight:bold">void&lt;/span> &lt;span style="color:#000;font-weight:bold">*&lt;/span>reserved){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> JNIEnv&lt;span style="color:#000;font-weight:bold">*&lt;/span> jniEnv&lt;span style="color:#000;font-weight:bold">=&lt;/span> &lt;span style="color:#000;font-weight:bold">nullptr&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">auto&lt;/span> status&lt;span style="color:#000;font-weight:bold">=&lt;/span>vm&lt;span style="color:#000;font-weight:bold">-&amp;gt;&lt;/span>AttachCurrentThread(&lt;span style="color:#000;font-weight:bold">&amp;amp;&lt;/span>jniEnv, &lt;span style="color:#000;font-weight:bold">nullptr&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">if&lt;/span>(JNI_OK&lt;span style="color:#000;font-weight:bold">==&lt;/span>status){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> JNINativeMethod methods[]&lt;span style="color:#000;font-weight:bold">=&lt;/span>{{&lt;span style="color:#d14">&amp;#34;jniString&amp;#34;&lt;/span>, &lt;span style="color:#d14">&amp;#34;()Ljava/lang/String;&amp;#34;&lt;/span>,&lt;span style="color:#000;font-weight:bold">reinterpret_cast&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#458;font-weight:bold">void&lt;/span> &lt;span style="color:#000;font-weight:bold">*&amp;gt;&lt;/span>(jniString)}};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">auto&lt;/span> cls&lt;span style="color:#000;font-weight:bold">=&lt;/span>jniEnv&lt;span style="color:#000;font-weight:bold">-&amp;gt;&lt;/span>FindClass(&lt;span style="color:#d14">&amp;#34;me/hongui/demo/Test&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> status&lt;span style="color:#000;font-weight:bold">=&lt;/span>jniEnv&lt;span style="color:#000;font-weight:bold">-&amp;gt;&lt;/span>RegisterNatives(cls,methods,&lt;span style="color:#000;font-weight:bold">sizeof&lt;/span>(methods)&lt;span style="color:#000;font-weight:bold">/&lt;/span>&lt;span style="color:#000;font-weight:bold">sizeof&lt;/span>(methods[&lt;span style="color:#099">0&lt;/span>]));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">if&lt;/span>(JNI_OK&lt;span style="color:#000;font-weight:bold">==&lt;/span>status) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">return&lt;/span> JNI_VERSION_1_6;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">return&lt;/span> JNI_VERSION_1_1;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h1 id="在jni中使用数据">在JNI中使用数据&lt;/h1>
&lt;p>前面磨磨唧唧说了这么一大片，其实才讲了一个问题——怎么找到。虽然繁杂，但好在有迹可循，大不了运行奔溃。下面要讲的这个问题就棘手多了，需要一点点耐性和细心。这一部分也可以划分成两个小问题——***访问已知对象的数据，创建新对象。有一点还是要提一下，这里的访问还创建都是针对Java程序而言的，也就是说，对象是存在JVM虚拟机的堆上的，我们的操作都是基于堆对象的操作。***而在C/C++的代码里，操作堆对象的唯一途径就是通过&lt;code>JNIenv&lt;/code>提供的方法。所以，这部分其实就是对&lt;code>JNIenv&lt;/code>方法的应用讲解。&lt;/p>
&lt;h2 id="java对象的访问">Java对象的访问&lt;/h2>
&lt;p>在面向对象的世界中，我们说访问对象，通常指两个方面的内容，访问对象的属性、调用对象的方法。这些操作在Java世界中，很好实现，但是在C/C++世界却并非如此。在JNI的类型系统那一节，我们也了解到，Java中的复杂对象在C/C++中都对应着&lt;code>jobject&lt;/code>这个类，显然，无论Java世界中，那个对象如何牛逼，在C/C++中都是一视同仁的。为了实现C/C++访问Java的复杂对象，结合访问对象的方式，&lt;code>JNIEnv&lt;/code>提供了两大类方法，一类是对应属性的，一类是对应方法的。借助&lt;code>JNIEnv&lt;/code>，C/C++就能实现访问对象的目标了。而且它们还有一个较为统一的使用步骤：&lt;/p>
&lt;ol>
&lt;li>根据要访问的内容准备好对应id（fieldid或者methodid）。&lt;/li>
&lt;li>确定访问的对象和调用数据&lt;/li>
&lt;li>通过&lt;code>JNIEnv&lt;/code>的方法调用完成对象访问&lt;/li>
&lt;/ol>
&lt;p>可以看出来，这使用步骤和普通面向对象的方式多了一些准备阶段（步骤1，2）。之前提到过，这部分的内容需要的更多的是耐心和细心，不需要多少酷炫的操作，毕竟发挥空间也有限。这具体也体现在上面的步骤1，2。正是这个准备阶段让整个C/C++的代码变得丑陋和脆弱，但是——又不是不能用，是吧。&lt;/p>
&lt;p>看一个例子，Java里定义了一个&lt;code>Person&lt;/code>类，类定义如下&lt;/p>
&lt;div class="highlight">&lt;div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
&lt;table style="border-spacing:0;padding:0;margin:0;border:0;">&lt;tr>&lt;td style="vertical-align:top;padding:0;margin:0;border:0;">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">5
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">6
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">7
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">public&lt;/span> &lt;span style="color:#000;font-weight:bold">class&lt;/span> &lt;span style="color:#900;font-weight:bold">Person&lt;/span>&lt;span style="color:#000;font-weight:bold">(){&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">private&lt;/span> &lt;span style="color:#458;font-weight:bold">int&lt;/span> age&lt;span style="color:#000;font-weight:bold">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">private&lt;/span> String name&lt;span style="color:#000;font-weight:bold">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">public&lt;/span> &lt;span style="color:#458;font-weight:bold">void&lt;/span> &lt;span style="color:#900;font-weight:bold">setName&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>String name&lt;span style="color:#000;font-weight:bold">){&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">return&lt;/span> &lt;span style="color:#000;font-weight:bold">this&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#008080">name&lt;/span>&lt;span style="color:#000;font-weight:bold">=&lt;/span>name&lt;span style="color:#000;font-weight:bold">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>现在，我们在C/C++代码里该怎么访问这个类的对象呢。假定需要读取这个对象的&lt;code>age&lt;/code>值，设置这个对象的&lt;code>name&lt;/code>值。根据上面的步骤，我们有以下步骤&lt;/p>
&lt;ol>
&lt;li>准备好&lt;code>age&lt;/code>的&lt;code>fieldid&lt;/code>,&lt;code>setName&lt;/code>的&lt;code>methodid&lt;/code>。根据&lt;code>JNIEnv&lt;/code>的方法，我们可以看到四个相关的，&lt;code>fieldid&lt;/code>,&lt;code>methodid&lt;/code>各两个，分普通的和静态的。我们这里都是普通的，所以确定的方法是&lt;code>GetFieldID&lt;/code>和&lt;code>GetMethodID&lt;/code>。第一个参数就是&lt;code>jclass&lt;/code>对象，获取方法前面已经说过,即通过&lt;code>JNIEnv&lt;/code>的&lt;code>FindClass&lt;/code>方法，参数是全限定类名，以&lt;code>/&lt;/code>替换&lt;code>.&lt;/code>。后面两个参数对应Java端的名称和类型签名，&lt;code>age&lt;/code>属于field，&lt;code>int&lt;/code>的类型签名是&lt;code>I&lt;/code>，&lt;code>setName&lt;/code>属于method，签名形式是&lt;code>(参数)返回值&lt;/code>，这里参数的签名是&lt;code>Ljava/lang/String;&lt;/code>，返回值的签名是&lt;code>V&lt;/code>，组合起来就是&lt;code>&amp;quot;(Ljava/lang/String;)V&amp;quot;&lt;/code>。&lt;/li>
&lt;li>假定我们已经有了&lt;code>Person&lt;/code>对象&lt;code>obj&lt;/code>,通过Java传过来的。&lt;/li>
&lt;li>分别需要调用两个方法，&lt;code>age&lt;/code>是整形属性，要获取它的值，对应就需要使用&lt;code>GetIntField&lt;/code>方法。&lt;code>setName&lt;/code>是返回值为&lt;code>void&lt;/code>的方法。所以应该使用&lt;code>CallVoidMethod&lt;/code>。&lt;/li>
&lt;/ol>
&lt;p>通过上面的分析，得出下面的示例代码。&lt;/p>
&lt;div class="highlight">&lt;div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
&lt;table style="border-spacing:0;padding:0;margin:0;border:0;">&lt;tr>&lt;td style="vertical-align:top;padding:0;margin:0;border:0;">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">5
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">auto&lt;/span> cls&lt;span style="color:#000;font-weight:bold">=&lt;/span>jniEnv&lt;span style="color:#000;font-weight:bold">-&amp;gt;&lt;/span>FindClass(&lt;span style="color:#d14">&amp;#34;me/hongui/demo/Person&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">auto&lt;/span> ageId&lt;span style="color:#000;font-weight:bold">=&lt;/span>jniEnv&lt;span style="color:#000;font-weight:bold">-&amp;gt;&lt;/span>GetFieldID(cls,&lt;span style="color:#d14">&amp;#34;age&amp;#34;&lt;/span>,&lt;span style="color:#d14">&amp;#34;I&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">auto&lt;/span> nameId&lt;span style="color:#000;font-weight:bold">=&lt;/span>jniEnv&lt;span style="color:#000;font-weight:bold">-&amp;gt;&lt;/span>GetMethodID(cls,&lt;span style="color:#d14">&amp;#34;setName&amp;#34;&lt;/span>,&lt;span style="color:#d14">&amp;#34;(Ljava/lang/String;)V&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>jint age&lt;span style="color:#000;font-weight:bold">=&lt;/span>jniEnv&lt;span style="color:#000;font-weight:bold">-&amp;gt;&lt;/span>GetIntField(obj,ageId);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">auto&lt;/span> name&lt;span style="color:#000;font-weight:bold">=&lt;/span>jniEnv&lt;span style="color:#000;font-weight:bold">-&amp;gt;&lt;/span>NewStringUTF(&lt;span style="color:#d14">&amp;#34;张三&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>jniEnv&lt;span style="color:#000;font-weight:bold">-&amp;gt;&lt;/span>CallVoidMethod(obj,nameId,name);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>从上面的分析和示例来看，耐心和细心主要体现在&lt;/p>
&lt;ol>
&lt;li>对要访问的属性或者方法要耐心确定类型和名称，并且要保持三个步骤中的类型要一一对应。即调用&lt;code>GetFieldID&lt;/code>的类型要以&lt;code>GetXXXField&lt;/code>的类型保持一致，方法也是一样。&lt;/li>
&lt;li>对属性或方法的静态非静态修饰也要留心，通常静态的都需要使用带有&lt;code>static&lt;/code>关键字的方法，普通的则不需要。如&lt;code>GetStaticIntField&lt;/code>就是对应获取静态整型属性的值，而&lt;code>GetIntField&lt;/code>则是获取普通对象的整型属性值。&lt;/li>
&lt;li>属性相关的设置方法都是类似于&lt;code>SetXField&lt;/code>的形式，里面的&lt;code>X&lt;/code>代表着具体类型，和前面的类型系统中的类型一一对应，假如是复杂对象，则用&lt;code>Object&lt;/code>表示，如&lt;code>SetObjectField&lt;/code>。而访问属性只需要将前缀&lt;code>Set&lt;/code>换成&lt;code>Get&lt;/code>即可。对于静态属性，则是在&lt;code>Set&lt;/code>和&lt;code>X&lt;/code>之间加上固定的&lt;code>Static&lt;/code>，即&lt;code>SetStaticIntField&lt;/code>这种形式。&lt;/li>
&lt;li>方法调用则是以&lt;code>Call&lt;/code>为前缀，后面跟着返回值的类型，形如&lt;code>CallXMethod&lt;/code>的形式。这里&lt;code>X&lt;/code>代表返回值。如&lt;code>CallVoidMethod&lt;/code>就表示调用对象的某个返回值为&lt;code>void&lt;/code>类型的方法。同样对应的静态方法则是在&lt;code>Call&lt;/code>和&lt;code>X&lt;/code>之间加上固定的&lt;code>Static&lt;/code>,如&lt;code>CallStaticVoidMethod&lt;/code>。&lt;/li>
&lt;/ol>
&lt;h2 id="向java世界传递数据">向Java世界传递数据&lt;/h2>
&lt;p>向Java世界传递数据更需要耐心。因为我们需要不断地构造对象，组合对象，设置属性。而每一种都是上面Java对象的访问的一种形式。&lt;/p>
&lt;h3 id="构造java对象">构造Java对象&lt;/h3>
&lt;p>C/C++构造Java对象和调用方法类似。但是，还是有很多值得关注的细节。根据前面的方法，我们构造对象，首先要知道构造方法的id，而得到id，我们需要得到&lt;code>jclass&lt;/code>，构造方法的名字和签名。我们知道在Java世界里，构造方法是和类同名的，但是在C/C++里并不是这样，它有着特殊的名字——&lt;code>&amp;lt;init&amp;gt;&lt;/code>，注意，这里的&lt;code>&amp;lt;&amp;gt;&lt;/code>不能少。***也就是说无论这个类叫什么，它的构造函数的名字都是&lt;code>&amp;lt;init&amp;gt;&lt;/code>。***而函数签名的关键点在于返回值，构造方法的返回值都是&lt;code>void&lt;/code>也就是对应签名类型&lt;code>V&lt;/code>。&lt;/p>
&lt;p>接前面那个&lt;code>Person&lt;/code>类的例子，要怎样构造一个&lt;code>Person&lt;/code>对象呢。&lt;/p>
&lt;ol>
&lt;li>通过&lt;code>JNIEnv&lt;/code>的&lt;code>FindClass&lt;/code>得到就&lt;code>jclass&lt;/code>对象。记得将&lt;code>'&lt;/code>替换成&lt;code>/&lt;/code>。&lt;/li>
&lt;li>根据需要得到合适的构造方法的id。我没有定义构造方法，那么编译器会为它提供一个无参的构造方法。也就是函数签名为&lt;code>()V&lt;/code>。调用&lt;code>JNIEnv&lt;/code>的&lt;code>GetMethodID&lt;/code>得到id。&lt;/li>
&lt;li>调用&lt;code>JNIEnv&lt;/code>的&lt;code>NewObject&lt;/code>创建对象，记得传递构造参数。我这里不需要传递。&lt;/li>
&lt;/ol>
&lt;p>综上分析，这个创建过程类似于如下示例&lt;/p>
&lt;div class="highlight">&lt;div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
&lt;table style="border-spacing:0;padding:0;margin:0;border:0;">&lt;tr>&lt;td style="vertical-align:top;padding:0;margin:0;border:0;">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">5
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">6
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">7
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">8
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">auto&lt;/span> cls&lt;span style="color:#000;font-weight:bold">=&lt;/span>env&lt;span style="color:#000;font-weight:bold">-&amp;gt;&lt;/span>FindClass(&lt;span style="color:#d14">&amp;#34;me/hongui/demo/Person&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">auto&lt;/span> construct&lt;span style="color:#000;font-weight:bold">=&lt;/span>env&lt;span style="color:#000;font-weight:bold">-&amp;gt;&lt;/span>GetMethodID(cls,&lt;span style="color:#d14">&amp;#34;&amp;lt;init&amp;gt;&amp;#34;&lt;/span>,&lt;span style="color:#d14">&amp;#34;()V&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">auto&lt;/span> age&lt;span style="color:#000;font-weight:bold">=&lt;/span>env&lt;span style="color:#000;font-weight:bold">-&amp;gt;&lt;/span>GetFieldID(cls,&lt;span style="color:#d14">&amp;#34;age&amp;#34;&lt;/span>,&lt;span style="color:#d14">&amp;#34;I&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">auto&lt;/span> name&lt;span style="color:#000;font-weight:bold">=&lt;/span>env&lt;span style="color:#000;font-weight:bold">-&amp;gt;&lt;/span>GetFieldID(cls,&lt;span style="color:#d14">&amp;#34;name&amp;#34;&lt;/span>,&lt;span style="color:#d14">&amp;#34;Ljava/lang/String;&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">auto&lt;/span> p&lt;span style="color:#000;font-weight:bold">=&lt;/span>env&lt;span style="color:#000;font-weight:bold">-&amp;gt;&lt;/span>NewObject(cls,construct);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">auto&lt;/span> nameValue&lt;span style="color:#000;font-weight:bold">=&lt;/span>env&lt;span style="color:#000;font-weight:bold">-&amp;gt;&lt;/span>NewStringUTF(&lt;span style="color:#d14">&amp;#34;张三&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>env&lt;span style="color:#000;font-weight:bold">-&amp;gt;&lt;/span>SetIntField(p,age,&lt;span style="color:#099">18&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>env&lt;span style="color:#000;font-weight:bold">-&amp;gt;&lt;/span>SetObjectField(p,name,nameValue);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">return&lt;/span> p
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>上面的示例有个有意思的点，其实示例中创建了两个Java对象，一个是&lt;code>Person&lt;/code>对象，另一个是&lt;code>String&lt;/code>对象。因为在编程中，&lt;code>String&lt;/code>出境的概率太大了，所以JNI提供了这个简便方法。同样特殊的还有数组对象的创建。并且因为数组类型不确定，还有多个版本的创建方法，如创建整型数组的方法是&lt;code>NewIntArray&lt;/code>。方法签名也很有规律，都是&lt;code>NewXArray&lt;/code>的形式，其中&lt;code>X&lt;/code>代表数组的类型，这些方法都需要一个参数，即数组大小。既然提到了数组，那么数组的设置方法就不得不提。设置数组元素的值也有对应的方法，形如&lt;code>SetXArrayRegion&lt;/code>，如&lt;code>SetIntArrayRegion&lt;/code>就是设置整型数组元素的值。和Java世界不同的是，这些方法都是支持同时设置多个值的。整形数组的签名是这样——&lt;code>void SetIntArrayRegion(jintArray array,jsize start, jsize len,const jint* buf)&lt;/code>第二个参数代表设置值的开始索引，第三个参数是数目，第四个参数是指向真正值的指针。其余类型都是类似的。&lt;/p>
&lt;h2 id="让数据访问更进一步">让数据访问更进一步&lt;/h2>
&lt;p>有些时候，我们不是在调用&lt;code>native&lt;/code>方法时访问对象，而是在将来的某个时间。这在Java世界很好实现，总能找到合适的类存放这个调用时传递进来的对象引用，在后面使用时直接用就可以了。&lt;code>native&lt;/code>世界也是这样吗？从使用流程上是一样的，但是从实现方式上却是很大不同。&lt;/p>
&lt;p>Java世界是带有GC的，也就是说，将某个临时对象&lt;code>X&lt;/code>传递给某个对象&lt;code>Y&lt;/code>之后，&lt;code>X&lt;/code>的生命周期被转移到了&lt;code>Y&lt;/code>上了，&lt;code>X&lt;/code>不会在调用结束后被销毁，而是在&lt;code>Y&lt;/code>被回收的时候才会一同回收。这种方式在纯Java的世界里没有问题,但是当我们把这个临时对象&lt;code>X&lt;/code>传递给&lt;code>native&lt;/code>世界，试图让它以Java世界那样工作时，应用却崩溃了，报错&lt;code>JNI DETECTED ERROR IN APPLICATION: native code passing in reference to invalid stack indirect reference table or invalid reference: 0xxxxx&lt;/code>。为什么同样的操作在Java里面可以，在&lt;code>native&lt;/code>却不行呢。问题的根源就是Java的GC。GC可以通过各种垃圾检测算法判断某个对象是否需要标记为垃圾。而在&lt;code>native&lt;/code>世界，不存在GC，为了不造成内存泄漏，只能采取最严格的策略，&lt;strong>默认调用&lt;code>native&lt;/code>方法的地方就是使用Java对象的地方&lt;/strong>。所以在&lt;code>native&lt;/code>方法调用的作用域结束后，临时对象就被GC标记为垃圾，后面想再使用，可能已经被回收了。还好，强大的&lt;code>JNIEnv&lt;/code>类同样提供了方法让我们改变这种默认策略——&lt;code>NewGlobalRef&lt;/code>。对象只需要通过这种方式告诉JVM，它想活得更久一点，JVM在执行垃圾检测的时候就不会把它标记为垃圾，这个对象就会一直存。在，直到调用&lt;code>DeleteGlobalRef&lt;/code>。&lt;em>&lt;strong>这里&lt;code>NewGlobalRef&lt;/code>，&lt;code>DeleteGlobalRef&lt;/code>是一一对应的，而且最好是再不需要对象的时候就调用&lt;code>DeleteGlobalRef&lt;/code>释放内存，避免内存泄漏。&lt;/strong>&lt;/em>&lt;/p>
&lt;h1 id="总结">总结&lt;/h1>
&lt;p>&lt;em>&lt;strong>JNI开发会涉及到Java和C/C++开发的知识，在用C/C++实现JNI时，基本思想就是用C/C++语法写出Java的逻辑，也就是一切为Java服务。JNI开发过程中，主要要处理两个问题，函数注册和数据访问。&lt;/strong>&lt;/em>&lt;/p>
&lt;p>函数注册推荐使用动态注册，在&lt;code>JNI_OnLoad&lt;/code>函数中使用&lt;code>JNIEnv&lt;/code>的&lt;code>RegisterNatives&lt;/code>注册函数，注意保持Java的&lt;code>native&lt;/code>方法和类型签名的一致性，复合类型不要忘记前缀&lt;code>L&lt;/code>、后缀&lt;code>;&lt;/code>，并将&lt;code>.&lt;/code>替换为&lt;code>/&lt;/code>。&lt;/p>
&lt;p>数据访问首先需要确定访问周期，需要在多个地方或者不同时间段访问的对象，记得使用&lt;code>NewGlobalRef&lt;/code>阻止对象被回收，当然还要记得&lt;code>DeleteGlobalRef&lt;/code>。访问对象需要先拿到相应的id，然后根据访问类型确定访问方法。设置属性通常是&lt;code>SetXField&lt;/code>的形式，获取属性值通常是&lt;code>GetXField&lt;/code>的形式。调用方法，需要根据返回值的类型确定调用方法，通常是&lt;code>CallXMethod&lt;/code>的形式。当然，这些都是针对普通对象的，假如需要访问静态属性或者方法，则是在普通版本的&lt;code>X&lt;/code>前面加上&lt;code>Static&lt;/code>。这里的所有&lt;code>X&lt;/code>都是指代类型，除了基本类型外，其他对象都用&lt;code>Object&lt;/code>替换。&lt;/p>
&lt;p>在注册函数和访问数据的时候需要时刻关注的就是数据类型。C/C++数据类型除了基本类型外都不能直接传递到Java里，需要通过创建对象的方式传递。一般的创建对象方式&lt;code>NewObject&lt;/code>可以创建任何对象，而对于使用频繁的字符串和数组有对应的快速方法&lt;code>NewStringUTF&lt;/code>，&lt;code>NewXArray&lt;/code>。向Java传递字符串和数组，这两个方法少不了。&lt;/p>
&lt;p>青山不改，绿水长流，咱们下期见！&lt;/p></description></item><item><title>CMake个人理解和使用</title><link>https://hongui.github.io/post/CMake%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3%E5%92%8C%E4%BD%BF%E7%94%A8.html</link><pubDate>Mon, 09 Aug 2021 19:21:49 +0800</pubDate><guid>https://hongui.github.io/post/CMake%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3%E5%92%8C%E4%BD%BF%E7%94%A8.html</guid><description>&lt;h1 id="前言">前言&lt;/h1>
&lt;p>CMake是一个构建工具，通过它可以很容易创建跨平台的项目。通常使用它构建项目要分两步，通过源代码生成工程文件，通过工程文件构建目标产物（可能是动态库，静态库，也可能是可执行程序）。使用CMake的一个主要优势是在多平台或者多人协作的项目中，开发人员可以根据自己的喜好来使选择IDE，不用受其他人工程配置的影响，它有点像跨平台的IDE，通过它配置好相关设置之后，可以在多个平台无缝衔接，提高开发效率。&lt;/p>
&lt;h1 id="最简单的cmake工程">最简单的CMake工程&lt;/h1>
&lt;h2 id="项目搭建">项目搭建&lt;/h2>
&lt;p>一个用CMake来管理的项目，其项目根目录通常会包含一个&lt;code>CMakeLists.txt&lt;/code>的文件，当然子目录可能也有，这种情况我们稍后再说。我们先从最简单的项目开始。以下就是一个最简单的工程示例：&lt;/p>
&lt;pre tabindex="0">&lt;code>CMakeProject
| CMakeLists.txt
| main.cpp
&lt;/code>&lt;/pre>&lt;p>这就是完整的可以跑起来的最小项目了。按照顺序，我们来看看文件里的内容&lt;/p>
&lt;p>&lt;code>CMakeLists.txt&lt;/code>&lt;/p>
&lt;pre tabindex="0">&lt;code># 设置版本号
cmake_minimum_required(VERSION 3.10)
# 设置项目名
project(CMakeProject)
# 设置产物和源码的关联
add_executable(${CMAKE_PROJECT_NAME} main.cpp)
&lt;/code>&lt;/pre>&lt;p>说明：&lt;/p>
&lt;ul>
&lt;li>CMake中命令不区分大小写&lt;/li>
&lt;li>以&lt;code>#&lt;/code>开始的是备注&lt;/li>
&lt;li>引用变量语法&lt;code>${变量名}&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>所以文档中真正的有效内容就三行，&lt;/p>
&lt;ol>
&lt;li>&lt;code>cmake_minimum_required(VERSION 3.10)&lt;/code>设置了CMake支持的最低版本，&lt;code>VERSION&lt;/code>是参数名，后面是版本号，可以根据自己的需要修改。 &lt;strong>注意参数名和参数是以空白符分隔的，不是逗号，&lt;/strong> 不然会报错。&lt;/li>
&lt;li>&lt;code>project(CMakeProject)&lt;/code>CMake中字符串可以带引号或者不带，效果是一致的，这一行就是配置了项目名，如生成的Visual Studio的工程名就是依据这个名字来的。&lt;/li>
&lt;li>&lt;code>add_executable(${CMAKE_PROJECT_NAME} main.cpp)&lt;/code>
才是真正管理源码和目标产物的地方，这里我们使用了引用变量的写法，而文件中没有定义这个变量，说明这个变量存在于CMake中，在CMake还有很多预定义的变量，我们可以直接通过这种方式引用，上面的写法是将项目名设置为产物的名字，当然也可以直接填字符串，取个另外的名字都是可以的。后面的&lt;code>main.cpp&lt;/code>则是用来生成产物的源码路径，这就是CMake最灵活的地方。&lt;strong>源码路径可以是多样的，查找出来的，直接写的，相对路径，绝对路径都可以。&lt;/strong> 多个源码的话就用空白符分隔，依次写就行了。
在上面的配置文件中，我们配置了它的源文件为&lt;code>main.cpp&lt;/code>，我们想通过它来生成一个可执行的程序，内容也很简单:&lt;/li>
&lt;/ol>
&lt;pre tabindex="0">&lt;code>#include &amp;lt;iostream&amp;gt;
int main()
{
std::cout&amp;lt;&amp;lt;&amp;#34;hello CMake&amp;#34;&amp;lt;&amp;lt;std::endl;
return 0;
}
&lt;/code>&lt;/pre>&lt;h2 id="项目编译与执行">项目编译与执行&lt;/h2>
&lt;p>准备工作已经做完，接下来我们就要使用CMake生成可执行文件了。&lt;/p>
&lt;p>第一步当然是要安装CMake啦，这是下载地址&lt;a class="link" href="https://cmake.org/download/" target="_blank" rel="noopener"
>!Download&lt;/a>，根据自己的平台选择下载即可，安装完成之后需要把它添加到环境变量中，便于我们在任何地方都能方便使用。
安装了CMake以后，打开命令行工具，进入到刚才创建的项目根目录，也就是进入到存着&lt;code>CMakeLists.txt&lt;/code>和&lt;code>main.cpp&lt;/code>的目录，下一步准备生成项目。&lt;/p>
&lt;p>通常为了不影响和污染当前的工作环境，我们会选择新建一个目录来存放生成的工程文件，以下我主要以Windows平台为主要平台讲解，其他平台基本一致。&lt;/p>
&lt;pre tabindex="0">&lt;code>mkdir build #创建文件夹，存储工程文件；
cd build #切换cmake工作目录;
cmake .. #生成项目文件；
&lt;/code>&lt;/pre>&lt;p>这三步执行完后，我们就可以在build文件夹下看到里面已经生成了一个Visual Studio的工程，我们可以直接用Visual Studio打开这个工程，按照我们的习惯执行编译和调试。当然，假如想最快地生成可执行文件，我还是推荐使用CMake。&lt;/p>
&lt;p>使用CMake执行编译，只需要在上一步的基础上（也就是已经成功执行了上面的三个步骤）再执行一个命令&lt;code>cmake --build .&lt;/code>就可以了。这里切记不能少第三个英文句号，它代表在当前的工作目录中执行CMake的编译。
假如上面的四步都一切顺利的话，那么，我们就可以在&lt;code>build/debug&lt;/code>目录下看到以&lt;code>add_executable&lt;/code>的第一个参数命名的可执行文件（这里就是&lt;code>CMakeProject.exe&lt;/code>），双击或者把它拖到命令行就可以执行它了。&lt;/p>
&lt;h2 id="项目扩展">项目扩展&lt;/h2>
&lt;p>在前面的例子中，生成工程文件，我们使用了两个命令，其实，这里可以直接用一个命令就可以完成——&lt;code>cmake build -S . -B build&lt;/code>。这个命令的意思是以当前路径为工作路径，以&lt;code>build&lt;/code>目录为生成目录，生成工程文件，也就是不需要我们手动创建&lt;code>build&lt;/code>文件夹了。其中 &lt;code>-S&lt;/code>参数配置的是源路径，&lt;code>-B&lt;/code>配置的是生成路径。&lt;/p>
&lt;p>另外，由于CMake没有清理方法，所以每次修改CMake的配置（也就是新增或者删除&lt;code>CMakeLists.txt&lt;/code>中的代码），需要重新生成工程文件的时候，需要我们手动清理生成目录，保证它是空目录，假如不这样做，那么项目可能生成失败或者新配置不起作用。假如只是修改了源代码的内容的话，则不需要重新生成，直接进行第四步即可。
虽然上面的操作已经足够简单，但是考虑到长期的修改和验证需要，还是太繁琐枯燥了，尤其是要反复切换工作目录，还是比较烦人的。所以我推荐使用批处理来完成这些操作。结合清理生成目录和切换工作目录这几个步骤，最终的批处理文件可能是这样的&lt;/p>
&lt;pre tabindex="0">&lt;code>
@echo off
rd /s /q build
mkdir build
cd build
cmake ..
cmake --build .
cd debug
CMakeProject
cd ../..
&lt;/code>&lt;/pre>&lt;p>按顺序依次解释一下:&lt;/p>
&lt;p>第一行是关闭了命令行的回显功能，因为我们不希望它的回显干扰到CMake的信息输出，以造成不必要的混乱，而且通常我们也只关心它最后有没有完成工作而不是看它在干什么。&lt;/p>
&lt;p>第二行则是用了Windows上的删除文件夹命令（Linux，MacOS上对应的是rmdir),/s是配置它清除文件夹中所有的内容，包括子文件夹，不配置命令就会执行失败，/q则是让命令直接执行删除，不需要我们手动确认，这个参数很重要，不然我们需要一个一个地确认删除，完全失去了自动化的作用。然后后面的四句就是我们上面讲的内容了，不再赘述。&lt;/p>
&lt;p>一直来到倒数第二句，这里我直接写了可执行文件的名字（需要替换为你自己的名字），为的就是直接在编译完成之后运行可执行文件，这对有些会生成文件的应用来说很有用。&lt;/p>
&lt;p>执行结束后，再将目录切回到项目根目录，这就是最后一行的作用，由于我们再编译的时候已经切换了目录到生成目录了，而编译的可执行文件又是在生成目录的子目录中，所以回到根目录，我们需要回退两次，这是保证下次我们能胜利执行批处理的关键。&lt;/p>
&lt;p>把上面的内容保存为bat结尾的文件，然后下次就可以直接在命令行输入bat文件名来一次性完成生成和构建了，简直爽歪歪。
以上就是CMake项目我们所需要知道的了。当然实际项目远比这个复杂得多，接下来我将以我踩过的坑为基础，逐一增加项目的复杂度，慢慢形成对CMake的工作流程的理解。&lt;/p>
&lt;h1 id="多源码项目">多源码项目&lt;/h1>
&lt;h2 id="个人感悟">个人感悟&lt;/h2>
&lt;p>在开始之前，我先讲一讲我对CMake项目或者说&lt;code>CMakeLists.txt&lt;/code>文件的理解。&lt;strong>我们不能单独的以某一个配置为理解对象，我们需要对这些命令进行分类甚至提炼出它的核心工作模式。我是以c++文件的编译链接为线索梳理的。&lt;/strong> 我们都知道一个c++源文件要想生成可执行代码，需要分三步&lt;/p>
&lt;ul>
&lt;li>预处理器处理，拷贝头文件的内容到源文件，宏替换等；&lt;/li>
&lt;li>编译器将源文件编译为.o的对象文件；&lt;/li>
&lt;li>链接器以.o文件和其他库为输入，链接生成可执行文件。&lt;/li>
&lt;/ul>
&lt;p>我们按照这个思路来理解CMake就简单多了。假如CMake报错，我们就可以根据报错信息定位到是哪个阶段出了问题，进而快速找到解决办法。另外我们也可以依据这些信息对CMake的配置分类，我自己理解的粗略分类如下:&lt;/p>
&lt;ul>
&lt;li>配置CMake基本信息的：&lt;code>cmake_minimum_required&lt;/code>；&lt;/li>
&lt;li>源码管理的：&lt;code>file&lt;/code>,&lt;code>aux_source_directory&lt;/code>；&lt;/li>
&lt;li>库管理的：&lt;code>find_libraray&lt;/code>；&lt;/li>
&lt;li>头文件管理的：&lt;code>include_directories&lt;/code>；&lt;/li>
&lt;li>链接库管理的：&lt;code>link_directories&lt;/code>；&lt;/li>
&lt;li>子项目管理的：&lt;code>add_subdirectory&lt;/code>；&lt;/li>
&lt;li>生成物管理的：&lt;code>add_executable&lt;/code>,&lt;code>add_library&lt;/code>；&lt;/li>
&lt;/ul>
&lt;p>当然，这些只是很少的一部分，但是对我们理解和搜索问题的解决思路提供了较好的方向。&lt;/p>
&lt;h2 id="cmake管理子目录">CMake管理子目录&lt;/h2>
&lt;p>很多时候，我们会引入第三方包来减少重复编码的工作，通常这种代码我们需要放在其他目录中，于是我新建了一个子目录，用于模拟存放的第三方代码。对于这种情况，我们有两种包含形式——子模块和子目录。&lt;/p>
&lt;p>先说简单一些的子目录吧。子目录的意思就是将第三方代码看作我们代码的一部分，一起合并编译，这种方式可以使我们的项目看起来更紧凑。如以下的项目结构&lt;/p>
&lt;pre tabindex="0">&lt;code>CMakeProject
| auto.bat
| CMakeLists.txt //修改
| main.cpp //修改
|
\---3rd //新增
lib.h
&lt;/code>&lt;/pre>&lt;p>我新建了一个子文件夹，用来模拟第三方代码，现在我们把它引入到&lt;code>main.cpp&lt;/code>中，编译，就会发现报错了，信息为&lt;code>fatal error C1083: 无法打开包括文件: “lib.h”: No such file or directory，&lt;/code>这很正常。结合上面我举的例子。这个报错信息是和头文件相关的，查看CMake文档，我发现了CMake有个&lt;code>include_directories&lt;/code>的指令，它的意思就是添加文件头的目录，以便让CMake找到头文件。于是，我在&lt;code>CMakeLists.txt&lt;/code>文件中添加了&lt;code>include_directories(3rd)&lt;/code>，然后再次执行编译，项目又正确跑起来了。来看看这时的&lt;code>main.cpp&lt;/code>&lt;/p>
&lt;pre tabindex="0">&lt;code>#include &amp;lt;iostream&amp;gt;
#include &amp;lt;lib.h&amp;gt;
int main()
{
int a=1,b=1;
std::cout&amp;lt;&amp;lt;&amp;#34;hello CMake&amp;#34;&amp;lt;&amp;lt;std::endl;
std::cout&amp;lt;&amp;lt;&amp;#34;a + b = &amp;#34;&amp;lt;&amp;lt;sum(a,b)&amp;lt;&amp;lt;std::endl;
return 0;
}
&lt;/code>&lt;/pre>&lt;p>注意：这里的&lt;code>include_directories&lt;/code>和cpp中的&lt;code>include&lt;/code>是一一对应的，就是说，假如&lt;code>include_directories&lt;/code>里面配置的目录是.（当前目录，CMake没有把当前目录添加到&lt;code>include&lt;/code>路径），则对应cpp的&lt;code>include&lt;/code>要写成&lt;code>3rd/lib.h&lt;/code>这种形式，简单来说，就是&lt;code>include_directories&lt;/code>被设置为了&lt;code>include&lt;/code>的根目录。
另一种情况就是子模块。&lt;/p>
&lt;h2 id="cmake管理子模块">CMake管理子模块&lt;/h2>
&lt;p>子模块的意思是，模块可以单独编译，单独提供给其他库使用，而不是和主项目共生的，适用于和主模块耦合不大的情况。为了满足这个条件，我们修改刚才的目录结构为下面这种&lt;/p>
&lt;pre tabindex="0">&lt;code>CMakeProject
| auto.bat
| CMakeLists.txt //修改
| main.cpp
|
\---3rd
CMakeLists.txt //新增
lib.cpp //新增
lib.h //修改
&lt;/code>&lt;/pre>&lt;p>我把&lt;code>lib.h&lt;/code>中的函数改为声明，实现放在了&lt;code>lib.cpp&lt;/code>文件中。最大的变化是新建了&lt;code>3rd&lt;/code>目录下的&lt;code>CMakeLists.txt&lt;/code>文件，用它统一管理&lt;code>3rd&lt;/code>目录下的所有源文件（假如文件很多的话，这里是模拟）,使用了&lt;code>add_library&lt;/code>把&lt;code>3rd&lt;/code>目录下打包成了子模块。&lt;/p>
&lt;pre tabindex="0">&lt;code>project(sum)
add_library(${PROJECT_NAME} lib.cpp)
&lt;/code>&lt;/pre>&lt;p>&lt;code>add_library&lt;/code>在名字和源代码中间还可以指定构建类型，默认是&lt;code>STATIC&lt;/code>，也就是静态库，假如想构建动态库需要手动指定为&lt;code>SHARED&lt;/code>（&lt;code>add_library(${PROJECT_NAME} SHARED lib.cpp)&lt;/code>）。&lt;/p>
&lt;p>重要的改变来自主目录下的&lt;code>CMakeLists.txt&lt;/code>&lt;/p>
&lt;pre tabindex="0">&lt;code># 设置版本号
cmake_minimum_required(VERSION 3.10)
# 设置项目名
project(CMakeProject)
# 指定3rd为include的查找目录
include_directories(3rd)
# 子模块
add_subdirectory(3rd)
# 设置产物和源码的关联
add_executable(${PROJECT_NAME} main.cpp)
target_link_libraries(${PROJECT_NAME} sum)
&lt;/code>&lt;/pre>&lt;p>新增了&lt;code>add_subdirectory&lt;/code>，它的作用是将指定目录下的源码作为一个模块编译，前提是这个目录下要有&lt;code>CMakeLists.txt&lt;/code>文件。另一个改变就是&lt;code>target_link_libraries&lt;/code>的添加，它的作用是将子模块链接进主模块，假如没有这一句，在链接的时候会报错&lt;code>error LNK2019: 无法解析的外部符号&lt;/code>。模块的名字需要和子模块中&lt;code>add_library&lt;/code>中第一个参数保持一致。&lt;/p>
&lt;h1 id="交叉编译">交叉编译&lt;/h1>
&lt;p>在前面的示例中，项目的复杂度表现在多目录，多源码，而在使用CMake进行交叉编译的过程中，项目的主要复杂度表现在环境配置。尽管CMake可以几乎不修改&lt;code>CMakeLists.txt&lt;/code>的情况下，实现交叉编译，但是对于新手，面对陌生的配置，往往会无从下手，企图找到一键就完成配置的简便方法。对于CMake,确实没有这种快捷方法，但是，只要我们理解了&lt;strong>交叉编译就是正确配置属性值的过程。&lt;/strong> 这一实质之后，问题就会变得明朗起来。所以，上面的问题就会转化为我们熟悉的问题了——需要配置哪些属性，这些属性有哪些合适的值，这些值怎样传递给CMake等等，这就是交叉编译的全部了。正如之前提到的一样，CMake有很多预设的变量，我们需要从这些预设变量中找到一些，设置一些值，然后让CMake按照这些配置完成工作，这就是我们接下来需要做的事。下面我将以Windows交叉编译Android为例说明这个过程。&lt;/p>
&lt;h2 id="前期准备">前期准备&lt;/h2>
&lt;p>在Windows平台上，默认会使用Visual Studio作为C，C++的编译器，这对于编译Android的库来说可能会报错。所以在执行&lt;code>cmake&lt;/code>命令的时候，需要使用&lt;code> -G &amp;quot;Unix Makefiles&amp;quot;&lt;/code>来改变这一行为。但这还不够，因为CMake编译是需要指定编译器的。而Android上的C,C++编译器通常以NDK的方式提供，所以，我们需要下载好NDK。在NDK中，会同时为我们提供两种工具，一种就是编译器，另一种就是&lt;code>android.toolchain.cmake&lt;/code>,这也是CMake命令构成的文件，里面为我们交叉编译指定了很多预设值，能大大减轻我们的工作。&lt;/p>
&lt;h2 id="编写编译脚本">编写编译脚本&lt;/h2>
&lt;p>前面说了，交叉编译就是改变CMake预设值，而改变这预设值的方式有两种，我们要结合起来使用。一种是通过NDK提供的&lt;code>android.toolchain.cmake&lt;/code>文件。 &lt;code>android.toolchain.cmake&lt;/code>中以设置了绝大部分的值，但是这些配置也是很灵活的，还有很大的配置空间。因此，根据用户的需求不同，我们还需要在执行CMake命令时动态传递一些值，以使CMake能正确完成工作。这就是另一种方式——选项。传递选项会以&lt;code>-D&lt;/code>开头，后面跟着某个CMake的预定义变量由于选项很多，而且大多比较复杂，所以，最好还是通过脚本文件来记录并且修改。以下就是Windows平台上编译Android代码需要指定的几个选项，我将逐个介绍这些必要的配置。&lt;/p>
&lt;ul>
&lt;li>&lt;code>-DCMAKE_SYSTEM_NAME=Android&lt;/code>这个配置是告诉CMake需要生成Android平台的库，也就是执行交叉编译。&lt;/li>
&lt;li>&lt;code>-DANDROID_ABI=x86&lt;/code>这个配置是告诉CMake生成库适用的架构平台。熟悉Android开发的读者应该不会陌生，支持的值会根据NDK的变化而有所变化，如早期的&lt;code>armeabi&lt;/code>已经在 NDK r17中移除了，现在主流的还有四种&lt;code>armeabi-v7a&lt;/code>，&lt;code>arm64-v8a&lt;/code>，&lt;code>x86&lt;/code>，&lt;code>x86_64&lt;/code>.根据需要把值替换就行。&lt;/li>
&lt;li>&lt;code>-DANDROID_PLATFORM=android-28&lt;/code>,这个值其实不是特别必要，因为有预设值，但是为了可控，还是需要指定一个。它是用来确定库支持的最低系统版本的。&lt;/li>
&lt;li>&lt;code>-DCMAKE_TOOLCHAIN_FILE=C:/Users/Leroene/AppData/Local/Android/Sdk/ndk/21.0.6113669/build/cmake/android.toolchain.cmake&lt;/code>，这是上面提到的预设文件。需要注意的是，NDK中有多个以这个名字命名的文件，假如指定错误，可能会导致CMake出错，所以我的经验就是，更改版本号（&lt;code>C:/Users/Leroene/AppData/Local/Android/Sdk/ndk/21.0.6113669&lt;/code>）及前面的路径，后面的保持不变。&lt;/li>
&lt;li>&lt;code>-DCMAKE_MAKE_PROGRAM=C:/Users/Leroene/AppData/Local/Android/Sdk/ndk/21.0.6113669/prebuilt/windows-x86_64/bin/make&lt;/code>最后一个参数是指定&lt;code>make&lt;/code>程序的路径，由于我们指定生成了make项目的代码，而Windows通常没有make可执行文件，所以我们需要让CMake找到make文件以完成编译。这里我的经验也是保持后面的不变，修改前面的，并保持版本一致以避免BUG。&lt;/li>
&lt;li>&lt;code>-DCMAKE_BUILD_TYPE=Release&lt;/code>，指定构建类型，这应该很常见了。&lt;/li>
&lt;/ul>
&lt;p>至此Windows交叉编译Android库的所有配置都讲解完了。让我们来看看它完整的例子&lt;/p>
&lt;pre tabindex="0">&lt;code>@echo off
rd /s /q build
mkdir build
cd build
cmake -G &amp;#34;Unix Makefiles&amp;#34; ^
-DCMAKE_TOOLCHAIN_FILE=C:/Users/Leroene/AppData/Local/Android/Sdk/ndk/21.0.6113669/build/cmake/android.toolchain.cmake ^
-DCMAKE_MAKE_PROGRAM=C:/Users/Leroene/AppData/Local/Android/Sdk/ndk/21.0.6113669/prebuilt/windows-x86_64/bin/make ^
-DANDROID_PLATFORM=android-28 ^
-DCMAKE_SYSTEM_NAME=Android ^
-DANDROID_ABI=x86 ^
-DCMAKE_BUILD_TYPE=Release ^
../3rd
cmake --build .
&lt;/code>&lt;/pre>&lt;p>从上面可以看到，这些选项后面都跟着一个&lt;code>^&lt;/code>符号，这不是cmake的一部分，只是为了我们阅读方便，特意书写成这样的，这是在Windows平台上批处理使用的命令换行符，它的作用就是告诉命令解析器，这个命令还没有结束，接着往下面解析，该功能在Linux,MacOS上对应于&lt;code>\&lt;/code>。现在有了这些配置之后，该怎么使用呢？其实也很简单，只需要将这些命令存储在&lt;code>android.bat&lt;/code>文件中，在CMD中切换到当前目录，执行这个文件就能在&lt;code>build&lt;/code>目录中找到以&lt;code>libsum.a&lt;/code>命名的静态库文件了。下一步，我们试着用这个库文件运行在模拟器中。&lt;/p>
&lt;h1 id="在android项目中使用cmake">在Android项目中使用CMake&lt;/h1>
&lt;p>在Android平台中，也使用CMake来管理jni的项目，配合Gradle一起完成构建工作。这和普通的CMake项目最大的不同是，我们通常需要引用多个Android相关的库，如&lt;code>log&lt;/code>,&lt;code>android&lt;/code>等.这些库通常是由NDK提供的，我们仿照默认生成的&lt;code>CMakeLists.txt&lt;/code>文件编写就可。&lt;/p>
&lt;h2 id="目录结构">目录结构&lt;/h2>
&lt;p>接下来，为了描述方便，我们先来看一下现在的目录结构（为了避免混乱，这里只列出比较有代表性的文件）&lt;/p>
&lt;pre tabindex="0">&lt;code>CMakeProject
│ android.bat
│ CMakeLists.txt
│ main.cpp
│
├─3rd
│ CMakeLists.txt
│ lib.cpp
│ lib.h
│
└─Android
│ build.gradle
│
├─app
│ │ build.gradle
│ │
│ ├─libs
│ └─src
│ ├─main
│ │ │ AndroidManifest.xml
│ │ │
│ │ ├─cpp
│ │ │ CMakeLists.txt
│ │ │ native-lib.cpp
│ │ │
│ │ ├─java
│ │ │ └─me
│ │ │ └─hongui
│ │ │ └─cmakesum
│ │ │ MainActivity.kt
│ │ │
│ │ ├─jniLibs
│ │ │ └─x86
│ │ │ libsum.a
&lt;/code>&lt;/pre>&lt;p>在原来的目录根目录下新建了&lt;code>Android&lt;/code>子目录，该目录是一个Android C++工程，所以相比其他普通Android工程，它多了个&lt;code>cpp&lt;/code>目录，后面我们主要的修改都是发生在该目录下。&lt;/p>
&lt;p>原来的根目录，为了不增加复杂度，我们只作为生成静态库的功能存在，所以和上面的示例相比，没有任何修改。&lt;/p>
&lt;h2 id="构建静态库">构建静态库&lt;/h2>
&lt;p>首先，我们回到根目录。使用根目录下的&lt;code>android.bat&lt;/code>批处理生成Android上可用的静态库，也可以修改&lt;code>android.bat&lt;/code>文件中的&lt;code>-DANDROID_ABI&lt;/code>选项的值，生成其他架构的静态库，但这需要和&lt;code>jniLibs&lt;/code>目录下的目录要一一对应，否则可能链接失败。如我生成的&lt;code>libsum.a&lt;/code>文件是&lt;code>x86&lt;/code>的架构。那么就需要在&lt;code>jniLibs&lt;/code>目录下新建&lt;code>x86&lt;/code>的目录下，然后再把&lt;code>libsum.a&lt;/code>放到该目录下。至此，静态库的构建工作就算结束了。&lt;/p>
&lt;h2 id="使用静态库">使用静态库&lt;/h2>
&lt;p>把静态库放到合适的位置后，我们需要配置&lt;code>app&lt;/code>目录下的&lt;code>build.gradle&lt;/code>和&lt;code>cpp&lt;/code>目录下的&lt;code>CMakeLists.txt&lt;/code>文件，完成静态库的引入。&lt;/p>
&lt;h3 id="配置gradle">配置Gradle&lt;/h3>
&lt;p>首先说&lt;code>build.gradle&lt;/code>，该文件主要涉及到修改ABI的问题，因为不指定的话，Gradle默认生成的ABI可能找不到对应的静态库文件来链接，从而导致链接失败。该文件主要的修改如下&lt;/p>
&lt;pre tabindex="0">&lt;code>android {
defaultConfig {
externalNativeBuild {
cmake {
cppFlags &amp;#34;&amp;#34;
abiFilters &amp;#34;x86&amp;#34;
}
}
}
}
&lt;/code>&lt;/pre>&lt;p>也就是把&lt;code>abiFilters&lt;/code>的值指定为刚才构建的静态库相同的值。&lt;/p>
&lt;h3 id="配置cmake">配置CMake&lt;/h3>
&lt;p>而&lt;code>CMakeLists.txt&lt;/code>文件就复杂一些了，它需要完成两个工作，找到静态库和静态库的头文件，链接静态库。&lt;/p>
&lt;h4 id="找到头文件">找到头文件&lt;/h4>
&lt;p>在文章的第二部分我们已经知道了让CMake找到头文件的&lt;code>include_directories&lt;/code>命令，把参数设置为&lt;code>3rd&lt;/code>目录就行了。值得注意的是，CMake是以当前的&lt;code>CMakeLists.txt&lt;/code>文件为工作目录的，所以，要指定到&lt;code>3rd&lt;/code>文件，我们需要一直回退目录到根项目，最终就有了&lt;code>include_directories(../../../../../3rd)&lt;/code>这样的配置。尽量使用相对路径，可以在多人协同的情况下，不用修改配置。&lt;/p>
&lt;h4 id="找到静态库">找到静态库&lt;/h4>
&lt;p>下一步要让CMake找到我们的静态库。说到库，都是和&lt;code>add_library&lt;/code>相关的，不同的只是参数。使用源码添加库的时候，我们需要指定库的名称和源码位置，而引用第三方库，则是需要指定库的名称和类型，外加一个&lt;code>IMPORTED&lt;/code>的指示参数，告诉CMake这个库是导入的。所以就有了&lt;code>add_library(addSum STATIC IMPORTED)&lt;/code>这样的配置。&lt;/p>
&lt;p>但是，这里我们只告诉了CMake库的名字，库存储在哪里，还不知道，所以我们还需要另一个命令告诉CMake库的存储位置。涉及到配置参数的，通常就是&lt;code>set_target_properties&lt;/code>命令了，可以多次调用这个命令设置多种配置。&lt;code>set_target_properties(addSum PROPERTIES IMPORTED_LOCATION ${CMAKE_CURRENT_SOURCE_DIR}/../jniLibs/${ANDROID_ABI}/libsum.a)&lt;/code>,第一个参数和上一条的第一个参数是一一对应的，可以随便取。其实&lt;code>add_library&lt;/code>相当于生成了一种目标产物，用第一个参数来指代这种产物，所以才让我们的&lt;code>set_target_properties&lt;/code>找得到合适的目标设置属性。第二个参数则是配置属性的标准写法，第三个代表属性变量，第四个是属性值，配置库路径的变量就是&lt;code>IMPORTED_LOCATION&lt;/code>，而值这里就有个坑了，Android下的CMake限定值必须是绝对路径，不能是相对路径。而这与使用CMake的初衷背道而驰，幸好，我们有几个预设值可以用，&lt;code>CMAKE_CURRENT_SOURCE_DIR&lt;/code>就是其中之一，它代表着当前这个&lt;code>CMakeLIsts.txt&lt;/code>文件的绝对路径，有了这个，再加上目录的回退功能，我们就能找到任何合适的目录了。至此，又出现了第二个问题，当有多个架构的静态库需要配置时，我们引入的目录是不一样的，而且会出现很多重复的配置。还好有&lt;code>ANDROID_ABI&lt;/code>的帮助，它指代了当前编译的某个架构，随着编译的进行，这个值会被设置为合适的值，并且是和正在编译的架构是一一对应的。所以，尽管它们有点奇怪，但是这给我带来了灵活和简单。&lt;/p>
&lt;h4 id="链接静态库">链接静态库&lt;/h4>
&lt;p>现在头文件有了，库也有了，但是C++的编译是分成两步的，目前为止，我们的工作只做完了编译的事情，还没涉及到链接的事情，当然，相比前面的配置，这就简单多了，无疑就是在&lt;code>target_link_libraries&lt;/code>命令里添加一个参数就可，如&lt;/p>
&lt;pre tabindex="0">&lt;code>target_link_libraries(
native-lib
${log-lib}
addSum
)
&lt;/code>&lt;/pre>&lt;p>只需哟注意名字和&lt;code>add_library&lt;/code>时配置的名字一一对应就可。&lt;/p>
&lt;h3 id="在源码中使用">在源码中使用&lt;/h3>
&lt;p>经过漫长的等待，现在我们终于能在&lt;code>native-lib.cpp&lt;/code>文件中引入&lt;code>addsum&lt;/code>的头文件，并且使用里面的函数完成工作了。我打算让函数返回一个包含加法运算结果的字符串。最终实现如下&lt;/p>
&lt;pre tabindex="0">&lt;code>#include &amp;lt;jni.h&amp;gt;
#include &amp;lt;string&amp;gt;
#include &amp;lt;lib.h&amp;gt;
extern &amp;#34;C&amp;#34; JNIEXPORT jstring JNICALL
Java_me_hongui_cmakesum_MainActivity_stringFromJNI(
JNIEnv* env,
jobject /* this */) {
std::string hello = std::to_string(sum(1,1));
return env-&amp;gt;NewStringUTF(hello.c_str());
}
&lt;/code>&lt;/pre>&lt;p>至此，点击工具栏上的&lt;code>run&lt;/code>按钮，我们终于可以在Android的模拟器上看到我们的静态库工作的成果啦。&lt;/p>
&lt;h2 id="扩展">扩展&lt;/h2>
&lt;p>其实除了引用静态库的方式之外，我们还可以直接通过配置&lt;code>CMakeLists.txt&lt;/code>文件来引用源码，这样可以随时随地对源码进行定制，但是也降低了编译速度，而且可能会增加&lt;code>CMakeLists.txt&lt;/code>的复杂度。所以我还是推荐直接使用静态库的方式。&lt;/p>
&lt;h1 id="总结">总结&lt;/h1>
&lt;p>CMake其实还有很多很多命令，我们这里涉及到的只是很少的一部分。但是，我觉得理解CMake有这些内容差不多就可以了，后续有需要再针对性学习就行了。学习一门技术，切忌不能贪多，贪细。先要抓住主干，理清脉络，后面的细节就是水到渠成的事。对于CMake，我觉得就是以C++代码编译为二进制的过程为主干就够了。源码从哪里来，头文件在那里，库文件在哪里，怎么组织编译，参与链接的库有哪些，生成什么产物，还有一些完成这些工作的通用操作，复制文件啊，目录信息啊等，这些操作的集合就构成了CMake的主体。另外，CMake其实只是一种构建工具，它本身不是编译器和链接器，有些问题可能不仅仅会涉及到cmake，还可能会涉及到编译器和连接器。当然，这些都是后面深入了解之后才可能碰到的问题了。&lt;/p></description></item><item><title> Kotlin协程-从一到多</title><link>https://hongui.github.io/post/%20Kotlin%E5%8D%8F%E7%A8%8B-%E4%BB%8E%E4%B8%80%E5%88%B0%E5%A4%9A.html</link><pubDate>Tue, 30 Mar 2021 19:10:30 +0800</pubDate><guid>https://hongui.github.io/post/%20Kotlin%E5%8D%8F%E7%A8%8B-%E4%BB%8E%E4%B8%80%E5%88%B0%E5%A4%9A.html</guid><description>&lt;blockquote>
&lt;p>上一篇文章，我介绍了Kotlin协程的创建，使用，协作等内容。本篇将引入更多的使用场景，继续带你走进协程世界。&lt;/p>
&lt;/blockquote>
&lt;h1 id="使用协程处理异步数据流">使用协程处理异步数据流&lt;/h1>
&lt;p>常用编程语言都会内置对同一类型不同对象的数据集表示，我们通常称之为容器类。不同的容器类适用于不同的使用场景。Kotlin的&lt;code>Flow&lt;/code>就是在异步计算的需求下引入的，用于表示异步的数据流。&lt;/p>
&lt;h2 id="flow">Flow&lt;/h2>
&lt;p>“问渠哪得清如许，为有源头活水来”，异步数据流的基本就是以某种方式获得异步数据。Kotlin提供了多种种方式，比较常用的就是Kotlin协程包的&lt;code>asFlow&lt;/code>扩展和&lt;code>flow&lt;/code>构造器。前者是对普通数据集的&lt;code>Flow&lt;/code>化封装，没有更多可言，我们着重来看后者。
&lt;code>flow&lt;/code>构造器的主要目标就是产生一个异步数据流，它是一个泛型函数，参数是一个挂起函数，并且是&lt;code>FlowCollector&lt;/code>是扩展函数。这个接口只有一个&lt;code>emit&lt;/code>方法，就是为创建的&lt;code>Flow&lt;/code>提供异步计算的数据的，因为它是挂起函数，所以我们能在里面使用其他挂起函数计算异步值，然后通过&lt;code>emit&lt;/code>方法将值发送出去，如此反复就能为下游操作提供源源不断的数据流了。
事情还没完，上面的步骤我们只是规定了创建数据的方式，并没有真正执行，也就是建好了道路，但是还没有车上路。那么，怎样才能让车在路上跑呢，查看&lt;code>Flow&lt;/code>的接口会发现，它提供了&lt;code>collect&lt;/code>方法来处理数据。&lt;code>collect&lt;/code>接收一个挂起函数作为处理逻辑，但是同时，&lt;code>collect&lt;/code>方法本身也是挂起函数，所以，这个方法只能在挂起函数中运行。有了这些知识，我们就可以写出最简单的异步数据流了。&lt;/p>
&lt;div class="highlight">&lt;div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
&lt;table style="border-spacing:0;padding:0;margin:0;border:0;">&lt;tr>&lt;td style="vertical-align:top;padding:0;margin:0;border:0;">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">13
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">14
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">15
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">16
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#099">1u&lt;/span>spend &lt;span style="color:#000;font-weight:bold">fun&lt;/span> &lt;span style="color:#900;font-weight:bold">compute&lt;/span>():Int{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> delay(&lt;span style="color:#099">123&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">return&lt;/span> &lt;span style="color:#099">1024&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> viewModelScope.launch {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">val&lt;/span> flow=flow&amp;lt;Int&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> emit(&lt;span style="color:#099">9527&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> emit(compute())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> delay(&lt;span style="color:#099">256&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> emit(&lt;span style="color:#099">256&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> flow.collect {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#000;font-weight:bold">it&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在&lt;code>flow&lt;/code>构造器里面随意做各种操作，只要在必要的时候传递结果就行了，但是需要注意的是，&lt;code>emit&lt;/code>方法只能运行在同一个协程里。乍一看，这样分开写和写在一起并没有本质上的差别，但&lt;code>Flow&lt;/code>还能做到更多。&lt;/p>
&lt;h1 id="该给flow换个工作环境了">该给Flow换个工作环境了&lt;/h1>
&lt;p>上一节，我们那个简单的示例，假如把构造器里面的数据获取方法换成网络请求，应用就歇菜了。因为它们都是运行在主线程里面的。那么这个时候，看过上一篇文章的小伙伴马上就会反应过来，用&lt;code>withContext&lt;/code>方法在构造器里面切换线程就行了哇。思路是很对，因为&lt;code>Flow&lt;/code>的默认配置就是构造器和&lt;code>collect&lt;/code>方法工作在同一线程，既然现在主线程不让运行，那就把构造器的线程切换一下就行了呗。然后事实并不是这样，这样写出来的代码根本无法运行。因为官方提供了唯一的&lt;code>flowOn&lt;/code>方法来切换构造器的执行线程。使用也很简单，就是对创建好的&lt;code>Flow&lt;/code>对象配置一次&lt;code>flowOn&lt;/code>方法就行了。&lt;/p>
&lt;div class="highlight">&lt;div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
&lt;table style="border-spacing:0;padding:0;margin:0;border:0;">&lt;tr>&lt;td style="vertical-align:top;padding:0;margin:0;border:0;">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">5
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">6
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">val&lt;/span> flow=[&lt;span style="color:#d14">&amp;#34;1.jpg&amp;#34;&lt;/span>,&lt;span style="color:#d14">&amp;#34;2.jpg&amp;#34;&lt;/span>].asFlow()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>flow.map { decode(&lt;span style="color:#000;font-weight:bold">it&lt;/span>) }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .flowOn(Dispatchers.IO)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>viewModelScope.launch {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> flow.collect{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> adapter.add(&lt;span style="color:#000;font-weight:bold">it&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h1 id="有些中间处理逻辑">有些中间处理逻辑&lt;/h1>
&lt;p>熟悉RxJava的小伙伴可能有疑问了，这些操作RxJava也能完成，甚至还有更多的操作符来支持中间状态的处理，那么异步数据流能做到这些吗。毫无疑问，它可以。普通的数据集有&lt;code>map&lt;/code>,&lt;code>filter&lt;/code>等操作方法，对于异步数据流来说，这些方法同样适用。而且这些方法参数都是挂起函数，都可以执行异步操作。而且它还有个更灵活的&lt;code>transform&lt;/code>方法，这个方法可以定制自己的操作符，实现更灵活的数据操作。&lt;/p>
&lt;p>当然，上面那些操作符都只能实现单一异步流的操作，对于多数据流的支持，它也同样不在话下。&lt;code>zip&lt;/code>可以将两个两个数据源两两合并起来，合成的数据流长度为两个数据流中最短的那个数据流的长度。&lt;code>combine&lt;/code>则与&lt;code>zip&lt;/code>不同，它会将两个数据流最近的发送数据作为输入，也就是说，假如一块一慢的两个数据源，慢的数据源的元素可能会被多次取到，从而最终的数据流比最短的那个都长。&lt;/p>
&lt;div class="highlight">&lt;div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
&lt;table style="border-spacing:0;padding:0;margin:0;border:0;">&lt;tr>&lt;td style="vertical-align:top;padding:0;margin:0;border:0;">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">val&lt;/span> flow = flowOf(&lt;span style="color:#099">1&lt;/span>, &lt;span style="color:#099">2&lt;/span>).delayEach(&lt;span style="color:#099">10&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">val&lt;/span> flow2 = flowOf(&lt;span style="color:#d14">&amp;#34;a&amp;#34;&lt;/span>, &lt;span style="color:#d14">&amp;#34;b&amp;#34;&lt;/span>, &lt;span style="color:#d14">&amp;#34;c&amp;#34;&lt;/span>).delayEach(&lt;span style="color:#099">15&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>flow.combine(flow2) { i, s &lt;span style="color:#000;font-weight:bold">-&amp;gt;&lt;/span> i.toString() + s }.collect {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#000;font-weight:bold">it&lt;/span>) &lt;span style="color:#998;font-style:italic">// Will print &amp;#34;1a 2a 2b 2c&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#998;font-style:italic">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h1 id="结束状态跟踪">结束状态跟踪&lt;/h1>
&lt;p>上一节提到，由于数据源和处理逻辑不在同一个地方，所以很难确定最终的数据流大小，进而不知道数据流什么时候处理结束。而且中间操作也可能会改变数据流的大小，由此就更加难以确定数据处理结束的时机了。但是我们有的时候却需要在数据处理完成后做一些操作，该怎么办呢？这个时候当然是该&lt;code>onCompletion&lt;/code>方法上场了。这个方法有一个可为空的&lt;code>Throwable&lt;/code>类型参数，很显然，这可以同时指示两种处理结果，成功或者失败，失败就会将异常对象传递进来。&lt;/p>
&lt;h1 id="多个协程共同工作">多个协程共同工作&lt;/h1>
&lt;p>很多时候，避免不了让多个协程共同工作。对于返回单个值的协程，上一篇我们也提到过了，可以传递&lt;code>async&lt;/code>构造器的返回对象&lt;code>Deferred&lt;/code>，但是局限性就是这个对象只能传递一个值。针对多值传递的情况，Kotlin提供了&lt;code>Channel&lt;/code>的解决方法。&lt;code>Channel&lt;/code>类似于阻塞队列，数据通过&lt;code>send&lt;/code>方法发送出去，在另外的地方使用&lt;code>receive&lt;/code>方法接收。通过这种方法，我们可以极大提供协程的工作效率。利用它就可以轻松实现生产者和消费者模型。&lt;/p>
&lt;div class="highlight">&lt;div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
&lt;table style="border-spacing:0;padding:0;margin:0;border:0;">&lt;tr>&lt;td style="vertical-align:top;padding:0;margin:0;border:0;">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">val&lt;/span> chanel=Channel&amp;lt;Int&amp;gt;()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> viewModelScope.launch(Dispatchers.IO) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">for&lt;/span> (i &lt;span style="color:#000;font-weight:bold">in&lt;/span> &lt;span style="color:#099">1.&lt;/span>.&lt;span style="color:#099">5&lt;/span>){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> delay(&lt;span style="color:#099">1000&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> chanel.send(i)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> viewModelScope.launch {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">for&lt;/span> (i &lt;span style="color:#000;font-weight:bold">in&lt;/span> chanel){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#d14">&amp;#34;Handle &lt;/span>&lt;span style="color:#d14">${i}&lt;/span>&lt;span style="color:#d14">&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>当然，这只是最简单的用法，还可以加入更多的生产者，或者不再需要数据时取消，甚至还有专门的&lt;code>product&lt;/code>构造器，直接获得返回多个值的协程对象。&lt;/p>
&lt;h1 id="总结">总结&lt;/h1>
&lt;p>Kotlin协程有很多有用的API，这些API覆盖了大部分异步使用的场景。所以在使用协程的时候，我们首先需要明确使用场景，再根据使用场景确定使用哪一套API，这可以使我们避免陷入API恐惧症。为此，我根据这两篇文章的内容，整理出了一份情景表格，实际开发中可以参照使用。
Kotlin协程构造器&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>API&lt;/th>
&lt;th>使用场景&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>launch&lt;/td>
&lt;td>执行耗时操作，不需要返回值&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>async&lt;/td>
&lt;td>需要获取耗时操作的单个返回值&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>produce&lt;/td>
&lt;td>需要获取耗时操作的多个返回值&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>Kotlin协程协同工具&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>API&lt;/th>
&lt;th>使用场景&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Flow&lt;/td>
&lt;td>操作异步数据流&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Channel&lt;/td>
&lt;td>协程间通信&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>青山不改，绿水长流，咱们下期见！&lt;/p></description></item><item><title>用纯HTML，JS，CSS实现横向滚动标签页</title><link>https://hongui.github.io/post/Kotlin%E5%8D%8F%E7%A8%8B-%E4%BB%8E%E7%90%86%E8%AE%BA%E5%88%B0%E5%AE%9E%E6%88%98.html</link><pubDate>Sat, 27 Mar 2021 19:02:30 +0800</pubDate><guid>https://hongui.github.io/post/Kotlin%E5%8D%8F%E7%A8%8B-%E4%BB%8E%E7%90%86%E8%AE%BA%E5%88%B0%E5%AE%9E%E6%88%98.html</guid><description>&lt;blockquote>
&lt;p>上一篇文章从理论上对Kotlin协程进行了部分说明，本文将在上一篇的基础上，从实战出发，继续协程之旅。&lt;/p>
&lt;/blockquote>
&lt;h1 id="从源头说起">从源头说起&lt;/h1>
&lt;p>在Kotlin中，要想使用协程，首先需要使用协程创建器创建，但还有个前提——协程作用域(&lt;code>CoroutineScope&lt;/code>)。在早期的Kotlin实现中，协程创建器是一等函数，也就是说我们随时随地可以通过协程创建器创建协程。但在协程正式发布以后，协程创建器需要在协程作用域对象上才能创建了，Kotlin添加了协程作用域来实现结构化并发。什么是结构化并发呢，通俗地说就是正确实施多个协程监控、管理的能力。在实际业务中，我们可能需要创建多个协程对象来完成不同的工作。为了对这些不相关的协程管理起来，Kotlin引入了协程作用域，通过某个协程作用域创建的协程都会被它管理着，在条件满足的时候，执行每个协程的取消工作或者结束自己。&lt;/p>
&lt;p>为了方便我们直接上手，官方提供了&lt;code>MainScope&lt;/code>和&lt;code>GlobalScope&lt;/code>供我们使用。正如名字那样，他们分别有不同的应用场景，前者比较适合用在UI相关的类中，而后者适用于在整个应用生命周期中都需要存活的类中。当然，对于Android开发者，其实我们有更好的选择——使用&lt;code>ViewModel&lt;/code>的Kotlin扩展，它不仅有着全部的协程作用域功能，开箱即用，而且还在&lt;code>onCleared&lt;/code>方法中实现了自动取消。&lt;/p>
&lt;h1 id="创建协程">创建协程&lt;/h1>
&lt;p>有了协程作用域，那我们来创建一个最简单的协程吧。&lt;/p>
&lt;div class="highlight">&lt;div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
&lt;table style="border-spacing:0;padding:0;margin:0;border:0;">&lt;tr>&lt;td style="vertical-align:top;padding:0;margin:0;border:0;">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>viewModelScope.launch{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#998;font-style:italic">//这里就是协程代码啦啦啦啦
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#998;font-style:italic">&lt;/span> delay(&lt;span style="color:#099">2000&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#000;font-weight:bold">out&lt;/span>.println(&lt;span style="color:#d14">&amp;#34;Hello World&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;code>launch&lt;/code>创建并启动了一个协程，协程启动两秒后，在控制抬打印了Hello World，然后协程就结束了（协程是有完整生命周期的）。这个协程完成的工作有限，我们可以使用线程完成相同的功能:&lt;/p>
&lt;div class="highlight">&lt;div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
&lt;table style="border-spacing:0;padding:0;margin:0;border:0;">&lt;tr>&lt;td style="vertical-align:top;padding:0;margin:0;border:0;">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>thread {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Thread.sleep(&lt;span style="color:#099">2000&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#000;font-weight:bold">out&lt;/span>.println(&lt;span style="color:#d14">&amp;#34;Hello World&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>我们可以看到，除去构建函数，两段代码唯一的区别就是延迟函数——&lt;code>delay&lt;/code>和&lt;code>Thread.sleep&lt;/code>.从功能上看他们都是让后面的代码延迟执行，但是效果却是不一样的，前者不会阻塞线程。这段代码其实是放在主线程里面执行的，但是它不会影响到UI的绘制，而后者假如把它放在主线程执行的话，应用会出现两秒的无响应。Kotlin把这种不会阻塞当前线程执行的函数称之为挂起函数，挂起函数可以在挂起点断开与当前线程的联系，让线程空闲下来完成其他的操作，当条件满足后，挂起函数重新在挂起点恢复，接着往下执行后面的代码。&lt;/p>
&lt;p>还有个小问题没有解决，在上一篇文章中，我曾经说过，挂起函数只能在挂起函数中执行，既然&lt;code>delay&lt;/code>是挂起函数，那么反推，我们的代码块也应该是个挂起函数，而这个挂起函数就是所谓的协程体。&lt;/p>
&lt;h1 id="让协程跨线程工作">让协程跨线程工作&lt;/h1>
&lt;p>如果你看到上面的代码，然后转手在协程体里面写个网络请求的话，你会发现，你的应用崩溃了，这是怎么回事呢？因为协程虽然不会阻塞主线程，但是主线程是不允许进行网络请求的。如果这时你就急着下了协程没啥用的结论，那么你就肤浅了。让我们稍微改一改上面的代码，让它运行在子线程吧。&lt;/p>
&lt;div class="highlight">&lt;div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
&lt;table style="border-spacing:0;padding:0;margin:0;border:0;">&lt;tr>&lt;td style="vertical-align:top;padding:0;margin:0;border:0;">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>viewModelScope.launch (Dispatchers.IO){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#998;font-style:italic">//这里就是协程代码啦啦啦啦
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#998;font-style:italic">&lt;/span> delay(&lt;span style="color:#099">2000&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#000;font-weight:bold">out&lt;/span>.println(&lt;span style="color:#d14">&amp;#34;Hello World&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>很好，现在协程体里面的网络请求可以顺利执行了，但是很快有读者就会发现新问题了——我怎么把网络请求的结果传回主线程呢，难不成还搞个&lt;code>Handler&lt;/code>,那和直接使用线程有什么区别，辣鸡协程。嘿，别急，这个协程其实也为客官处理好了。让我们再次改造一下代码：&lt;/p>
&lt;div class="highlight">&lt;div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
&lt;table style="border-spacing:0;padding:0;margin:0;border:0;">&lt;tr>&lt;td style="vertical-align:top;padding:0;margin:0;border:0;">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">5
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">6
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">7
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">8
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>viewModelScope.launch (Dispatchers.IO){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#998;font-style:italic">//这里就是协程代码啦啦啦啦，这里是在子线程执行的代码哦
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#998;font-style:italic">&lt;/span> &lt;span style="color:#998;font-style:italic">//假装这个是网络请求吧
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#998;font-style:italic">&lt;/span> delay(&lt;span style="color:#099">2000&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> withContext(Dispatchers.Main) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#998;font-style:italic">//哦豁豁，这里竟然运行在主线程哦
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#998;font-style:italic">&lt;/span> System.&lt;span style="color:#000;font-weight:bold">out&lt;/span>.println(&lt;span style="color:#d14">&amp;#34;Hello World&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>很好，我们可以愉快地使用协程处理网络请求了，那么这些魔法是怎么发生的呢，停下脚步，我们来重新审视一下上面的代码。&lt;/p>
&lt;p>首先，相比于最开始的代码，我们的代码里多了两个对象，一个方法调用。首先我们来看那两个对象，从名字中我们不难猜到它就是调度线程的。
Kotlin提供了四个常用的实现&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>Default&lt;/code>,它是标准协程构建者默认使用的调度器，使用共享的线程池工作，适用于计算型的任务；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>Main&lt;/code>,它是代表UI线程的调度器，通常来说只有一个线程，使用这个调度器就可以直接在协程中操作UI;&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>Unconfined&lt;/code>,它没有限定线程范围，它在哪个线程中被调用就会在哪个线程里执行完初始的代码，直到遇到挂起函数，随后它会使用挂起函数指定的调度器恢复，这个过程可以一直持续下去。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>IO&lt;/code>,是用来承载阻塞的IO操作的，如文件读写，网络连接等，是我们比较常用的调度器。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>所以那两个调度器对象是让协程切换工作环境的魔法。接下来还有一个方法调用没有解释。&lt;code>withContext&lt;/code>的作用是将当前的协程调度器切换到指定的调度器上，用这个调度器接着执行构建块中的代码。同时它也是一个挂起函数。提到挂起函数，我们就该想到，它是可恢复的。所以当这个挂起函数的代码块执行完成之后，它会自动恢复成原来的调度器，接着往下执行。&lt;/p>
&lt;h1 id="用协程串联两个异步操作">用协程串联两个异步操作&lt;/h1>
&lt;p>在项目开发中，还有一种常见的应用场景，客户端需要先请求一些配置信息，然后利用配置信息再请求真正的内容信息。这个过程描述起来是串行的，但是代码写起来却是割裂的，需要在第一个网络请求的回调中处理和发起第二个请求，然后在第二个回调中获取真正需要展示的数据，可能这个过程还会加个存库，或者触发另外请求的工作，那么完了，这代码没法看了。这放在以前，这种情况通常会使用RxJava，但是RxJava的代码可读性也还是差点意思。那么Kotlin协程可以写成什么样呢？&lt;/p>
&lt;div class="highlight">&lt;div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
&lt;table style="border-spacing:0;padding:0;margin:0;border:0;">&lt;tr>&lt;td style="vertical-align:top;padding:0;margin:0;border:0;">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">5
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">6
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">7
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">8
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>viewModelScope.launch(Dispatchers.IO) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">val&lt;/span> retrofit=Retrofit.Builder().build()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">val&lt;/span> apiUser=retrofit.create(APIUser&lt;span style="color:#000;font-weight:bold">::&lt;/span>&lt;span style="color:#000;font-weight:bold">class&lt;/span>.java)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">val&lt;/span> user=api.current()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">val&lt;/span> detail=api.userDetail(user.id)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> withContext(Dispatchers.Main) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> userLiveData.&lt;span style="color:#000;font-weight:bold">value&lt;/span>=detail
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这和我们写一般的同步代码一摸一样，没有回调，也不需要付出其他代价，这个过程甚至可以一直加下去。其实我觉得这个才是协程的真正威力。&lt;/p>
&lt;h1 id="让多个协程一起工作">让多个协程一起工作&lt;/h1>
&lt;p>我们继续复杂化使用场景——我在做一个多端使用的笔记App，现在用户打开了某一个已存在的笔记，为了让用户能快速浏览到上一次的操作信息，一方面我需要从文件中读取上一次操作的结果，另一方面我要拉取远程的操作结果，然后对两个结果合并，决定最终的展示数据。考虑到这两个操作其实是并行的，上面我们让协程串联起来的思路已经不适用了，因为协程里面的操作都是串行的。既然一个协程解决不了，我们再加一个协程可不可以呢？看着好像是可以，但是，协程操作的结果我们怎么获取到呢？查阅API，我找到了另一个协程构建器&lt;code>async&lt;/code>。它会返回一个协程对象，然后通过&lt;code>await&lt;/code>方法获取到协程的计算结果。思路来了，我们马上动手&lt;/p>
&lt;div class="highlight">&lt;div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
&lt;table style="border-spacing:0;padding:0;margin:0;border:0;">&lt;tr>&lt;td style="vertical-align:top;padding:0;margin:0;border:0;">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">13
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">14
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">15
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">val&lt;/span> fileResult=viewModelScope.async(Dispatchers.IO) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#998;font-style:italic">//假装是读文件的代码吧
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#998;font-style:italic">&lt;/span> &lt;span style="color:#099">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">val&lt;/span> networkResult=viewModelScope.async(Dispatchers.IO) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#998;font-style:italic">//也是假装是网络请求的代码
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#998;font-style:italic">&lt;/span> &lt;span style="color:#099">2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">val&lt;/span> fResult=fileResult.await()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">val&lt;/span> rResult=networkResult.await()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">val&lt;/span> result=&lt;span style="color:#000;font-weight:bold">if&lt;/span>(fResult&amp;gt;rResult){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fResult
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}&lt;span style="color:#000;font-weight:bold">else&lt;/span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> networkResult
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>然后你就会发现报错了，&lt;code>await&lt;/code>是挂起函数。看来两个协程还完成不了，要三个，所以，让我们创建第三个协程吧&lt;/p>
&lt;div class="highlight">&lt;div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
&lt;table style="border-spacing:0;padding:0;margin:0;border:0;">&lt;tr>&lt;td style="vertical-align:top;padding:0;margin:0;border:0;">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#998;font-style:italic">//前面的两个协程不变
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#998;font-style:italic">&lt;/span> viewModelScope.launch {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">val&lt;/span> fResult=fileResult.await()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">val&lt;/span> rResult=networkResult.await()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">val&lt;/span> result=&lt;span style="color:#000;font-weight:bold">if&lt;/span>(fResult&amp;gt;rResult){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fResult
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }&lt;span style="color:#000;font-weight:bold">else&lt;/span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> networkResult
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这就是协程间通信的基本写法啦，从这个基础之上，甚至还能衍生出更复杂的版本，但是万变不离其宗，都可以参考这种思路完成。&lt;/p>
&lt;h1 id="协程的取消">协程的取消&lt;/h1>
&lt;p>正如之前提到的一样，协程有着类似于线程的完整生命周期，包括创建，激活，完成中（取消中），已完成（已取消），刚才我们的示例都是正常状态，协程完成工作后会自动结束，但协程的另一条取消流程我们还没有提到。协程有自己的取消API——&lt;code>cancel&lt;/code>可供使用，我们只需要保存好协程创建者返回的协程对象就行了。当然更常见的还是文章开篇提到的使用协程作用域取消。这个操作会取消所有的协程。&lt;/p>
&lt;h1 id="总结">总结&lt;/h1>
&lt;p>本篇文章从协程创建开始，讲到了怎样用协程写出异步代码，怎么让多个协程共同工作，虽然覆盖了很大一部分使用场景，但是依然还有遗漏。由于篇幅限制，遗漏部分将在下一篇博文中继续讲解，希望大家持续关注。&lt;/p>
&lt;p>青山不改，绿水长流，咱们下期见！&lt;/p></description></item><item><title>Kotlin协程-那些理不清乱不明的关系</title><link>https://hongui.github.io/post/Kotlin%E5%8D%8F%E7%A8%8B-%E9%82%A3%E4%BA%9B%E7%90%86%E4%B8%8D%E6%B8%85%E4%B9%B1%E4%B8%8D%E6%98%8E%E7%9A%84%E5%85%B3%E7%B3%BB.html</link><pubDate>Fri, 26 Mar 2021 18:50:29 +0800</pubDate><guid>https://hongui.github.io/post/Kotlin%E5%8D%8F%E7%A8%8B-%E9%82%A3%E4%BA%9B%E7%90%86%E4%B8%8D%E6%B8%85%E4%B9%B1%E4%B8%8D%E6%98%8E%E7%9A%84%E5%85%B3%E7%B3%BB.html</guid><description>&lt;blockquote>
&lt;p>Kotlin的协程自推出以来，受到了越来越多Android开发者的追捧。另一方面由于它庞大的API，也将相当一部分开发者拒之门外。本篇试图从协程的几个重要概念入手，在复杂API中还原出它本来的面目，以全新的角度带读者走进Kotlin协程世界。&lt;/p>
&lt;/blockquote>
&lt;h1 id="什么是协程">什么是协程&lt;/h1>
&lt;p>在很多有关协程的文章中，描述协程通常会用这样的一句描述——协程比线程更加轻量，是可取消的。这句话没有错，这两个都是协程的优点，但是并不是特点，它并没有解释协程是什么。那么什么是协程的特点呢，我觉得可以先用线程做个类比，&lt;em>&lt;strong>解释一个概念最好的办法就是类比。&lt;/strong>&lt;/em> 我不打算使用科学严谨的描述，我想给线程一个我自己的定义——线程是一个可供CPU调度的执行单元，它有自己的执行块，可以独立地执行逻辑。我特意将线程的三个关键特征列举出来了：&lt;/p>
&lt;ul>
&lt;li>线程由CPU调度&lt;/li>
&lt;li>线程拥有自己的代码块&lt;/li>
&lt;li>代码块需要才能调度执行&lt;/li>
&lt;/ul>
&lt;p>这是我对线程的直观感受，并且这些特点是能从代码上体现出来的。如Java中的&lt;code>Thread&lt;/code>，它是线程的同时，也是一个实体对象，能通过API来认识它，使用它。而它的特别之处就是我上面列举的三点，这些都是线程特有的。我试着用相同的思路来给协程下一个自己的定义——协程是由线程调度执行的执行单元，它也有自己的执行块，可以独立或者协同执行逻辑。其实Kotlin中的协程也有自己对应实体和操作API，甚至和线程的还很像(如生命周期），但是由于Kotlin对协程的封装过于彻底，很多API没有暴露出来，以至于我对协程的认识一直处于盲人摸象的状态。另外，其实协程是有多种实现方式的，以下我的观点仅针对Kotlin的协程实现，可能与其他语言的实现不一致。&lt;/p>
&lt;p>&lt;em>&lt;strong>Kotlin中的协程对象本质上来讲就是个可执行的代码块，&lt;/strong>&lt;/em> 执行的代码就是创建协程传递进去的。除此之外它还有个最大的特点——协程是不和线程绑定的。它可以在某个时刻断开当前的线程，然后在其他时候，附着到其他线程上。也就是说，它像一个乒乓球，线程就好比是球拍，它可以在球拍间反复横跳。所以，结合这两个特点，官方给协程的定义是 &lt;em>&lt;strong>一个可挂起的计算实体&lt;/strong>&lt;/em>。我觉得这个定义不算精确，它只体现了挂起这个概念，没有体现恢复的概念。我给它一个我自己的定义——&lt;em>&lt;strong>一个可被调度的计算实体&lt;/strong>&lt;/em>。&lt;/p>
&lt;h1 id="协程中几个关键概念">协程中几个关键概念&lt;/h1>
&lt;p>明白了协程是什么还不够，因为Kotlin的协程还涉及到很多方面，有几个关键概念需要理解。&lt;/p>
&lt;h2 id="挂起函数">挂起函数&lt;/h2>
&lt;p>提到Kotlin的协程就不得不提到挂起函数，这是Kotlin协程实现的最重要的概念之一。简单来说，&lt;em>&lt;strong>挂起函数是一种异步实现方案，它是一个普通函数的前提下，还具备挂起和恢复的特性。&lt;/strong>&lt;/em> 它是解决耗时计算和结果传递的一种方案。那么它和我们常见的基于回调的方案相比，有什么不同呢。在基于回调的方案中，计算过程和结果没有关系，结果需要通过另一个对象，在计算完成后由计算过程手动传递，而这一过程是可能被反复嵌套的，从而导致，一些本该是串行化的代码，被割裂成几个部分，分散到不同的代码块中。如以下读写文件的代码&lt;/p>
&lt;div class="highlight">&lt;div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
&lt;table style="border-spacing:0;padding:0;margin:0;border:0;">&lt;tr>&lt;td style="vertical-align:top;padding:0;margin:0;border:0;">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">13
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">14
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">15
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">16
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#998;font-style:italic">// asynchronously read into `buf`, and when done run the lambda
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#998;font-style:italic">&lt;/span> inChannel.read(buf) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#998;font-style:italic">// this lambda is executed when the reading completes
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#998;font-style:italic">&lt;/span> bytesRead &lt;span style="color:#000;font-weight:bold">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">..&lt;/span>.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">..&lt;/span>.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> process(buf, bytesRead)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#998;font-style:italic">// asynchronously write from `buf`, and when done run the lambda
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#998;font-style:italic">&lt;/span> outChannel.write(buf) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#998;font-style:italic">// this lambda is executed when the writing completes
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#998;font-style:italic">&lt;/span> &lt;span style="color:#000;font-weight:bold">..&lt;/span>.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">..&lt;/span>.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> outFile.close()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>同样的逻辑，将&lt;code>read&lt;/code>和&lt;code>write&lt;/code>实现为挂起函数后，能写成什么样呢？&lt;/p>
&lt;div class="highlight">&lt;div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
&lt;table style="border-spacing:0;padding:0;margin:0;border:0;">&lt;tr>&lt;td style="vertical-align:top;padding:0;margin:0;border:0;">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">13
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">14
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span> launch {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#998;font-style:italic">// suspend while asynchronously reading
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#998;font-style:italic">&lt;/span> &lt;span style="color:#000;font-weight:bold">val&lt;/span> bytesRead = inChannel.aRead(buf)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#998;font-style:italic">// we only get to this line when reading completes
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#998;font-style:italic">&lt;/span> &lt;span style="color:#000;font-weight:bold">..&lt;/span>.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">..&lt;/span>.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> process(buf, bytesRead)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#998;font-style:italic">// suspend while asynchronously writing
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#998;font-style:italic">&lt;/span> outChannel.aWrite(buf)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#998;font-style:italic">// we only get to this line when writing completes
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#998;font-style:italic">&lt;/span> &lt;span style="color:#000;font-weight:bold">..&lt;/span>.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">..&lt;/span>.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> outFile.close()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这是Kotlin官方给的一个例子，可以看出挂起函数的实现非常符合直觉，是和思考过程保持一致的，同时还减少了大量的嵌套。&lt;/p>
&lt;p>为了更好地解释挂起函数，我还需要引入了一个新的概念——挂起点。
挂起点是一个分界点，代表着从这个时刻之后，执行过程可能会转移到其他地方执行，然后在某个时刻，再从这个点恢复，继续往下执行。这个过程中，当前线程不会被阻塞。所以 &lt;em>&lt;strong>挂起函数其实实现了异步非阻塞的通信模式。&lt;/strong>&lt;/em>&lt;/p>
&lt;p>一句话总结，挂起函数是一种不阻塞当前线程，并能返回异步计算结果的函数。&lt;/p>
&lt;h2 id="协程创建者">协程创建者&lt;/h2>
&lt;p>前面提到的挂起函数虽然好，但是有个限制，普通方法是不能调用挂起函数的，只能通过挂起函数调用。那么就出现了先有鸡还是先有蛋的问题。解决这个问题的方法就是协程创建者。&lt;code>launch&lt;/code>, &lt;code>future&lt;/code>, &lt;code>sequence&lt;/code>都是协程创建者。顾名思义，协程创建者是用来创建协程对象的，除此之外和普通函数没有区别。它们就是通往协程世界和挂起函数的大门。在这个大门里，我们可以尽情地使用挂起函数，简化我们的计算过程。当然，这些都不是固定不变的，这些函数都有多个配置参数，其中最重要的就是&lt;code>CoroutineContext&lt;/code>。&lt;/p>
&lt;h2 id="coroutinecontext">&lt;code>CoroutineContext&lt;/code>&lt;/h2>
&lt;p>&lt;code>CoroutineContext&lt;/code>的作用是提供协程的各种配置信息，&lt;em>&lt;strong>本质上就是保存非重复元素的容器(Set)&lt;/strong>&lt;/em>，里面的元素可以根据Key获取到（如调度器），称之为元素（Element）。这里，我忍不住想把它的接口定义放出来，因为实在是太美了。&lt;/p>
&lt;div class="highlight">&lt;div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
&lt;table style="border-spacing:0;padding:0;margin:0;border:0;">&lt;tr>&lt;td style="vertical-align:top;padding:0;margin:0;border:0;">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">interface&lt;/span> &lt;span style="color:#458;font-weight:bold">CoroutineContext&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">operator&lt;/span> &lt;span style="color:#000;font-weight:bold">fun&lt;/span> &amp;lt;&lt;span style="color:#458;font-weight:bold">E&lt;/span> : &lt;span style="color:#458;font-weight:bold">Element&lt;/span>&amp;gt; &lt;span style="color:#900;font-weight:bold">get&lt;/span>(key: Key&amp;lt;E&amp;gt;): E?
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">fun&lt;/span> &amp;lt;&lt;span style="color:#458;font-weight:bold">R&lt;/span>&amp;gt; &lt;span style="color:#900;font-weight:bold">fold&lt;/span>(initial: R, operation: (R, Element) &lt;span style="color:#000;font-weight:bold">-&amp;gt;&lt;/span> R): R
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">operator&lt;/span> &lt;span style="color:#000;font-weight:bold">fun&lt;/span> &lt;span style="color:#900;font-weight:bold">plus&lt;/span>(context: CoroutineContext): CoroutineContext
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">fun&lt;/span> &lt;span style="color:#900;font-weight:bold">minusKey&lt;/span>(key: Key&amp;lt;*&amp;gt;): CoroutineContext
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">interface&lt;/span> &lt;span style="color:#458;font-weight:bold">Element&lt;/span> : CoroutineContext {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">val&lt;/span> key: Key&amp;lt;*&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">interface&lt;/span> &lt;span style="color:#458;font-weight:bold">Key&lt;/span>&amp;lt;E : Element&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>以上就是Kotlin中对&lt;code>CoroutineContext&lt;/code>的定义，这些API每个都有其巧妙的用途，让人叹服&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>get&lt;/code>目的是根据Key获取对应的对象，这个方法的奇特之处就是查询参数。利用这个方法在执行某个操作之前判断&lt;code>CoroutineContext&lt;/code>是否有某个配置对象，从而实现一种权限认证。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>fold&lt;/code>其实就是一种迭代算法，可以对全部元素进行检查。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>plus&lt;/code>这就很有意思了，它可以让两个对象合并起来，并且当&lt;code>key&lt;/code>相同时使用右侧的对象覆盖左侧的对象。这在我们的协程使用中绝对是最灵活的API了。我们可以使用+替换调原本的调度器，使用我们给定的调度器，而且看起来是那么自然。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>minusKey&lt;/code>返回不包含指定&lt;code>key&lt;/code>的&lt;code>context&lt;/code>，相当于一种取反操作，这在某些情境下非常有用。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>我觉得这应该算得上是对抽象的极致体现了，这个接口用简单的API抽象了增删改查四个操作，并且保留了强大的扩展性。在最开始接触协程的时候，我常常对协程复杂的工作机制和简单的参数配置产生了深深的怀疑，直到我看到了这个定义，我才明白它真正的强大之处，它不仅可以用系统默认的工作配置完成工作，还允许用户实现自己的&lt;code>CoroutineContext&lt;/code>来随时替换掉默认配置，完成自己定制化的任务。&lt;/p>
&lt;h2 id="continuation">&lt;code>Continuation&lt;/code>&lt;/h2>
&lt;p>&lt;code>Continuation&lt;/code>不是Kotlin特有的概念，它在维基上的解释是一种控制状态的抽象表示。而在Kotlin中，它是对协程在挂起点的一个状态抽象，这可能不太好理解，我们可以通过具体的API来将这个概念具体化。&lt;/p>
&lt;div class="highlight">&lt;div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
&lt;table style="border-spacing:0;padding:0;margin:0;border:0;">&lt;tr>&lt;td style="vertical-align:top;padding:0;margin:0;border:0;">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">interface&lt;/span> &lt;span style="color:#458;font-weight:bold">Continuation&lt;/span>&amp;lt;&lt;span style="color:#000;font-weight:bold">in&lt;/span> T&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">val&lt;/span> context: CoroutineContext
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">fun&lt;/span> &lt;span style="color:#900;font-weight:bold">resumeWith&lt;/span>(result: Result&amp;lt;T&amp;gt;)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>它有个关键的函数——resumeWith，它表示在挂起状态之后的某个时刻，通过这个状态对象从原来的位置恢复过来。这是挂起函数实现的关键。而这里面的控制状态就是由参数体现了，成功或者失败，所以它还有两个扩展方法：&lt;/p>
&lt;div class="highlight">&lt;div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
&lt;table style="border-spacing:0;padding:0;margin:0;border:0;">&lt;tr>&lt;td style="vertical-align:top;padding:0;margin:0;border:0;">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">fun&lt;/span> &amp;lt;&lt;span style="color:#458;font-weight:bold">T&lt;/span>&amp;gt; &lt;span style="color:#900;font-weight:bold">Continuation&lt;/span>&amp;lt;T&amp;gt;.resume(&lt;span style="color:#000;font-weight:bold">value&lt;/span>: T)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">fun&lt;/span> &amp;lt;&lt;span style="color:#458;font-weight:bold">T&lt;/span>&amp;gt; &lt;span style="color:#900;font-weight:bold">Continuation&lt;/span>&amp;lt;T&amp;gt;.resumeWithException(exception: Throwable)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h1 id="总结">总结&lt;/h1>
&lt;p>协程是一个可被调度的计算实体，可通过协程创建者创建，在协程的代码块里可以使用挂起函数，它能必要的时候挂起，然后在条件满足后恢复，完成异步代码的串行化编程。&lt;/p>
&lt;p>以上就是理解协程的关键概念，在实际使用协程的过程中可能用不到很多，但是却会对我们理解其运作过程很有帮助，也是写出标准协程代码的关键。Kotlin协程并没有很多黑魔法，只是为了适用多种不同的使用场景，有了庞大的API，本篇文章就是对这些API的一个概括解释，后面将会针对各种场景再进行详细梳理，希望大家喜欢。&lt;/p>
&lt;p>青山不改，绿水长流，咱们下期见！&lt;/p></description></item><item><title>沉思篇-剖析Jetpack的ViewModel</title><link>https://hongui.github.io/post/%E6%B2%89%E6%80%9D%E7%AF%87-%E5%89%96%E6%9E%90Jetpack%E7%9A%84LiveData.html</link><pubDate>Wed, 24 Mar 2021 18:18:30 +0800</pubDate><guid>https://hongui.github.io/post/%E6%B2%89%E6%80%9D%E7%AF%87-%E5%89%96%E6%9E%90Jetpack%E7%9A%84LiveData.html</guid><description>&lt;blockquote>
&lt;p>ViewModel做为架构组件的三元老之一，是实现MVVM的有力武器。&lt;/p>
&lt;/blockquote>
&lt;h1 id="viewmodel的设计目标">ViewModel的设计目标&lt;/h1>
&lt;p>ViewModel的基本功能就是管理UI的数据。其实，从职责上来说，这又是对Activity和Fragment的一次功能拆分。以前存储在它们内部的数据，需要它们自己处理创建，更新，存储，恢复的所有过程，同时它们还要处理UI的数据绑定，更新，动画等操作。职责的多元化就容易出现不好定位和调试的问题。另外，Activity和Fragment作为UI的承载者，很多时候需要共享数据和复用功能。而UI的差异让复用的粒度划分很难把控，容易写出扩展性差的代码。基于这些痛点，ViewModel被设计出来了。
同时ViewModel还将保存数据的功能强化了——它将设备配置变更后数据保存和恢复自动化了，在UI生命周期内都能保证数据的有效性，这大大减少了样板代码的编写，提高了开发效率。&lt;/p>
&lt;h1 id="viewmodel的架构设计">ViewModel的架构设计&lt;/h1>
&lt;p>*** ViewModel用了两种粒度划分来完成数据管理功能。*** 第一层是对ViewModel自身存储数据的管理。目标就是完成ViewModel的创建，对应的抽象实体是&lt;code>ViewModelProvider.Factory&lt;/code>。第二层则是对已存在的ViewModel组的管理，目标就是保证意外情况下ViewModel的有效性，对应的抽象实体是ViewModelStore。当然，这些都只是概念上的抽象，还需要一个粘合剂把它们的抽象层级体现出来，这就是ViewModelProvider。这三个主体类共同搭建了ViewModel的体系框架。剩下的类都是对这三个概念的补充和完善。接下来我将分别以这些抽象为主线，逐层分析它们的实现逻辑。&lt;/p>
&lt;h1 id="viewmodel的组管理">ViewModel的组管理&lt;/h1>
&lt;p>前面也提到过，ViewModelStore是完成组管理的，那么我们首先应该确定的是组的概念,也就是这些ViewModel都归属于谁的问题。这不难理解，要管理组，那就必须得找到组的主人啊，由此引申出了ViewModelStoreOwner，它代表着某个拥有组管理权限的对象，通过它提供的ViewModelStore对象就能对里面的ViewModel进行管理了，同时这些ViewModel也就共同形成了组。所以ViewModelStoreOwner其实就是组的抽象实体，它代表着某个组，也是管理分组的单位。
ViewModel有两个默认实现的组——ComponentActivity和Fragment。也就是说ComponentActivity和Fragment都实现了ViewModelStoreOwner这个接口。
先来看ComponentActivity的实现。根据接口，首先查看接口方法&lt;code>getViewModelStore&lt;/code>的实现。里面主要涉及到两个对象，一个就是ViewModelStore的引用&lt;code>mViewModelStore&lt;/code>，另一个就很有意思了，它是一个NonConfigurationInstances对象，这是一个简单类，就是保存ViewModelStore对象的。那么它特殊在什么地方呢？它是&lt;code>onRetainNonConfigurationInstance&lt;/code>方法的返回对象。&lt;/p>
&lt;blockquote>
&lt;p>插一个课外知识科普，&lt;code>onRetainNonConfigurationInstance&lt;/code>是Activity的一个方法，这个方法是设备配置发生变化（如横竖屏切换的时候）时被系统自动调用的，用于用户保存数据。只要这个方法返回的对象，在设备配置放生改变时都不会被销毁。稍后在重建完成后，可以通过&lt;code>getLastNonConfigurationInstance&lt;/code>方法获取到。&lt;/p>
&lt;/blockquote>
&lt;p>接着回到&lt;code>getViewModelStore&lt;/code>的实现，刚才说到NonConfigurationInstances对象，它是通过调用&lt;code>getLastNonConfigurationInstance&lt;/code>方法获得的。如果方法返回了有效的对象，说明Activity被重建了，就直接获取保存在NonConfigurationInstances对象中的值，然后更新&lt;code>mViewModelStore&lt;/code>。否则就说明还没有有效的ViewModelStore对象，则直接创建。从这个逻辑不难看出，我们的ViewModel不会随着设备变化而重建，这正好满足了我们的设计目标。那么对于Fragment，它的实现又是怎样的呢。
Fragment的实现比较曲折，它直接委托给了FragmentManager,又委托给了FragmentManagerViewModel的&lt;code>getViewModelStore&lt;/code>方法，方法实现也很简单，就是对&lt;code>HashMap&lt;/code>查找，没有就创建新的。这显然不是我们想看到的，因为这里并没有和Activity类似的处理状态变更的逻辑。那么唯一的突破点就是那个HashMap对象了。搜索一圈发现，它会作为getSnapshot方法的返回值返回，有点Activity那味了。往上回溯，会发现它最终就是作为不销毁的对象，在Fragment销毁前保存下来了。
以上就是两种应用场景下ViewModelStore的创建逻辑，另外，还有清除逻辑没有讲到。这个逻辑本质上就是调用ViewModelStore的clear方法，唯一的问题就是确定调用时机。具体来说就是，Activity通过注册&lt;code>Lifecycle&lt;/code>的状态监听，在&lt;code>Lifecycle.Event.ON_DESTROY&lt;/code>的时候，调用了&lt;code>clear&lt;/code>方法,而Fragment则是继续通过FragmentManager的&lt;code>desctory&lt;/code>方法作为调用的入口点。在FragmentManagerViewModel里完成了方法调用。
总结一下，ViewModelStoreOwner是对ViewModel组的一种抽象。虽然对应着两个不同的实现，但是殊途同归，&lt;em>&lt;strong>最终的目的就是保证在设备配置发生变化的时候对应ViewModelStore对象的有效性，&lt;/strong>&lt;/em> 从而保证ViewModel对象的有效性。同时在真正需要销毁的时候做好清理工作。这就是这ViewModel的组管理功能。&lt;/p>
&lt;h1 id="viewmodel的创建管理">ViewModel的创建管理&lt;/h1>
&lt;p>ViewModel用&lt;code>ViewModelProvider.Factory&lt;/code>来管理创建过程。具体来说就是怎样根据一个ViewModel子类的类信息创建对应的对象。这有两个难点——必要的依赖注入、数据的恢复。对于依赖注入，ViewModel还是耍了老把戏，和创建ViewModelStore类似，提供了&lt;code>HasDefaultViewModelProviderFactory&lt;/code>的一个抽象，把依赖注入转移到了ComponentActivity和Fragment中。之所以这么做，是因为在创建ViewModel的过程中，可能需要使用到Application和Bundle等信息，而这些信息是只能在在Activity和Fragment中才能获取到的。数据恢复则是关注怎样利用现有的数据将对象恢复到原来的状态。当然这些过程其实都可以没有，不需要传递Application或者Bundle对象，不需要恢复ViewModel状态，则库提供了默认的实现。就是简单的调用反射创建对象而已。
针对刚才说的各种情况，&lt;code>ViewModelProvider.Factory&lt;/code>有多个实现，那么实际上它到底是使用哪个实现呢，我们得从ViewModelProvider中寻找答案。在它的构造方法里，会对ViewModelStoreOwner做类型判断，假如它是&lt;code>HasDefaultViewModelProviderFactory&lt;/code>的实例，则使用实例返回的对象，否则默认的实现。结合上面的分析，让我们继续到ComponentActivity和Fragment中寻找答案。不看不知道，一看吓一跳，它们竟然都是使用了SavedStateViewModelFactory类，那么我们一起来看看它是怎么实现的吧。
在构建SavedStateViewModelFactory对象的时候，会传入三个对象——Application,SavedStateRegistryOwner,Bundle,这三个对象中最重要的就是第二个，它的主要功能就是提供在SavedStateRegistry对象，这个对象会在合适的时候保存数据，然后在合适的时候再恢复过来。它也是生命周期感知的组件。在它的&lt;code>create&lt;/code>方法里，也是通过反射构建ViewModel对象的，唯一的不同就是反射多了个参数。接着往下看，最终会利用这些信息构造出SavedStateHandle对象，这个对象就是真正对我们当前创建的ViewModel对象有用的信息。SavedStateHandle提供了根据键值对保存数据的方法，也提供了查询方法，所以ViewModel可以根据这个对象，恢复自己的LiveData数据，最重要的，这个类还提供了LiveData的另一个子类SavingStateLiveData，能自动处理数据保存的问题。
一句话总结，ComponentActivity和Fragment会使用SavedStateViewModelFactory对象作为ViewModelProvider中的&lt;code>Factory&lt;/code>来创建ViewModel。只要ViewModel提供了带有Application或者SavedStateHandle的构造方法，就能享受从Bundle中恢复数据的便利。&lt;/p>
&lt;h1 id="viewmodel的粘合剂viewmodelprovider">ViewModel的粘合剂ViewModelProvider&lt;/h1>
&lt;p>为什么说ViewModelProvider是粘合剂呢？因为这个类就做了一件事，把ViewModelStore和&lt;code>ViewModelProvider.Factory&lt;/code>组合起来，实现了一个叫get的方法，这个方法的内部实现就是有两个步骤。&lt;/p>
&lt;ol>
&lt;li>
&lt;p>调用ViewModelStore的&lt;code>get&lt;/code>方法查询是否有创建好的对象，如果有就返回，方法结束，否则进入步骤2。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>调用&lt;code>ViewModelProvider.Factory&lt;/code>的&lt;code>create&lt;/code>方法创建对象，并将之保存到ViewModelStore中。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>所以当我们要使用ViewModel的时候，通常是创建ViewModelProvider对象，然后调用&lt;code>get&lt;/code>方法获取真正的ViewModel对象，这样，我们的对象就具备了正确处理设备配置变更的能力。&lt;/p>
&lt;h1 id="viewmodel的fragment间通信功能">ViewModel的Fragment间通信功能&lt;/h1>
&lt;p>根据前面的梳理，我们知道，ViewModelStore是管理某个ViewModel组的，只要我们保证ViewModelStore存在，我们就可以保证ViewModel存活。再反推一步，要保证ViewModelStore存活，我们就要保证ViewModelStoreOwner在不同的地方都能返回同一个ViewModelStore对象，而ComponentActivity和Fragment是都实现了这个接口的。结合Activity的生命周期通常是大于Fragment这一事实，不难得出结论——&lt;em>&lt;strong>在某个Fragment里面，用Activity对象创建ViewModelProvider对象，就能保证获取到和Activity一样的ViewModelStore对象，也就能保证获取到相同的ViewModel对象。只要Activity没有销毁，该Activity下的所有Fragment都能获取到相同的ViewModel对象，然后通过更改状态能方式完成通信。&lt;/strong>&lt;/em>&lt;/p>
&lt;p>到此，对ViewModel的分析告一段落了，对创建过程的两次抽象是我觉得最精彩的环节，另外对现有条件（Activity和Fragment的生命周期）的利用也是它独到之处，真的是受益匪浅。青山不改，绿水长流，咱们下期见！
&lt;img src="https://hongui.github.io/post/viewmodel.webp"
width="1080"
height="515"
srcset="https://hongui.github.io/post/viewmodel_hu1a3d262f0baed64d23f8cbca65f2577a_23416_480x0_resize_q75_h2_box_2.webp 480w, https://hongui.github.io/post/viewmodel_hu1a3d262f0baed64d23f8cbca65f2577a_23416_1024x0_resize_q75_h2_box_2.webp 1024w"
loading="lazy"
alt="viewmodel"
class="gallery-image"
data-flex-grow="209"
data-flex-basis="503px"
>&lt;/p></description></item><item><title>沉思篇-剖析Jetpack的LiveData</title><link>https://hongui.github.io/post/%E6%B2%89%E6%80%9D%E7%AF%87-%E5%89%96%E6%9E%90Jetpack%E7%9A%84LiveData.html</link><pubDate>Tue, 23 Mar 2021 18:14:09 +0800</pubDate><guid>https://hongui.github.io/post/%E6%B2%89%E6%80%9D%E7%AF%87-%E5%89%96%E6%9E%90Jetpack%E7%9A%84LiveData.html</guid><description>&lt;blockquote>
&lt;p>上一篇我们讲到了架构组件中的Lifecycle，由于缺少具体的运用，可能缺少直观的感受，今天我们就用Lifecycle实战一回，看看Lifecycle是怎样运用到LiveData中的。&lt;/p>
&lt;/blockquote>
&lt;h1 id="livedata的功能">LiveData的功能&lt;/h1>
&lt;p>根据&lt;code>LiveData&lt;/code>的类注释，我们可以知道，&lt;code>LiveData&lt;/code>是一个实现了观察者模式的数据容器，并且是可感知生命周期的。由这个功能描述，我们就能知道&lt;code>LiveData&lt;/code>是由两部分功能合并而来的，一部分是数据容器，一部分是响应生命周期。在阅读源码的时候，我觉得功能拆解是个很有用的手段，合理的功能拆解，就是有目的的省略，有助于快速理清功能实现逻辑。
接下来，我将以这两个功能为突破点，逐一梳理&lt;code>LiveData&lt;/code>的实现思路。&lt;/p>
&lt;h2 id="livedata的数据容器功能">LiveData的数据容器功能&lt;/h2>
&lt;p>数据容器的概念相信大家不会陌生，几乎每种语言都会有他们的身影，开发者用它们来保存数据对象。由于应用场景的不同，出现了各种各样的数据容器，如&lt;code>List&lt;/code>,&lt;code>Set&lt;/code>这些是保存数据集的，&lt;code>ThreadLocal&lt;/code>是保存线程私有数据的。那么&lt;code>LiveData&lt;/code>是保存什么数据的呢，它是保存可观察数据的。
对于数据容器的拆解，其实是有固定的模式可寻的，就是以添加数据为突破口，然后以数据流向为主线，逐步击破。所以我们就从&lt;code>LiveData&lt;/code>添加数据的方法&lt;code>setValue&lt;/code>开始分析。&lt;/p>
&lt;ol>
&lt;li>&lt;code>setValue&lt;/code>方法的逻辑很少，主要就是两个，增加mVersion的版本，保存数据，然后就是调用&lt;code>dispatchingValue&lt;/code>进行分发了。&lt;code>mVersion&lt;/code>是个关键点，后面还会讲到，这里主要是混个脸熟。我们先进入到下一步。&lt;/li>
&lt;li>&lt;code>dispatchingValue&lt;/code>的功能很清楚，从名字上就能看出来，就是分发数据的。但是它的实现却是很巧妙的。为了阐述这个实现，我们需要一个合适的场景。假设当前&lt;code>LiveData&lt;/code>保存的数据变动频繁，并且观察对象很多的情况，我们怎样快速，准确地把数据传递给观察者呢？或者换种说法，当我们正在分发数据的时候，又有新数据来了怎么办？通常来说有两种方案，掐头去尾。掐头就是在数据更新的时候不管新数据，先把分发操作执行完之后再处理新数据。去尾就是新数据来了，取消上一次数据分发，重新分发新数据。&lt;code>LiveData&lt;/code>采用的是去尾的方式。明白了这点，再看&lt;code>dispatchingValue&lt;/code>就很清晰了，它用&lt;code>mDispatchingValue&lt;/code>标识分发状态，用&lt;code>mDispatchInvalidated&lt;/code>来标识新数据状态，然后在使用&lt;code>for&lt;/code>循环分发数据的时候检测&lt;code>mDispatchInvalidated&lt;/code>的状态是不是更新了，由此确定是不是需要取消此次分发，进行新一轮的分发。其他的就没有更多奥秘可言了。&lt;/li>
&lt;li>&lt;code>considerNotify&lt;/code>是分发给具体的观察者之后的处理逻辑。这一步就是在步骤2中的&lt;code>for&lt;/code>循环里完成的。所以这里就是数据的最后一站了。这个方法需要根据观察者的两个状态来确定是不是要通知。一个就是步骤1中提到的&lt;code>mVersion&lt;/code>，因为观察者也有一份自己的&lt;code>mLastVersion&lt;/code>,假如&lt;code>mVersion&lt;/code>比&lt;code>mLastVersion&lt;/code>小的话就没必要通知了，因为每次通知之后，它两的值是一样的。另一个就是和生命周期扯上关系的&lt;code>mActive&lt;/code>了。这个状态标示着当前的观察者是否处于激活状态。假如不是，则直接返回了。搞了这两个判断之后就是简单的更新&lt;code>mLastVersion&lt;/code>和执行&lt;code>onChanged&lt;/code>回调了。
以上三步就是&lt;code>LiveData&lt;/code>的数据更新过程，重点在于处理分发这个步骤上，在以后的项目中，我们可以借鉴这种思想，当然具体问题是需要具体分析的。
在上面的步骤3中我们知道了观察者的&lt;code>mActive&lt;/code>是决定&lt;code>LiveData&lt;/code>响应生命周期的关键，那么接下来我们来看看这个状态是怎么更新的吧。&lt;/li>
&lt;/ol>
&lt;h2 id="livedata的生命周期感知">LiveData的生命周期感知&lt;/h2>
&lt;p>联系上一篇文章沉思篇-剖析JetPack的&lt;code>Lifecycle&lt;/code>,我们知道&lt;code>Lifecycle&lt;/code>是专业干介个的（生命周期感知）。同时文章也提到了&lt;code>Lifecycle&lt;/code>三个很重要的抽象，&lt;code>LifecycleOwner&lt;/code>，&lt;code>Lifecycle&lt;/code>，&lt;code>LifecycleObserver&lt;/code>，这是引入生命周期感知三个很好的突破口。&lt;/p>
&lt;ul>
&lt;li>&lt;code>LifecycleOwner&lt;/code>作为生命周期的动力源，是直接可以获得Lifecycle的，继而可以方便地读取状态和注册状态监听，由于出色的接口封装，不需要和其他类产生耦合，是个很好的引入对象。&lt;/li>
&lt;li>&lt;code>Lifecycle&lt;/code>作为&lt;code>Lifecycle&lt;/code>的核心类，它完成了很多功能，是抽象类，只能继承使用。&lt;/li>
&lt;li>&lt;code>LifecycleObserver&lt;/code>，作为状态更新通知的最后一环，可以很方便地完成状态监听，但是需要注册到合适的&lt;code>Lifecycle&lt;/code>上。&lt;/li>
&lt;/ul>
&lt;p>所以很显然，&lt;code>LiveData&lt;/code>使用&lt;code>Lifecycle&lt;/code>需要搞一个&lt;code>LifecycleOwner&lt;/code>，用于引入生命周期的状态，还需要搞一个&lt;code>LifecycleObserver&lt;/code>，用于响应状态更新。另外，由于我们是数据容器的定位，我们的数据是很可能供给给很多类使用的，所以假如将&lt;code>LifecycleOwner&lt;/code>和&lt;code>LiveData&lt;/code>绑定的话，一旦某个操作致使&lt;code>LiveData&lt;/code>失活，其他所有的观察者就一摸黑了，啥也收不到了，这是有悖设计的。基于这个原因，&lt;code>LifecycleOwner&lt;/code>只能和&lt;code>Observer&lt;/code>绑定。结果就显而易见了，他们同时出现在了&lt;code>observe&lt;/code>方法里，这也就解释了&lt;code>observe&lt;/code>方法为啥需要两个参数。
很明显&lt;code>observe&lt;/code>就是分析生命周期感知的突破口，我们再接再励，看看他们是怎么合力工作的。&lt;/p>
&lt;p>在&lt;code>observe&lt;/code>内部，&lt;code>LifecycleOwner&lt;/code>和&lt;code>Observer&lt;/code>同时被&lt;code>LifecycleBoundObserver&lt;/code>接收，用于构造对象了，逻辑继续转到&lt;code>LifecycleBoundObserver&lt;/code>中.&lt;/p>
&lt;p>注意到&lt;code>LifecycleBoundObserver&lt;/code>是实现了&lt;code>LifecycleEventObserver&lt;/code>,并且继承自&lt;code>ObserverWrapper&lt;/code>。&lt;code>ObserverWrapper&lt;/code>不熟悉我们先放一边，上一篇中我们知道了&lt;code>LifecycleEventObserver&lt;/code>是继承自&lt;code>LifecycleObserver&lt;/code>的，它只有一个状态变更的回调。很显然，我们下一步就是去看看它是怎样处理状态变更的。&lt;/p>
&lt;p>来到&lt;code>onStateChanged&lt;/code>方法，里面做了两件事，而且是互斥的，这就是说，其实它在某种条件下干一件事，其他条件干另一个事。先看简单的一件事，它在&lt;code>Lifecycle&lt;/code>状态是&lt;code>DESTROYED``的时候移除了&lt;/code>Observer&lt;code>，没有更多了。那么另一件事其实我们也能猜到了，就是状态不为&lt;/code>DESTROYED&lt;code>的时候怎么搞。它委托给了父类&lt;/code>ObserverWrapper`搞。&lt;/p>
&lt;p>逻辑来到&lt;code>ObserverWrapper&lt;/code>的&lt;code>activeStateChanged&lt;/code>方法里，里面就是对&lt;code>LiveData&lt;/code>的状态进行设置而已，也就是根据现在是不是激活状态更新&lt;code>mActiveCount&lt;/code>的值，并且在适当的条件下通知&lt;code>LiveData&lt;/code>进入激活状态或者失活状态。另外就是上面我们心心念念的&lt;code>mActive&lt;/code>了，这就接上了。当然，还有个极为关键的点，在激活状态下，会以自身为参数，进行一次数据数据，在某种情况下，这可能会引入数据问题。&lt;/p>
&lt;p>到这里，&lt;code>LiveData&lt;/code>的生命周期感知就看完了.一句话就能总结，&lt;code>Lifecycle&lt;/code>让&lt;code>LiveData&lt;/code>有了在激活状态下分发数据，在失活后自动取消监听的能力。&lt;/p>
&lt;p>补充说明
虽然前面讲了那么多，还有一些内容是没有讲到的，比如数据的异步更新，&lt;code>Observer&lt;/code>的注册过程，等等，但是已经不妨碍我们理解主流程了。为了加深印象，我还整理一个UML图，可以对照着图再次理解，回顾。
&lt;img src="https://hongui.github.io/post/livedata.webp"
width="898"
height="996"
srcset="https://hongui.github.io/post/livedata_hu5fe1c56aabf5e1118826b0d70e18969c_22476_480x0_resize_q75_h2_box_2.webp 480w, https://hongui.github.io/post/livedata_hu5fe1c56aabf5e1118826b0d70e18969c_22476_1024x0_resize_q75_h2_box_2.webp 1024w"
loading="lazy"
alt="livedata UML"
class="gallery-image"
data-flex-grow="90"
data-flex-basis="216px"
>&lt;/p></description></item><item><title>沉思篇-剖析JetPack的Lifecycle</title><link>https://hongui.github.io/post/%E6%B2%89%E6%80%9D%E7%AF%87-%E5%89%96%E6%9E%90JetPack%E7%9A%84Lifecycle.html</link><pubDate>Sun, 21 Mar 2021 15:56:53 +0800</pubDate><guid>https://hongui.github.io/post/%E6%B2%89%E6%80%9D%E7%AF%87-%E5%89%96%E6%9E%90JetPack%E7%9A%84Lifecycle.html</guid><description>&lt;blockquote>
&lt;p>这几年，对于Android开发者来说，最时髦的技术当属Jetpack了。谷歌官方从19年开始，就在极力推动Jetpack的使用，经过这几年的发展，Jetpack也基本完成了当时的设计目标——简单，一致，专注。而使得这一切成为可能的基石，我觉得当属架构组件了。最初架构组件作为单独的库和support库并没有太多联系，随着Jetpack的成型，给架构组件也注入了新的活力。在Jetpack库中，建构组件的使用随处可见，扮演着越来越重要的角色。今天，我就以作为架构组件基石的Lifecycle开始，尝试对架构组件进行剖析，向大家展示谷歌开发者是怎样设计一个高内聚，低耦合的库的。&lt;/p>
&lt;/blockquote>
&lt;h1 id="前言">前言&lt;/h1>
&lt;p>要说阅读源码，我觉得和把大象装进冰箱的操作是一样的，就是再大的事，得分步骤。阅读源码的第一步就是站在库开发者的角度，提炼出库需要完成的功能。明确了功能，才能针对功能进行代码设计，这也是我们阅读源码的第二步，理清实现逻辑。我们可以通过画UML图的方式帮助理解。通常来说画完UML图，源码的理解也就七七八八了。这时我们就可以走到第三步，品读实现细节。有了前两步的基础，我们就可以针对性地选取一些感兴趣的内容研读实现了，而且可以做到收放自如，指哪打哪。
那我们开始吧！&lt;/p>
&lt;h1 id="lifecycle的源码思路">Lifecycle的源码思路&lt;/h1>
&lt;p>明确Lifecycle的设计目标
一句话概括，Lifecycle就是完成了生命周期感知的任务。生命周期感知是什么意思呢，就是一个类可以不依赖Activity或者Fragment的回调，正确处理状态更新的问题。那么我们为什么需要这样的一个类呢，这和我们直接在回调方法里面写逻辑有什么差别吗？为了回答这个问题，我们来设想一下这样一个场景：一个Activity需要获取用户实时的位置信息，同时需要使用相机，以往我们的做法是在Activity的某些回调里面设置位置，相机的监听及解监听。如果这时，Activity再加入其他的一些逻辑，它的代码就可能膨胀到不能忍受的地步，并且随着业务的增长，后续Activity的膨胀是不可预期的，这样是不利于调试和测试的，而且，从设计上来说，这样的设计也是脆弱的，耦合太紧了。但是我们的这些组件确确实实是需要响应生命周期回调的啊，那么怎样才能做到既能感知生命周期，又能降低耦合呢。计算机科学告诉我们这样一条真理，当找不到其他方法时，可以考虑加一层抽象。由此，Lifecycle诞生了。这就是Lifecycle的目标，很纯粹，就是生命周期感知，就是把专业的事情交给专业的去做。&lt;/p>
&lt;h1 id="lifecycle的工作流程">Lifecycle的工作流程&lt;/h1>
&lt;p>概括来说，Lifecycle就是完成了状态监听和状态分发的两个功能。为了完成这两个功能，Lifecycle抽象出了三个概念，也可以说是三个流程吧。&lt;/p>
&lt;ol>
&lt;li>拥有生命周期的对象，称为LifecycleOwner，这其实只是一个接口，只要能提供Lifecycle的都可以称为LifecycleOwner，这个类主要的功能就是提供原始的生命周期事件，供后续的操作提供数据，这是第一步——状态感知；&lt;/li>
&lt;li>拥有生命周期状态，称为Lifecycle，这个类主要的功能就是提供状态抽象和提供状态信息，这是第二步——状态更新；&lt;/li>
&lt;li>对生命周期状态感兴趣的观察者，称为LifecycleObserver，这个类主要的功能就是对状态信息进行响应，这是第三步——状态响应。&lt;/li>
&lt;/ol>
&lt;p>流程很简单，看着也很清晰的，就是观察者模式。但是Lifecycle库为了完成更好的解耦和提供更多的扩展，在这三个环节上衍生出了更多的类，这也是我以Lifecycle为剖析对象的原因。我觉得一个好的库，不仅仅要能够完成库的设计目标，同时还应该保持尽可能的扩展性和可读性。在这点上，Lifecycle无疑是我们很好的榜样。接下来，我们就一起以这三个阶段为主线，逐一剖析Lifecycle是怎样完成抽象，设计，及实现的。&lt;/p>
&lt;h2 id="lifecycle的状态感知">Lifecycle的状态感知&lt;/h2>
&lt;p>传统的状态感知就是重写Activity和Fragment的生命周期回调，在回调里面进行状态更新。这其实也是Lifecycle实现的基本思路，只是它将这些个回调抽象为了一个个的事件。那么怎么将生命周期转化为一个个事件呢？Lifecycle用了一个巧妙的方法，自定义了一个ReportFragment。ReportFragment作用很明确，就是监听生命周期，生成状态事件。
&lt;img src="https://hongui.github.io/post/reportfragment.webp"
width="749"
height="658"
srcset="https://hongui.github.io/post/reportfragment_hu8dc71e5f17ce61b71ba2cd161ed127f1_37502_480x0_resize_q75_h2_box_2.webp 480w, https://hongui.github.io/post/reportfragment_hu8dc71e5f17ce61b71ba2cd161ed127f1_37502_1024x0_resize_q75_h2_box_2.webp 1024w"
loading="lazy"
alt="ReportFragment接口列表"
class="gallery-image"
data-flex-grow="113"
data-flex-basis="273px"
>
如图所示，本质上ReportFragment还是监听了Activity的生命周期，绑定关系就发生在injectIfNeededIn方法中。然后为了将监听到的状态传递出去给其他类使用，ReportFragment借助了dispatch方法。这里有个很巧妙的设计细节，dispatch并没有直接引用自己的组件，而是使用了Activity，但是为什么还是能将事件发送出去呢？因为这里面使用了动态类型判断及转换的操作，最终，转换成了分发器LifecycleRegistry来完成事件分发操作。从而顺利讲逻辑转到了第二阶段，状态更新。&lt;/p>
&lt;h2 id="lifecycle的状态更新">Lifecycle的状态更新&lt;/h2>
&lt;p>状态更新主要的逻辑还是放在了LifecycleRegistry类里，这个类是继承了Lifecycle的。
&lt;img src="https://hongui.github.io/post/lifecycleregistry.webp"
width="749"
height="833"
srcset="https://hongui.github.io/post/lifecycleregistry_hu9aa9a9c3b2b7f005ae4b2391a8f56d06_50360_480x0_resize_q75_h2_box_2.webp 480w, https://hongui.github.io/post/lifecycleregistry_hu9aa9a9c3b2b7f005ae4b2391a8f56d06_50360_1024x0_resize_q75_h2_box_2.webp 1024w"
loading="lazy"
alt="LifecycleRegistry接口列表"
class="gallery-image"
data-flex-grow="89"
data-flex-basis="215px"
>
如图所示，这个类作为Lifecycle的子类完成了被观察对象的两个功能，接收和管理观察对象。其次作为核心类它又完成了状态更新的功能。事件在这里被转化为状态，保存了下来，然后通知给自己的观察者。从类缩略图中，我们也可以看出这些方法就是为了完成这两大功能而设计的。知道了这些，状态更新的步骤也就了解了。那么顺理成章的，我们马上进入第三个步骤。&lt;/p>
&lt;h2 id="lifecycle的状态响应">Lifecycle的状态响应&lt;/h2>
&lt;p>LifecycleObserver是个空接口，那么状态更新怎么做呢？这就还得从LifecycleRegistry开始看起。LifecycleRegistry在添加LifecycleObserver的时候做了包装，于是LifecycleObserver变成了多种LifecycleObserver的子类，在不同的子类里面其实都直接或者间接地继承自LifecycleEventObserver。所以最终状态是通过LifecycleEventObserver的onStateChanged方法通知给观察者的。但是我们很快发现不对劲，官方Demo是直接实现LifecycleObserver，并且只需要用注解对感兴趣的状态注册就可以了。这里完全没有体现哇。按照刚才的思路，我们还是从添加LifecycleObserver的方法开始，LifecycleObserver被包装成ObserverWithState对象，而在构造方法里面委托给了Lifecycling，所以最终的秘密藏在Lifecycling。Lifecycling里面对多种LifecycleObserver进行了处理，其中就包括了我们熟悉的注解的方式。所以，总结来看，我们通过注解定义LifecycleObserver观察者后，注册到LifecycleRegistry就会被包装成新的观察者对象。然后，在状态更新的时候，用过注解找到合适的方法来通知观察者。到这里其实整个Lifecycle的工作流程已经理清了，我根据这些整理出了一份UML图。
&lt;img src="https://hongui.github.io/post/lifecycle.png"
width="641"
height="712"
srcset="https://hongui.github.io/post/lifecycle_hu356aac92caa3fec0cee3418a7186b738_43477_480x0_resize_box_3.png 480w, https://hongui.github.io/post/lifecycle_hu356aac92caa3fec0cee3418a7186b738_43477_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="Lifecycle UML图"
class="gallery-image"
data-flex-grow="90"
data-flex-basis="216px"
>
由UML图，我们可以直观地得出一句话的结论，LifecycleRegistry使用LifecycleOwner提供的Lifecycle，使用观察者的模式把状态传递给了LifecycleEventObserver，这就是我最开始说的三个抽象之间的联系。&lt;/p>
&lt;h1 id="品读实现细节">品读实现细节&lt;/h1>
&lt;p>经过多次的品读，我发现了Lifecycle的多个小细节值得我们细细品味，其一就是Lifecycle强大的抽象。Lifecycle使用了LifecycleOwner抽象了生命周期这个概念，生命周期不一定是和Activity绑定的，用户可以自己定义自己的LifecycleOwner，定制满足自己业务需求的Lifecycle。其次LifecycleRegistry是一个很好的高内聚，低耦合的实现典范——LifecycleRegistry依赖的都是LifecycleOwner和LifecycleObserver这样的顶层接口，遵循了依赖倒置原则、LifecycleRegistry内部对LifecycleObserver的包装又委托给了Lifecycling，遵循了单一职责原则，就连LifecycleRegistry的方法都是严格遵守单一职责原则的，不得不叹服开发者对代码强大的掌控力。
当然，还有其他也很不错的实现细节，我没有一一展开，因为代码是读不完的，我们抓住我们感兴趣的就行了，有些细节就是用来忽略的，我们不得不承认这个事实。&lt;/p>
&lt;p>青山不改，绿水长流，咱们下期见！&lt;/p></description></item></channel></rss>