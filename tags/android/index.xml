<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Android on 低头沉思</title><link>https://deep-thinking.top/tags/android/</link><description>Recent content in Android on 低头沉思</description><generator>Hugo</generator><language>zh-CN</language><lastBuildDate>Tue, 09 May 2023 22:14:38 +0800</lastBuildDate><atom:link href="https://deep-thinking.top/tags/android/index.xml" rel="self" type="application/rss+xml"/><item><title>Android-OpenGLES学习-画个颜色</title><link>https://deep-thinking.top/posts/learning-opengles-on-the-android-fill-the-window/</link><pubDate>Tue, 09 May 2023 22:14:38 +0800</pubDate><guid>https://deep-thinking.top/posts/learning-opengles-on-the-android-fill-the-window/</guid><description>&lt;blockquote>
&lt;p>我们知道屏幕显示出内容是靠一个一个发光的RGB灯珠，而决定灯珠亮度的是一块内存区域，通过往这一块内存区域写入数据，我们就能在屏幕上观察到数据显示效果。这是个复杂又灵活的工作，为了方便完成这项工作，先驱们制定出了OpenGL标准，我们的故事也将从这里开始。&lt;/p>
&lt;/blockquote>
&lt;h3 id="opengl-es" class="relative group">OpenGL ES &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#opengl-es" aria-label="">#&lt;/a>&lt;/span>&lt;/h3>&lt;p>OpenGL ES是OpenGL的精简版本，Android平台从发行伊始就提供了OpenGL ES的支持，只是不同的版本，支持的OpenGL ES版本不同，目前主流的版本还是2.0和3.0。OpenGL ES是一组API，为开发者提供配置数据，传输数据，绘制内容的能力。它的工作是和绘制严格相关的，所以光是OpenGL ES不会造成很大的理解障碍，问题出在配置OpenGL ES的配置环境上。为什么要将OpenGL ES API和配置环境分开呢，因为OpenGL ES是跨平台的API，但是实际运行的时候需要和特定平台绑定，如Android。平台间准备OpenGL ES环境所需要的条件不同，为了保证OpenGL ES的跨平台能力，就需要将配置环境单独拿出来和特定平台绑定。在Android上这个配置环境就是EGL。明确OpenGL ES API和配置OpenGL ES环境的区别不仅对理解这两个关键概念有很大帮助，更是对后期调试代码，排错帮助极大。&lt;/p>
&lt;h3 id="工作流程" class="relative group">工作流程 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e5%b7%a5%e4%bd%9c%e6%b5%81%e7%a8%8b" aria-label="">#&lt;/a>&lt;/span>&lt;/h3>&lt;p>明确了一些基本概念之后，我们接下来最重要的任务是理清OpenGL ES的工作流程。很多教程一上来就列举一大堆名词或者直接上实例，我觉得是不妥的。只有熟悉了工作流程，我们在写代码的时候才能做到心中有数，才能在排错过程中更快更准确地定位问题。&lt;/p>
&lt;h4 id="准备环境" class="relative group">准备环境 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e5%87%86%e5%a4%87%e7%8e%af%e5%a2%83" aria-label="">#&lt;/a>&lt;/span>&lt;/h4>&lt;p>OpenGL ES是由一系列API组成的，但是不代表可以在任何时机下调用这些API，而是需要运行环境进行一些设置，这就是准备环境。准备环境通常是做一些显存分配，窗口配置的工作，很繁琐却必不可少。&lt;/p></description></item><item><title>Android-NDK开发——基本概念</title><link>https://deep-thinking.top/posts/a-introduction-to-android-ndk-basic-concept/</link><pubDate>Sun, 06 Mar 2022 11:30:40 +0800</pubDate><guid>https://deep-thinking.top/posts/a-introduction-to-android-ndk-basic-concept/</guid><description>&lt;p>在Android开发中,有时候出于安全，性能，代码共用的考虑，需要使用C/C++编写的库。虽然在现代化工具链的支持下，这个工作的难度已经大大降低，但是毕竟万事开头难，初学者往往还是会遇到很多不可预测的问题。本篇就是基于此背景下写的一份简陋指南，希望能对刚开始编写C/C++库的读者有所帮助。同时为了尽可能减少认知断层，本篇将试着从一个最简单的功能开始，逐步添加工具链，直到实现最终功能，真正做到知其然且之所以然。&lt;/p></description></item><item><title>Android-JNI开发概论</title><link>https://deep-thinking.top/posts/a-introduction-to-android-jni/</link><pubDate>Sun, 12 Sep 2021 21:34:45 +0800</pubDate><guid>https://deep-thinking.top/posts/a-introduction-to-android-jni/</guid><description>&lt;h3 id="什么是jni开发" class="relative group">什么是JNI开发 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e4%bb%80%e4%b9%88%e6%98%afjni%e5%bc%80%e5%8f%91" aria-label="">#&lt;/a>&lt;/span>&lt;/h3>&lt;p>JNI的全称是Java Native Interface，顾名思义，这是一种解决Java和C/C++相互调用的编程方式。&lt;em>&lt;strong>它其实只解决两个方面的问题，怎么找到和怎么访问。&lt;/strong>&lt;/em> 弄清楚这两个话题，我们就学会了JNI开发。&lt;em>&lt;strong>需要注意的是，JNI开发只涉及到一小部分C/C++开发知识，遇到问题的时候我们首先要判断是C/C++的问题还是JNI的问题，这可以节省很多搜索和定位的时间。&lt;/strong>&lt;/em>&lt;/p></description></item><item><title>CMake个人理解和使用</title><link>https://deep-thinking.top/posts/personal-understanding-and-usage-of-cmake/</link><pubDate>Mon, 09 Aug 2021 19:21:49 +0800</pubDate><guid>https://deep-thinking.top/posts/personal-understanding-and-usage-of-cmake/</guid><description>&lt;h3 id="前言" class="relative group">前言 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e5%89%8d%e8%a8%80" aria-label="">#&lt;/a>&lt;/span>&lt;/h3>&lt;p>CMake是一个构建工具，通过它可以很容易创建跨平台的项目。通常使用它构建项目要分两步，通过源代码生成工程文件，通过工程文件构建目标产物（可能是动态库，静态库，也可能是可执行程序）。使用CMake的一个主要优势是在多平台或者多人协作的项目中，开发人员可以根据自己的喜好来使选择IDE，不用受其他人工程配置的影响，它有点像跨平台的IDE，通过它配置好相关设置之后，可以在多个平台无缝衔接，提高开发效率。&lt;/p></description></item><item><title>Kotlin协程-从一到多</title><link>https://deep-thinking.top/posts/a-introduction-to-kotlin-coroutine-from-zero-to-multiple/</link><pubDate>Tue, 30 Mar 2021 19:10:30 +0800</pubDate><guid>https://deep-thinking.top/posts/a-introduction-to-kotlin-coroutine-from-zero-to-multiple/</guid><description>&lt;blockquote>
&lt;p>上一篇文章，我介绍了Kotlin协程的创建，使用，协作等内容。本篇将引入更多的使用场景，继续带你走进协程世界。&lt;/p>
&lt;/blockquote>
&lt;h3 id="使用协程处理异步数据流" class="relative group">使用协程处理异步数据流 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e4%bd%bf%e7%94%a8%e5%8d%8f%e7%a8%8b%e5%a4%84%e7%90%86%e5%bc%82%e6%ad%a5%e6%95%b0%e6%8d%ae%e6%b5%81" aria-label="">#&lt;/a>&lt;/span>&lt;/h3>&lt;p>常用编程语言都会内置对同一类型不同对象的数据集表示，我们通常称之为容器类。不同的容器类适用于不同的使用场景。Kotlin的&lt;code>Flow&lt;/code>就是在异步计算的需求下引入的，用于表示异步的数据流。&lt;/p>
&lt;h4 id="flow" class="relative group">Flow &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#flow" aria-label="">#&lt;/a>&lt;/span>&lt;/h4>&lt;p>“问渠哪得清如许，为有源头活水来”，异步数据流的基本就是以某种方式获得异步数据。Kotlin提供了多种种方式，比较常用的就是Kotlin协程包的&lt;code>asFlow&lt;/code>扩展和&lt;code>flow&lt;/code>构造器。前者是对普通数据集的&lt;code>Flow&lt;/code>化封装，没有更多可言，我们着重来看后者。
&lt;code>flow&lt;/code>构造器的主要目标就是产生一个异步数据流，它是一个泛型函数，参数是一个挂起函数，并且是&lt;code>FlowCollector&lt;/code>是扩展函数。这个接口只有一个&lt;code>emit&lt;/code>方法，就是为创建的&lt;code>Flow&lt;/code>提供异步计算的数据的，因为它是挂起函数，所以我们能在里面使用其他挂起函数计算异步值，然后通过&lt;code>emit&lt;/code>方法将值发送出去，如此反复就能为下游操作提供源源不断的数据流了。
事情还没完，上面的步骤我们只是规定了创建数据的方式，并没有真正执行，也就是建好了道路，但是还没有车上路。那么，怎样才能让车在路上跑呢，查看&lt;code>Flow&lt;/code>的接口会发现，它提供了&lt;code>collect&lt;/code>方法来处理数据。&lt;code>collect&lt;/code>接收一个挂起函数作为处理逻辑，但是同时，&lt;code>collect&lt;/code>方法本身也是挂起函数，所以，这个方法只能在挂起函数中运行。有了这些知识，我们就可以写出最简单的异步数据流了。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl"> &lt;span class="m">1u&lt;/span>&lt;span class="n">spend&lt;/span> &lt;span class="k">fun&lt;/span> &lt;span class="nf">compute&lt;/span>&lt;span class="p">():&lt;/span>&lt;span class="n">Int&lt;/span>&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">delay&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="m">123&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="m">1024&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">viewModelScope&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">launch&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">val&lt;/span> &lt;span class="py">flow&lt;/span>&lt;span class="p">=&lt;/span>&lt;span class="n">flow&lt;/span>&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="n">Int&lt;/span>&lt;span class="p">&amp;gt;&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">emit&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="m">9527&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">emit&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">compute&lt;/span>&lt;span class="p">())&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">delay&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="m">256&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">emit&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="m">256&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">flow&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">collect&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">it&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在&lt;code>flow&lt;/code>构造器里面随意做各种操作，只要在必要的时候传递结果就行了，但是需要注意的是，&lt;code>emit&lt;/code>方法只能运行在同一个协程里。乍一看，这样分开写和写在一起并没有本质上的差别，但&lt;code>Flow&lt;/code>还能做到更多。&lt;/p>
&lt;h3 id="该给flow换个工作环境了" class="relative group">该给Flow换个工作环境了 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e8%af%a5%e7%bb%99flow%e6%8d%a2%e4%b8%aa%e5%b7%a5%e4%bd%9c%e7%8e%af%e5%a2%83%e4%ba%86" aria-label="">#&lt;/a>&lt;/span>&lt;/h3>&lt;p>上一节，我们那个简单的示例，假如把构造器里面的数据获取方法换成网络请求，应用就歇菜了。因为它们都是运行在主线程里面的。那么这个时候，看过上一篇文章的小伙伴马上就会反应过来，用&lt;code>withContext&lt;/code>方法在构造器里面切换线程就行了哇。思路是很对，因为&lt;code>Flow&lt;/code>的默认配置就是构造器和&lt;code>collect&lt;/code>方法工作在同一线程，既然现在主线程不让运行，那就把构造器的线程切换一下就行了呗。然后事实并不是这样，这样写出来的代码根本无法运行。因为官方提供了唯一的&lt;code>flowOn&lt;/code>方法来切换构造器的执行线程。使用也很简单，就是对创建好的&lt;code>Flow&lt;/code>对象配置一次&lt;code>flowOn&lt;/code>方法就行了。&lt;/p></description></item><item><title>Kotlin协程-从理论到实战</title><link>https://deep-thinking.top/posts/a-introduction-to-kotlin-coroutine-from-theory-to-practice/</link><pubDate>Sat, 27 Mar 2021 19:02:30 +0800</pubDate><guid>https://deep-thinking.top/posts/a-introduction-to-kotlin-coroutine-from-theory-to-practice/</guid><description>&lt;blockquote>
&lt;p>上一篇文章从理论上对Kotlin协程进行了部分说明，本文将在上一篇的基础上，从实战出发，继续协程之旅。&lt;/p>
&lt;/blockquote>
&lt;h3 id="从源头说起" class="relative group">从源头说起 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e4%bb%8e%e6%ba%90%e5%a4%b4%e8%af%b4%e8%b5%b7" aria-label="">#&lt;/a>&lt;/span>&lt;/h3>&lt;p>在Kotlin中，要想使用协程，首先需要使用协程创建器创建，但还有个前提——协程作用域(&lt;code>CoroutineScope&lt;/code>)。在早期的Kotlin实现中，协程创建器是一等函数，也就是说我们随时随地可以通过协程创建器创建协程。但在协程正式发布以后，协程创建器需要在协程作用域对象上才能创建了，Kotlin添加了协程作用域来实现结构化并发。什么是结构化并发呢，通俗地说就是正确实施多个协程监控、管理的能力。在实际业务中，我们可能需要创建多个协程对象来完成不同的工作。为了对这些不相关的协程管理起来，Kotlin引入了协程作用域，通过某个协程作用域创建的协程都会被它管理着，在条件满足的时候，执行每个协程的取消工作或者结束自己。&lt;/p>
&lt;p>为了方便我们直接上手，官方提供了&lt;code>MainScope&lt;/code>和&lt;code>GlobalScope&lt;/code>供我们使用。正如名字那样，他们分别有不同的应用场景，前者比较适合用在UI相关的类中，而后者适用于在整个应用生命周期中都需要存活的类中。当然，对于Android开发者，其实我们有更好的选择——使用&lt;code>ViewModel&lt;/code>的Kotlin扩展，它不仅有着全部的协程作用域功能，开箱即用，而且还在&lt;code>onCleared&lt;/code>方法中实现了自动取消。&lt;/p>
&lt;h3 id="创建协程" class="relative group">创建协程 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e5%88%9b%e5%bb%ba%e5%8d%8f%e7%a8%8b" aria-label="">#&lt;/a>&lt;/span>&lt;/h3>&lt;p>有了协程作用域，那我们来创建一个最简单的协程吧。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="n">viewModelScope&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">launch&lt;/span>&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//这里就是协程代码啦啦啦啦
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">delay&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="m">2000&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nc">System&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="k">out&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;Hello World&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>launch&lt;/code>创建并启动了一个协程，协程启动两秒后，在控制抬打印了Hello World，然后协程就结束了（协程是有完整生命周期的）。这个协程完成的工作有限，我们可以使用线程完成相同的功能:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="n">thread&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nc">Thread&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">sleep&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="m">2000&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nc">System&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="k">out&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;Hello World&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>我们可以看到，除去构建函数，两段代码唯一的区别就是延迟函数——&lt;code>delay&lt;/code>和&lt;code>Thread.sleep&lt;/code>.从功能上看他们都是让后面的代码延迟执行，但是效果却是不一样的，前者不会阻塞线程。这段代码其实是放在主线程里面执行的，但是它不会影响到UI的绘制，而后者假如把它放在主线程执行的话，应用会出现两秒的无响应。Kotlin把这种不会阻塞当前线程执行的函数称之为挂起函数，挂起函数可以在挂起点断开与当前线程的联系，让线程空闲下来完成其他的操作，当条件满足后，挂起函数重新在挂起点恢复，接着往下执行后面的代码。&lt;/p>
&lt;p>还有个小问题没有解决，在上一篇文章中，我曾经说过，挂起函数只能在挂起函数中执行，既然&lt;code>delay&lt;/code>是挂起函数，那么反推，我们的代码块也应该是个挂起函数，而这个挂起函数就是所谓的协程体。&lt;/p>
&lt;h3 id="让协程跨线程工作" class="relative group">让协程跨线程工作 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e8%ae%a9%e5%8d%8f%e7%a8%8b%e8%b7%a8%e7%ba%bf%e7%a8%8b%e5%b7%a5%e4%bd%9c" aria-label="">#&lt;/a>&lt;/span>&lt;/h3>&lt;p>如果你看到上面的代码，然后转手在协程体里面写个网络请求的话，你会发现，你的应用崩溃了，这是怎么回事呢？因为协程虽然不会阻塞主线程，但是主线程是不允许进行网络请求的。如果这时你就急着下了协程没啥用的结论，那么你就肤浅了。让我们稍微改一改上面的代码，让它运行在子线程吧。&lt;/p></description></item><item><title>Kotlin协程-那些理不清乱不明的关系</title><link>https://deep-thinking.top/posts/a-introduction-to-kotlin-coroutine-those-unclear-relationships/</link><pubDate>Fri, 26 Mar 2021 18:50:29 +0800</pubDate><guid>https://deep-thinking.top/posts/a-introduction-to-kotlin-coroutine-those-unclear-relationships/</guid><description>&lt;blockquote>
&lt;p>Kotlin的协程自推出以来，受到了越来越多Android开发者的追捧。另一方面由于它庞大的API，也将相当一部分开发者拒之门外。本篇试图从协程的几个重要概念入手，在复杂API中还原出它本来的面目，以全新的角度带读者走进Kotlin协程世界。&lt;/p>
&lt;/blockquote>
&lt;h3 id="什么是协程" class="relative group">什么是协程 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e4%bb%80%e4%b9%88%e6%98%af%e5%8d%8f%e7%a8%8b" aria-label="">#&lt;/a>&lt;/span>&lt;/h3>&lt;p>在很多有关协程的文章中，描述协程通常会用这样的一句描述——协程比线程更加轻量，是可取消的。这句话没有错，这两个都是协程的优点，但是并不是特点，它并没有解释协程是什么。那么什么是协程的特点呢，我觉得可以先用线程做个类比，&lt;em>&lt;strong>解释一个概念最好的办法就是类比。&lt;/strong>&lt;/em> 我不打算使用科学严谨的描述，我想给线程一个我自己的定义——线程是一个可供CPU调度的执行单元，它有自己的执行块，可以独立地执行逻辑。我特意将线程的三个关键特征列举出来了：&lt;/p>
&lt;ul>
&lt;li>线程由CPU调度&lt;/li>
&lt;li>线程拥有自己的代码块&lt;/li>
&lt;li>代码块需要才能调度执行&lt;/li>
&lt;/ul>
&lt;p>这是我对线程的直观感受，并且这些特点是能从代码上体现出来的。如Java中的&lt;code>Thread&lt;/code>，它是线程的同时，也是一个实体对象，能通过API来认识它，使用它。而它的特别之处就是我上面列举的三点，这些都是线程特有的。我试着用相同的思路来给协程下一个自己的定义——协程是由线程调度执行的执行单元，它也有自己的执行块，可以独立或者协同执行逻辑。其实Kotlin中的协程也有自己对应实体和操作API，甚至和线程的还很像(如生命周期），但是由于Kotlin对协程的封装过于彻底，很多API没有暴露出来，以至于我对协程的认识一直处于盲人摸象的状态。另外，其实协程是有多种实现方式的，以下我的观点仅针对Kotlin的协程实现，可能与其他语言的实现不一致。&lt;/p>
&lt;p>&lt;em>&lt;strong>Kotlin中的协程对象本质上来讲就是个可执行的代码块，&lt;/strong>&lt;/em> 执行的代码就是创建协程传递进去的。除此之外它还有个最大的特点——协程是不和线程绑定的。它可以在某个时刻断开当前的线程，然后在其他时候，附着到其他线程上。也就是说，它像一个乒乓球，线程就好比是球拍，它可以在球拍间反复横跳。所以，结合这两个特点，官方给协程的定义是 &lt;em>&lt;strong>一个可挂起的计算实体&lt;/strong>&lt;/em>。我觉得这个定义不算精确，它只体现了挂起这个概念，没有体现恢复的概念。我给它一个我自己的定义——&lt;em>&lt;strong>一个可被调度的计算实体&lt;/strong>&lt;/em>。&lt;/p>
&lt;h3 id="协程中几个关键概念" class="relative group">协程中几个关键概念 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e5%8d%8f%e7%a8%8b%e4%b8%ad%e5%87%a0%e4%b8%aa%e5%85%b3%e9%94%ae%e6%a6%82%e5%bf%b5" aria-label="">#&lt;/a>&lt;/span>&lt;/h3>&lt;p>明白了协程是什么还不够，因为Kotlin的协程还涉及到很多方面，有几个关键概念需要理解。&lt;/p>
&lt;h4 id="挂起函数" class="relative group">挂起函数 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e6%8c%82%e8%b5%b7%e5%87%bd%e6%95%b0" aria-label="">#&lt;/a>&lt;/span>&lt;/h4>&lt;p>提到Kotlin的协程就不得不提到挂起函数，这是Kotlin协程实现的最重要的概念之一。简单来说，&lt;em>&lt;strong>挂起函数是一种异步实现方案，它是一个普通函数的前提下，还具备挂起和恢复的特性。&lt;/strong>&lt;/em> 它是解决耗时计算和结果传递的一种方案。那么它和我们常见的基于回调的方案相比，有什么不同呢。在基于回调的方案中，计算过程和结果没有关系，结果需要通过另一个对象，在计算完成后由计算过程手动传递，而这一过程是可能被反复嵌套的，从而导致，一些本该是串行化的代码，被割裂成几个部分，分散到不同的代码块中。如以下读写文件的代码&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// asynchronously read into `buf`, and when done run the lambda
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">inChannel&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">read&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">buf&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// this lambda is executed when the reading completes
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">bytesRead&lt;/span> &lt;span class="o">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">..&lt;/span>&lt;span class="p">.&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">..&lt;/span>&lt;span class="p">.&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">process&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">buf&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">bytesRead&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// asynchronously write from `buf`, and when done run the lambda
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">outChannel&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">write&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">buf&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// this lambda is executed when the writing completes
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="o">..&lt;/span>&lt;span class="p">.&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">..&lt;/span>&lt;span class="p">.&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">outFile&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">close&lt;/span>&lt;span class="p">()&lt;/span> 
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>同样的逻辑，将&lt;code>read&lt;/code>和&lt;code>write&lt;/code>实现为挂起函数后，能写成什么样呢？&lt;/p></description></item><item><title>沉思篇-剖析Jetpack的ViewModel</title><link>https://deep-thinking.top/posts/%E6%B2%89%E6%80%9D%E7%AF%87-%E5%89%96%E6%9E%90jetpack%E7%9A%84viewmodel/</link><pubDate>Wed, 24 Mar 2021 18:18:30 +0800</pubDate><guid>https://deep-thinking.top/posts/%E6%B2%89%E6%80%9D%E7%AF%87-%E5%89%96%E6%9E%90jetpack%E7%9A%84viewmodel/</guid><description>&lt;blockquote>
&lt;p>ViewModel做为架构组件的三元老之一，是实现MVVM的有力武器。&lt;/p>
&lt;/blockquote>
&lt;h3 id="viewmodel的设计目标" class="relative group">ViewModel的设计目标 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#viewmodel%e7%9a%84%e8%ae%be%e8%ae%a1%e7%9b%ae%e6%a0%87" aria-label="">#&lt;/a>&lt;/span>&lt;/h3>&lt;p>ViewModel的基本功能就是管理UI的数据。其实，从职责上来说，这又是对Activity和Fragment的一次功能拆分。以前存储在它们内部的数据，需要它们自己处理创建，更新，存储，恢复的所有过程，同时它们还要处理UI的数据绑定，更新，动画等操作。职责的多元化就容易出现不好定位和调试的问题。另外，Activity和Fragment作为UI的承载者，很多时候需要共享数据和复用功能。而UI的差异让复用的粒度划分很难把控，容易写出扩展性差的代码。基于这些痛点，ViewModel被设计出来了。
同时ViewModel还将保存数据的功能强化了——它将设备配置变更后数据保存和恢复自动化了，在UI生命周期内都能保证数据的有效性，这大大减少了样板代码的编写，提高了开发效率。&lt;/p></description></item><item><title>沉思篇-剖析Jetpack的LiveData</title><link>https://deep-thinking.top/posts/%E6%B2%89%E6%80%9D%E7%AF%87-%E5%89%96%E6%9E%90jetpack%E7%9A%84livedata/</link><pubDate>Tue, 23 Mar 2021 18:14:09 +0800</pubDate><guid>https://deep-thinking.top/posts/%E6%B2%89%E6%80%9D%E7%AF%87-%E5%89%96%E6%9E%90jetpack%E7%9A%84livedata/</guid><description>&lt;blockquote>
&lt;p>上一篇我们讲到了架构组件中的Lifecycle，由于缺少具体的运用，可能缺少直观的感受，今天我们就用Lifecycle实战一回，看看Lifecycle是怎样运用到LiveData中的。&lt;/p>
&lt;/blockquote>
&lt;h3 id="livedata的功能" class="relative group">LiveData的功能 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#livedata%e7%9a%84%e5%8a%9f%e8%83%bd" aria-label="">#&lt;/a>&lt;/span>&lt;/h3>&lt;p>根据&lt;code>LiveData&lt;/code>的类注释，我们可以知道，&lt;code>LiveData&lt;/code>是一个实现了观察者模式的数据容器，并且是可感知生命周期的。由这个功能描述，我们就能知道&lt;code>LiveData&lt;/code>是由两部分功能合并而来的，一部分是数据容器，一部分是响应生命周期。在阅读源码的时候，我觉得功能拆解是个很有用的手段，合理的功能拆解，就是有目的的省略，有助于快速理清功能实现逻辑。
接下来，我将以这两个功能为突破点，逐一梳理&lt;code>LiveData&lt;/code>的实现思路。&lt;/p></description></item><item><title>沉思篇-剖析JetPack的Lifecycle</title><link>https://deep-thinking.top/posts/%E6%B2%89%E6%80%9D%E7%AF%87-%E5%89%96%E6%9E%90jetpack%E7%9A%84lifecycle/</link><pubDate>Sun, 21 Mar 2021 15:56:53 +0800</pubDate><guid>https://deep-thinking.top/posts/%E6%B2%89%E6%80%9D%E7%AF%87-%E5%89%96%E6%9E%90jetpack%E7%9A%84lifecycle/</guid><description>&lt;blockquote>
&lt;p>这几年，对于Android开发者来说，最时髦的技术当属Jetpack了。谷歌官方从19年开始，就在极力推动Jetpack的使用，经过这几年的发展，Jetpack也基本完成了当时的设计目标——简单，一致，专注。而使得这一切成为可能的基石，我觉得当属架构组件了。最初架构组件作为单独的库和support库并没有太多联系，随着Jetpack的成型，给架构组件也注入了新的活力。在Jetpack库中，建构组件的使用随处可见，扮演着越来越重要的角色。今天，我就以作为架构组件基石的Lifecycle开始，尝试对架构组件进行剖析，向大家展示谷歌开发者是怎样设计一个高内聚，低耦合的库的。&lt;/p>
&lt;/blockquote></description></item></channel></rss>