<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>源码剖析 on 低头沉思</title><link>https://bravebuffalo.cc/tags/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/</link><description>Recent content in 源码剖析 on 低头沉思</description><generator>Hugo</generator><language>zh-CN</language><lastBuildDate>Wed, 24 Mar 2021 18:18:30 +0800</lastBuildDate><atom:link href="https://bravebuffalo.cc/tags/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/index.xml" rel="self" type="application/rss+xml"/><item><title>沉思篇-剖析Jetpack的ViewModel</title><link>https://bravebuffalo.cc/post/%E6%B2%89%E6%80%9D%E7%AF%87-%E5%89%96%E6%9E%90Jetpack%E7%9A%84LiveData.html</link><pubDate>Wed, 24 Mar 2021 18:18:30 +0800</pubDate><guid>https://bravebuffalo.cc/post/%E6%B2%89%E6%80%9D%E7%AF%87-%E5%89%96%E6%9E%90Jetpack%E7%9A%84LiveData.html</guid><description>&lt;blockquote>
&lt;p>ViewModel做为架构组件的三元老之一，是实现MVVM的有力武器。&lt;/p>
&lt;/blockquote>
&lt;h1 id="viewmodel的设计目标" class="relative group">ViewModel的设计目标 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#viewmodel%e7%9a%84%e8%ae%be%e8%ae%a1%e7%9b%ae%e6%a0%87" aria-label="">#&lt;/a>&lt;/span>&lt;/h1>&lt;p>ViewModel的基本功能就是管理UI的数据。其实，从职责上来说，这又是对Activity和Fragment的一次功能拆分。以前存储在它们内部的数据，需要它们自己处理创建，更新，存储，恢复的所有过程，同时它们还要处理UI的数据绑定，更新，动画等操作。职责的多元化就容易出现不好定位和调试的问题。另外，Activity和Fragment作为UI的承载者，很多时候需要共享数据和复用功能。而UI的差异让复用的粒度划分很难把控，容易写出扩展性差的代码。基于这些痛点，ViewModel被设计出来了。
同时ViewModel还将保存数据的功能强化了——它将设备配置变更后数据保存和恢复自动化了，在UI生命周期内都能保证数据的有效性，这大大减少了样板代码的编写，提高了开发效率。&lt;/p></description></item><item><title>沉思篇-剖析Jetpack的LiveData</title><link>https://bravebuffalo.cc/post/%E6%B2%89%E6%80%9D%E7%AF%87-%E5%89%96%E6%9E%90Jetpack%E7%9A%84LiveData.html</link><pubDate>Tue, 23 Mar 2021 18:14:09 +0800</pubDate><guid>https://bravebuffalo.cc/post/%E6%B2%89%E6%80%9D%E7%AF%87-%E5%89%96%E6%9E%90Jetpack%E7%9A%84LiveData.html</guid><description>&lt;blockquote>
&lt;p>上一篇我们讲到了架构组件中的Lifecycle，由于缺少具体的运用，可能缺少直观的感受，今天我们就用Lifecycle实战一回，看看Lifecycle是怎样运用到LiveData中的。&lt;/p>
&lt;/blockquote>
&lt;h1 id="livedata的功能" class="relative group">LiveData的功能 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#livedata%e7%9a%84%e5%8a%9f%e8%83%bd" aria-label="">#&lt;/a>&lt;/span>&lt;/h1>&lt;p>根据&lt;code>LiveData&lt;/code>的类注释，我们可以知道，&lt;code>LiveData&lt;/code>是一个实现了观察者模式的数据容器，并且是可感知生命周期的。由这个功能描述，我们就能知道&lt;code>LiveData&lt;/code>是由两部分功能合并而来的，一部分是数据容器，一部分是响应生命周期。在阅读源码的时候，我觉得功能拆解是个很有用的手段，合理的功能拆解，就是有目的的省略，有助于快速理清功能实现逻辑。
接下来，我将以这两个功能为突破点，逐一梳理&lt;code>LiveData&lt;/code>的实现思路。&lt;/p></description></item><item><title>沉思篇-剖析JetPack的Lifecycle</title><link>https://bravebuffalo.cc/post/%E6%B2%89%E6%80%9D%E7%AF%87-%E5%89%96%E6%9E%90JetPack%E7%9A%84Lifecycle.html</link><pubDate>Sun, 21 Mar 2021 15:56:53 +0800</pubDate><guid>https://bravebuffalo.cc/post/%E6%B2%89%E6%80%9D%E7%AF%87-%E5%89%96%E6%9E%90JetPack%E7%9A%84Lifecycle.html</guid><description>&lt;blockquote>
&lt;p>这几年，对于Android开发者来说，最时髦的技术当属Jetpack了。谷歌官方从19年开始，就在极力推动Jetpack的使用，经过这几年的发展，Jetpack也基本完成了当时的设计目标——简单，一致，专注。而使得这一切成为可能的基石，我觉得当属架构组件了。最初架构组件作为单独的库和support库并没有太多联系，随着Jetpack的成型，给架构组件也注入了新的活力。在Jetpack库中，建构组件的使用随处可见，扮演着越来越重要的角色。今天，我就以作为架构组件基石的Lifecycle开始，尝试对架构组件进行剖析，向大家展示谷歌开发者是怎样设计一个高内聚，低耦合的库的。&lt;/p>
&lt;/blockquote></description></item></channel></rss>