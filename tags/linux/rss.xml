<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Linux on 低头沉思</title><link>https://hongui.github.io/tags/linux/</link><description>Recent content in Linux on 低头沉思</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Fri, 18 Feb 2022 21:19:39 +0800</lastBuildDate><atom:link href="https://hongui.github.io/tags/linux/rss.xml" rel="self" type="application/rss+xml"/><item><title>Linux批量文件操作——基于find,xargs</title><link>https://hongui.github.io/post/Linux%E6%89%B9%E9%87%8F%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E2%80%94%E2%80%94%E5%9F%BA%E4%BA%8Efind,xargs.html</link><pubDate>Fri, 18 Feb 2022 21:19:39 +0800</pubDate><guid>https://hongui.github.io/post/Linux%E6%89%B9%E9%87%8F%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E2%80%94%E2%80%94%E5%9F%BA%E4%BA%8Efind,xargs.html</guid><description>前言 在项目初创阶段，经常会遇到各种文件操作，拷贝头文件，库，批量重命名等。文件结构一复杂，这就将是个无聊的工作。
查找文件 find可以在目录结构中搜索文件，这是它在man里面的作用描述。那么怎么搜索呢？有多种方式，按文件时间，大小，按文件名，路径名，按文件类型，权限，按用户。而这些方式又可以通过与或非的逻辑相互组合，完成更苛刻的查找工作，简直是文件查找的福音。 通常介绍一种命令都会以命令形式开始，find的格式如下
find [-H] [-L] [-P] [-D debugopts] [-Olevel] [starting-point...] [expression] [-H] [-L] [-P] [-D debugopts] [-Olevel]这一些统统不重要， [-H] [-L] [-P]是针对软连接的，不常用。[-D debugopts]是显示运行期间的额外信息，信息太乱太杂，用处不大。[-Olevel]则是用于优化查找的，默认的已经够用，所以也没必要深究。 find的最大魔法在最后的[expression],下面将以实例的形式讲解这个[expression]到底该怎么玩，原始的文件结构如下
├── alice.h ├── andy │ ├── jack │ │ └── mary.h │ ├── mark.cpp │ ├── mark.h │ └── pony.txt ├── andy.c ├── bill.cpp ├── bill.h ├── mark.h └── mary 现在，我想找到以andy命名的文件，命令该怎么写呢。直觉告诉我们应该是
find andy 但是直觉对吗，我们来看输出
andy andy/mark.cpp andy/jack andy/jack/mary.h andy/pony.txt andy/mark.h 它只找到了andy目录，甚至都没找到andy.c，那么看来我们需要一种方式告诉find，我们找的东西是文件，不是目录，这个选项就是-type。 -type后面需要紧跟一个参数，常用取值是d代表目录,f代表文件。现在我们需要找到文件，那么就应该加个-type f的选项。但这就够了吗？执行命令会发现报错了，因为后面的andy被认为是路径，而我们要找的是文件名啊。所以，这又需要另一个选项的帮忙，-name。-name后面可以跟具体的名字或者正则。结合这两个条件，我们得出了最终的命令
find -type f -name &amp;#34;andy*&amp;#34; 这里有两点值得注意，首先-type和-name其实是两个独立选项，可以单独使用，也可以联合使用，当联合使用时，他们之间不使用操作符（-o(Or)，-a(AND),-not）连接时，就会把-a单做连接符，也就是所有的条件都满足才回出现在最终的结果中。由此，可以延伸出一种反向的查找方法，</description></item></channel></rss>