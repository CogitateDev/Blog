<!doctype html><html lang=en dir=ltr class=scroll-smooth data-default-appearance=light data-auto-appearance=true><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=theme-color content="#FFFFFF"><title>Modern C++ study guide-template &#183; Deep thinking</title>
<meta name=title content="Modern C++ study guide-template &#183; Deep thinking"><script type=text/javascript src=/js/appearance.min.8a082f81b27f3cb2ee528df0b0bdc39787034cf2cc34d4669fbc9977c929023c.js integrity="sha256-iggvgbJ/PLLuUo3wsL3Dl4cDTPLMNNRmn7yZd8kpAjw="></script><link type=text/css rel=stylesheet href=/css/main.bundle.min.b0785c8131a75f72b211435af86269eb2d4b81dda03a8f2cf5ccb1c967747167.css integrity="sha256-sHhcgTGnX3KyEUNa+GJp6y1Lgd2gOo8s9cyxyWd0cWc="><script defer type=text/javascript id=script-bundle src=/js/main.bundle.min.af5d9722112bedac95702865c340bcd6286c4e9b2c15ce26b531ea1fba974cb8.js integrity="sha256-r12XIhEr7ayVcChlw0C81ihsTpssFc4mtTHqH7qXTLg=" data-copy=Copy data-copied=Copied></script><meta name=description content="
      Modern C++ study guide-template
    "><link rel=canonical href=https://bravebuffalo.cc/en/post/Modern%20C++%20study%20guide-template.html><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><meta property="og:url" content="https://bravebuffalo.cc/en/post/Modern%20C++%20study%20guide-template.html"><meta property="og:site_name" content="Deep thinking"><meta property="og:title" content="Modern C++ study guide-template"><meta property="og:description" content="Modern C++ study guide-template"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-10-31T21:33:38+08:00"><meta property="article:modified_time" content="2022-10-31T21:33:38+08:00"><meta property="article:tag" content="Study Guide"><meta property="article:tag" content="C++"><meta name=twitter:card content="summary"><meta name=twitter:title content="Modern C++ study guide-template"><meta name=twitter:description content="Modern C++ study guide-template"><script type=application/ld+json>{"@context":"https://schema.org","@type":"Article","articleSection":"Posts","name":"Modern C\u002b\u002b study guide-template","headline":"Modern C\u002b\u002b study guide-template","description":"Modern C\u002b\u002b study guide-template","abstract":"\u003cblockquote\u003e\n\u003cp\u003eTemplate have always had a pivotal role as an important feature of C\u002b\u002b, and are a great tool for writing highly abstract code.\u003c\/p\u003e\n\u003c\/blockquote\u003e\n\u003ch3 id=\u0022what-is-template\u0022 class=\u0022relative group\u0022\u003eWhat is template \u003cspan class=\u0022absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100\u0022\u003e\u003ca class=\u0022group-hover:text-primary-300 dark:group-hover:text-neutral-700\u0022 style=\u0022text-decoration-line: none !important;\u0022 href=\u0022#what-is-template\u0022 aria-label=\u0022Anchor\u0022\u003e#\u003c\/a\u003e\u003c\/span\u003e\u003c\/h3\u003e\u003cp\u003eTemplate are real-life examples: fix the parts that are all the same, leave the parts that change empty, and combine the two parts to form something valid when you use it. Application forms and Word templates are examples of this, as are templates in C\u002b\u002b, but more explicitly in C\u002b\u002b, where the variable part is a surrogate type, called a generic parameter.\u003c\/p\u003e","inLanguage":"en","url":"https:\/\/bravebuffalo.cc\/en\/post\/Modern%20C\u002b\u002b%20study%20guide-template.html","author":{"@type":"Person","name":"Deep thinking"},"copyrightYear":"2022","dateCreated":"2022-10-31T21:33:38\u002b08:00","datePublished":"2022-10-31T21:33:38\u002b08:00","dateModified":"2022-10-31T21:33:38\u002b08:00","keywords":["Study guide","C++"],"mainEntityOfPage":"true","wordCount":"3881"}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","item":"https://bravebuffalo.cc/en/","name":"Deep Thinking","position":1},{"@type":"ListItem","item":"https://bravebuffalo.cc/en/posts/","name":"Posts","position":2},{"@type":"ListItem","item":"https://bravebuffalo.cc/en/categories/c++/","name":"C++","position":3},{"@type":"ListItem","name":"Modern C Study Guide Template","position":4}]}</script><meta name=author content="Deep thinking"><link href=mailto:honguilee@163.com rel=me><link href=https://github.com/hongui rel=me></head><body class="m-auto flex h-screen max-w-7xl flex-col bg-neutral px-6 text-lg leading-7 text-neutral-900 dark:bg-neutral-800 dark:text-neutral sm:px-14 md:px-24 lg:px-32"><div id=the-top class="absolute flex self-center"><a class="-translate-y-8 rounded-b-lg bg-primary-200 px-3 py-1 text-sm focus:translate-y-0 dark:bg-neutral-600" href=#main-content><span class="pe-2 font-bold text-primary-600 dark:text-primary-400">&darr;</span>Skip to main content</a></div><header class="py-6 font-semibold text-neutral-900 dark:text-neutral sm:py-10 print:hidden"><nav class="flex items-start justify-between sm:items-center"><div class="flex flex-row items-center"><a href=/en/ class=mr-2><img src=/images/logo.png width=500 height=500 class="max-h-[10rem] max-w-[10rem] object-scale-down object-left" alt="Deep thinking">
</a><a class="decoration-primary-500 hover:underline hover:decoration-2 hover:underline-offset-2" rel=me href=/en/>Deep thinking</a></div><ul class="flex list-none flex-col text-end sm:flex-row"><li class="group mb-1 sm:mb-0 sm:me-7 sm:last:me-0.5"><a href=/en/posts/ title><span class="decoration-primary-500 group-hover:underline group-hover:decoration-2 group-hover:underline-offset-2">Blog</span></a></li><li class="group mb-1 sm:mb-0 sm:me-7 sm:last:me-0.5"><a href=/en/categories/ title><span class="decoration-primary-500 group-hover:underline group-hover:decoration-2 group-hover:underline-offset-2">Categories</span></a></li><li class="group mb-1 sm:mb-0 sm:me-7 sm:last:me-0.5"><a href=/en/tags/ title><span class="decoration-primary-500 group-hover:underline group-hover:decoration-2 group-hover:underline-offset-2">Tags</span></a></li><li class="group mb-1 sm:mb-0 sm:me-7 sm:last:me-0.5"><a href=/en/about.html title><span class="decoration-primary-500 group-hover:underline group-hover:decoration-2 group-hover:underline-offset-2">About</span></a></li><li class="group mb-1 sm:mb-0 sm:me-7 sm:last:me-0.5"><button id=search-button-1 title="Search (/)">
<span class="group-dark:hover:text-primary-400 transition-colors group-hover:text-primary-600"><span class="icon relative inline-block px-1 align-text-bottom"><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="search" class="svg-inline--fa fa-search fa-w-16" role="img" viewBox="0 0 512 512"><path fill="currentcolor" d="M505 442.7 405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9.0 208 0S0 93.1.0 208s93.1 208 208 208c48.3.0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9.0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7.0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7.0 128 57.2 128 128 0 70.7-57.2 128-128 128z"/></svg>
</span></span><span class="decoration-primary-500 group-hover:underline group-hover:decoration-2 group-hover:underline-offset-2"></span></button></li><li class="group mb-1 sm:mb-0 sm:me-7 sm:last:me-0.5"><div class="group relative"><button class="group-dark:hover:text-primary-400 flex w-full items-center justify-end transition-colors group-hover:text-primary-600">
<span class="icon relative inline-block px-1 align-text-bottom"><svg viewBox="0 0 16 16"><path fill="currentcolor" d="M4.545 6.714 4.11 8H3l1.862-5h1.284L8 8H6.833l-.435-1.286H4.545zm1.634-.736L5.5 3.956h-.049l-.679 2.022H6.18z"/><path fill="currentcolor" d="M0 2a2 2 0 012-2h7a2 2 0 012 2v3h3a2 2 0 012 2v7a2 2 0 01-2 2H7a2 2 0 01-2-2v-3H2A2 2 0 010 9V2zm2-1A1 1 0 001 2v7a1 1 0 001 1h7a1 1 0 001-1V2A1 1 0 009 1H2zm7.138 9.995c.193.301.402.583.63.846-.748.575-1.673 1.001-2.768 1.292.178.217.451.635.555.867 1.125-.359 2.08-.844 2.886-1.494.777.665 1.739 1.165 2.93 1.472.133-.254.414-.673.629-.89-1.125-.253-2.057-.694-2.82-1.284.681-.747 1.222-1.651 1.621-2.757H14V8h-3v1.047h.765c-.318.844-.74 1.546-1.272 2.13a6.066 6.066.0 01-.415-.492 1.988 1.988.0 01-.94.31z"/></svg>
</span><span class=text-sm>EN</span><span class=text-[0.6rem]><span class="icon relative inline-block px-1 align-text-bottom"><svg viewBox="0 0 512 512"><path fill="currentcolor" d="M233.4 406.6c12.5 12.5 32.8 12.5 45.3.0l192-192c12.5-12.5 12.5-32.8.0-45.3s-32.8-12.5-45.3.0L256 338.7 86.6 169.4c-12.5-12.5-32.8-12.5-45.3.0s-12.5 32.8.0 45.3l192 192z"/></svg></span></span></button><div class="invisible w-full bg-transparent group-hover:visible"></div><div class="invisible absolute z-50 flex flex-col whitespace-nowrap rounded border border-neutral-300 bg-neutral text-start text-base shadow group-hover:visible ltr:right-0 rtl:left-0 dark:border-neutral-600 dark:bg-neutral-800"><div class="flex flex-grow"><a href=/en/post/Modern%20C++%20study%20guide-template.html class="flex w-full items-center justify-between bg-primary-100 px-2 py-1 dark:bg-primary-900">English<span class="ms-2 w-6 text-primary-600 dark:text-primary-400"><span class="icon relative inline-block px-1 align-text-bottom"><svg viewBox="0 0 448 512"><path fill="currentcolor" d="M438.6 105.4c12.5 12.5 12.5 32.7.0 45.2l-256 256c-12.5 12.5-32.7 12.5-45.2.0L9.372 278.6c-12.496-12.5-12.496-32.7.0-45.2 12.498-12.5 32.758-12.5 45.258.0L159.1 338.7 393.4 105.4c12.5-12.52 32.7-12.52 45.2.0h0z"/></svg></span></span></a></div><div class="flex flex-grow"><a href=/post/%E7%8E%B0%E4%BB%A3C++%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97%20%E6%A8%A1%E6%9D%BF.html class="w-full py-1 pe-10 ps-2 decoration-primary-500 hover:underline hover:decoration-2 hover:underline-offset-2">简体中文</a></div></div></div></li></ul></nav></header><div class="relative flex grow flex-col"><main id=main-content class=grow><article><header class=max-w-prose><h1 class="mb-8 mt-0 text-4xl font-extrabold text-neutral-900 dark:text-neutral">Modern C++ study guide-template</h1><div class="mb-10 text-base text-neutral-500 dark:text-neutral-400 print:hidden"><div class="flex flex-row flex-wrap items-center"><time datetime="2022-10-31 21:33:38 +0800 +0800">31 October 2022</time><span class="px-2 text-primary-500">&#183;</span><span title="Reading time">19 mins</span></div></div></header><section class="prose mt-0 flex max-w-full flex-col dark:prose-invert lg:flex-row"><div class="min-h-0 min-w-0 max-w-prose grow"><blockquote><p>Template have always had a pivotal role as an important feature of C++, and are a great tool for writing highly abstract code.</p></blockquote><h3 id=what-is-template class="relative group">What is template <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#what-is-template aria-label=Anchor>#</a></span></h3><p>Template are real-life examples: fix the parts that are all the same, leave the parts that change empty, and combine the two parts to form something valid when you use it. Application forms and Word templates are examples of this, as are templates in C++, but more explicitly in C++, where the variable part is a surrogate type, called a generic parameter.</p><p>Let&rsquo;s look at an example to see how templates evolved. If we need to calculate the result of adding two objects, how do we write the code? Before we write the code, we have a couple of issues that we need to discuss clearly:
The first thing we need to determine is that the two objects are of what type, after all, C++ is a strongly typed programming language, variables, functions, and classes are explicitly specified as to what the type is, and the compilation of an unspecified type will not pass. Let&rsquo;s assume for a moment that the two types are integers. Once we have determined the type, we need to determine how the two objects need to be added together. Based on our assumption that they are integers, we know that we can just call the operator <code>+</code>. Finally, we need to determine what the result type of the addition of the two objects will be, and the result of the addition of an integer type will also be an integer type. To summarize, the code for this example might look something like this</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=nf>sum</span><span class=p>(</span><span class=kt>int</span> <span class=n>left</span><span class=p>,</span><span class=kt>int</span> <span class=n>right</span><span class=p>){</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=n>left</span> <span class=o>+</span> <span class=n>right</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>This example is simple, so simple that it doesn&rsquo;t even need to be written as a separate function. What if the data we need to calculate is not two numbers, but the sum of an array? Based on the previous analysis and assumptions, we can also quickly implement the corresponding code</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=nf>sum</span><span class=p>(</span><span class=k>const</span> <span class=kt>int</span> <span class=n>data</span><span class=p>[],</span> <span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>size_t</span> <span class=n>length</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kt>int</span> <span class=n>result</span><span class=p>{};</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>length</span><span class=p>;</span><span class=o>++</span><span class=n>i</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=n>result</span> <span class=o>+=</span> <span class=o>*</span><span class=p>(</span><span class=n>data</span> <span class=o>+</span> <span class=n>i</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=n>result</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Again, very simple. Unfortunately, this function is not very general, it can only compute integer sums, if we need to compute a sum with a decimal point, it doesn&rsquo;t work because the first argument type doesn&rsquo;t match, even though we know that almost all of <code>sum</code>&rsquo;s code can be reused, except for the <code>int</code> in the first line, which needs to be replaced with <code>double</code>. But it can&rsquo;t! We can only make a copy and change the <code>int</code> places to <code>double</code>.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>double</span> <span class=nf>sum</span><span class=p>(</span><span class=k>const</span> <span class=kt>double</span> <span class=n>data</span><span class=p>[],</span> <span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>size_t</span> <span class=n>length</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kt>double</span> <span class=n>result</span><span class=p>{};</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>length</span><span class=p>;</span><span class=o>++</span><span class=n>i</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=n>result</span> <span class=o>+=</span> <span class=o>*</span><span class=p>(</span><span class=n>data</span> <span class=o>+</span> <span class=n>i</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=n>result</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>This is where you see the problem, <strong>this process, we have only changed the type information</strong>. The problem continues to grow, we may need to ask for an array sum of <code>float</code> again, the same array sum of <code>double</code> above won&rsquo;t match, because <code>float</code>, <code>double</code> are two types. It is because the data types are different that many times we need to provide similar code for different data, which is painful in the case of bloated data types, and when making changes to the algorithm we need to make sure that all the data types are modified and tested one by one, which definitely increases the workload and amplifies the error rate. But the actual valid code is to specify the type, if the type is not clear, the compiler can not determine whether the code is legal, not sure things the compiler has to report an error, so in accordance with the ordinary thinking, this problem is not solved.</p><p>But in fact, very often, these similar codes are simply different data types, and dealing with this repetitive work should be left to the computer, i.e. the compiler. So we need a technique that allows the <strong>compiler to not care what the specific type is in the first place, but to replace it with a special type that can be replaced with any type, complete the specific algorithm with this special type, and provide the type information to the algorithm based on the actual needs at the time of use to allow the compiler to generate a specific algorithm that satisfies the provided type, which is a template</strong>. This is ideologically common with templates in life. The algorithm is the fixed part, the data type is the variable part, and the two together make legal C++ code. That is, using templates, we can write just one algorithm, and with the help of the compiler generate algorithms of all types, and the only difference between these algorithms is the type.</p><p>Of course the template is not enough, the above only solves the problem of the type, did not solve the problem of algorithm implementation. How so, e.g. we have a requirement to sort the data first and then find the maximum value. This is valid for numeric (<code>int</code>, <code>float</code>, <code>double</code>, etc.) types, and can be done using comparison operators (<code>&lt;</code>, <code>></code>), but what if we want to make this algorithm work for custom types? Writing the comparison operator directly in the template implementation won&rsquo;t work for custom types because they don&rsquo;t have a corresponding comparison function. The solution is simple: the custom type implements the corresponding comparison operator. Problems such as these will often be encountered in the template, because we do not know anything about the type of information, but to ensure that almost all types can work properly, which will have to use a variety of techniques to qualify or detect the type, which is actually the essence of the template problem. So the template problem is not just a type problem, or a combination of other C++ problems, and requires a more complete understanding of C++ features in order to write useful and efficient code.
In C++, templates are usually divided into function templates and template classes, so let&rsquo;s start with the simpler function templates.</p><h3 id=function-template class="relative group">Function template <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#function-template aria-label=Anchor>#</a></span></h3><p>A function template is a function that differs from a regular function in that at least one of its argument list is of indeterminate type. Continue with our example above:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=n>T</span> <span class=n>sum</span><span class=p>(</span><span class=k>const</span> <span class=n>T</span> <span class=n>data</span><span class=p>[],</span> <span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>size_t</span> <span class=n>length</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=n>T</span> <span class=n>result</span><span class=p>{};</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>length</span><span class=p>;</span><span class=o>++</span><span class=n>i</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=n>result</span> <span class=o>+=</span> <span class=o>*</span><span class=p>(</span><span class=n>data</span> <span class=o>+</span> <span class=n>i</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=n>result</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kt>int</span> <span class=n>intData</span><span class=p>[]</span> <span class=o>=</span> <span class=p>{</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>2</span> <span class=p>};</span>
</span></span><span class=line><span class=cl>	<span class=kt>float</span> <span class=n>floatData</span><span class=p>[]</span> <span class=o>=</span> <span class=p>{</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>2</span> <span class=p>};</span>
</span></span><span class=line><span class=cl>	<span class=kt>double</span> <span class=n>doubleData</span><span class=p>[]</span> <span class=o>=</span> <span class=p>{</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>2</span> <span class=p>};</span>
</span></span><span class=line><span class=cl>	<span class=k>auto</span> <span class=n>len</span> <span class=o>=</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>intData</span><span class=p>)</span><span class=o>/</span><span class=k>sizeof</span><span class=p>(</span><span class=n>intData</span><span class=p>[</span><span class=mi>0</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;intSum = &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>sum</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span><span class=p>(</span><span class=n>intData</span><span class=p>,</span><span class=n>len</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;, floatSum = &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>sum</span><span class=o>&lt;</span><span class=kt>float</span><span class=o>&gt;</span><span class=p>(</span><span class=n>floatData</span><span class=p>,</span><span class=n>len</span><span class=p>)</span> <span class=o>&lt;&lt;</span><span class=s>&#34;, doubleSum = &#34;</span> <span class=o>&lt;&lt;</span><span class=n>sum</span><span class=o>&lt;</span><span class=kt>double</span><span class=o>&gt;</span><span class=p>(</span><span class=n>doubleData</span><span class=p>,</span><span class=n>len</span><span class=p>)</span><span class=o>&lt;&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=c1>// output
</span></span></span><span class=line><span class=cl><span class=c1>// intSum = 6, floatSum = 6, doubleSum = 6
</span></span></span></code></pre></div><p>Here, we&rsquo;ve just written a function that works for <code>int</code>, <code>float</code>, and <code>double</code>. If there are other types that implement the default initialization and operator <code>+=</code> you can also use this function to sum without changing any existing code, that&rsquo;s the beauty of templates.
Before moving on to something new, let&rsquo;s recognize the difference between a function template and a regular function:</p><ol><li>Function templates require a template header, <code>template&lt;typename T></code>. It serves to tell the compiler that none of the following functions where <code>T</code> is encountered are of a specific type, and that it needs to be determined again when the function is called.</li><li>In the function declaration, the type position is replaced by <code>T</code>, which means that <code>T</code> is a placeholder type that can be used as a normal type. This is useful when writing boilerplate code.</li></ol><p>Looking again at the use of functions, that is, statements like <code>sum&lt;xxx>(xxxData,len)</code>, where <code>xxx</code> represents the data type, which is the actual type of <code>T</code> in the function template. This simply tells the compiler to replace the type <code>T</code> in the function template with the type <code>xxx</code>, a process that has an official name, <strong>instantiation</strong>, which is another thing that is different from normal functions&mldr;. Using function templates is a two-step process.</p><ol><li>Define the template. This step does not have a specific type and requires the use of a generic parameter to placeholder the type, i.e., wherever an actual type occurs, use the generic parameter to placeholder it and use this generic parameter to implement the complete algorithm. In this step the compiler, since it does not know the exact type, will not disable some type operations, but only check if the identifier exists, if the syntax is legal etc.</li><li>Instantiation. The process of instantiation happens only where the developer calls the function template, the code of the function template that is not instantiated does not appear in the most executable file. The compiler will replace the generic parameter with the actual parameter for each place where instantiation occurs, and check whether the actual type supports all the operations in the algorithm, if not, the compilation fails, and the developer needs to implement the relevant operations or modify the function template. As in the above example, if we instantiate a custom type, we will find that the compilation fails because the custom type does not define the operator <code>+=</code> (unless that operator is already defined), and this process occurs in the instantiation. The solution is simple: add the operator <code>+=</code> to the custom type.</li></ol><h3 id=type-derivation class="relative group">Type derivation <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#type-derivation aria-label=Anchor>#</a></span></h3><p>In the above example, we found that in the process of instantiation, we have to pass both the type parameter and the data parameter to the function template, and the type parameter is often one-to-one with the type of the data, which is a redundant syntax for modern C++ is unacceptable, so modern C++ compilers all support type derivation. Type derivation allows the developer to omit the type parameter and derive the type parameter directly from the data type, so the above example instantiation can be written in the form of <code>sum(xxxData,len)</code>, and the compiler will be able to derive the type of <code>xxx</code> to be <code>int</code>, <code>float</code>, and <code>double</code> respectively.
Of course, type derivation is not foolproof, let&rsquo;s look at the following example</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=n>T</span> <span class=n>max</span><span class=p>(</span><span class=n>T</span> <span class=n>a</span><span class=p>,</span> <span class=n>T</span> <span class=n>b</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=n>a</span> <span class=o>&gt;</span> <span class=n>b</span> <span class=o>?</span> <span class=nl>a</span> <span class=p>:</span> <span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kt>int</span> <span class=n>a</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=kt>int</span> <span class=n>b</span> <span class=o>=</span> <span class=mi>2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;max(&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>a</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;,&#34;</span><span class=o>&lt;&lt;</span><span class=n>b</span><span class=o>&lt;&lt;</span><span class=s>&#34;) = &#34;</span> <span class=o>&lt;&lt;</span><span class=n>max</span><span class=p>(</span><span class=n>a</span><span class=p>,</span><span class=n>b</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// output
</span></span></span><span class=line><span class=cl><span class=c1>// max(1,2) = 2
</span></span></span></code></pre></div><p>This example is intuitive, and the result is certainly unsurprising. Now we&rsquo;re going to morph: we change the type of the variable <code>b</code> to <code>float</code> and realize that the compilation won&rsquo;t pass. The hint is that we have a data type mismatch, because <code>a</code> is <code>int</code> and <code>b</code> is <code>float</code>, so the deduction is <code>max&lt;int,float>()</code>, whereas in reality we have only one type parameter.
So since the problem is clear, the solution seems simple enough, wouldn&rsquo;t it be enough to add another parameter to <code>max</code>? Let&rsquo;s take a look.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>A</span><span class=p>,</span><span class=k>typename</span> <span class=n>B</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=n>A</span> <span class=n>max</span><span class=p>(</span><span class=n>A</span> <span class=n>a</span><span class=p>,</span> <span class=n>B</span> <span class=n>b</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=n>a</span> <span class=o>&gt;</span> <span class=n>b</span> <span class=o>?</span> <span class=nl>a</span> <span class=p>:</span> <span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kt>int</span> <span class=n>a</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=kt>float</span> <span class=n>b</span> <span class=o>=</span> <span class=mi>2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;max(&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>a</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;,&#34;</span><span class=o>&lt;&lt;</span><span class=n>b</span><span class=o>&lt;&lt;</span><span class=s>&#34;) = &#34;</span> <span class=o>&lt;&lt;</span><span class=n>max</span><span class=p>(</span><span class=n>a</span><span class=p>,</span><span class=n>b</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// output
</span></span></span><span class=line><span class=cl><span class=c1>// max(1,2) = 2
</span></span></span></code></pre></div><p>After this change, it compiles and runs without errors, so the problem seems to be solved, right?
No, it&rsquo;s not. Let&rsquo;s replace <code>float b = 2;</code> with <code>float b = 2.5;</code>.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kt>int</span> <span class=n>a</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=kt>float</span> <span class=n>b</span> <span class=o>=</span> <span class=mf>2.5</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;max(&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>a</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;,&#34;</span><span class=o>&lt;&lt;</span><span class=n>b</span><span class=o>&lt;&lt;</span><span class=s>&#34;) = &#34;</span> <span class=o>&lt;&lt;</span><span class=n>max</span><span class=p>(</span><span class=n>a</span><span class=p>,</span><span class=n>b</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// output
</span></span></span><span class=line><span class=cl><span class=c1>// max(1,2.5) = 2
</span></span></span></code></pre></div><p>Run the program again, and you&rsquo;ll see that the output is wrong. This is because in the function template, we defined the return value as <code>A</code>, and at instantiation time <code>A</code> was derived to be of type <code>int</code>, so in fact the return value of <code>max</code> became of type <code>int</code>, and the maximum value, <code>B</code>, was forcibly converted from a <code>float</code> to an <code>int</code>, and the data precision was lost. So is there a solution? There is, and there is more than one!
According to the above analysis, the root of the problem is that the data has been forcibly converted, and the solution is of course to prevent it from happening, that is, to keep the two data types consistent, so how to ensure it? Block the compiler&rsquo;s type derivation, manually fill in the type parameter.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kt>int</span> <span class=n>a</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=kt>float</span> <span class=n>b</span> <span class=o>=</span> <span class=mf>2.5</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;max(&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>a</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;,&#34;</span><span class=o>&lt;&lt;</span><span class=n>b</span><span class=o>&lt;&lt;</span><span class=s>&#34;) = &#34;</span> <span class=o>&lt;&lt;</span><span class=n>max</span><span class=o>&lt;</span><span class=kt>float</span><span class=o>&gt;</span><span class=p>(</span><span class=n>a</span><span class=p>,</span><span class=n>b</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// outout
</span></span></span><span class=line><span class=cl><span class=c1>// max(1,2.5) = 2.5
</span></span></span></code></pre></div><p>As you can see in this example, we only filled in one type parameter, because type <code>B</code> is automatically deduced to <code>float</code>. Yes, type derivation can be partially disabled!
Another solution is to let the compiler calculate the type entirely. How to calculate it, C++11 provides <code>auto</code> and <code>decltype</code>. <code>auto</code> calculates the type of a variable, and <code>decltype</code> calculates the type of an expression, as follows:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>auto</span> <span class=n>a</span><span class=o>=</span><span class=mi>1</span><span class=p>;</span> <span class=c1>// a is derived as type int
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>auto</span> <span class=n>b</span><span class=o>=</span><span class=mf>1.5</span><span class=p>;</span> <span class=c1>// b is derived as type double
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>decltype</span><span class=p>(</span><span class=n>a</span><span class=o>+</span><span class=n>b</span><span class=p>)</span> <span class=c1>//the result is type double
</span></span></span></code></pre></div><p>That is, you can set the return value to <code>auto</code> and let the compiler decide the return type</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>A</span><span class=p>,</span><span class=k>typename</span> <span class=n>B</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>auto</span> <span class=n>max</span><span class=p>(</span><span class=n>A</span> <span class=n>a</span><span class=p>,</span> <span class=n>B</span> <span class=n>b</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=n>a</span> <span class=o>&gt;</span> <span class=n>b</span> <span class=o>?</span> <span class=nl>a</span> <span class=p>:</span> <span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kt>int</span> <span class=n>a</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=kt>float</span> <span class=n>b</span> <span class=o>=</span> <span class=mf>2.5</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;max(&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>a</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;,&#34;</span><span class=o>&lt;&lt;</span><span class=n>b</span><span class=o>&lt;&lt;</span><span class=s>&#34;) = &#34;</span> <span class=o>&lt;&lt;</span><span class=n>max</span><span class=o>&lt;</span><span class=kt>float</span><span class=o>&gt;</span><span class=p>(</span><span class=n>a</span><span class=p>,</span><span class=n>b</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// output
</span></span></span><span class=line><span class=cl><span class=c1>// max(1,2.5) = 2.5
</span></span></span></code></pre></div><p>If the compiler only supported C++11, it would be a bit tricky to not only front <code>auto</code>, but also use <code>decltype</code> after the function header to compute the return type, a feature known as <strong>tailed return derivation.</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>A</span><span class=p>,</span><span class=k>typename</span> <span class=n>B</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>auto</span> <span class=n>max</span><span class=p>(</span><span class=n>A</span> <span class=n>a</span><span class=p>,</span> <span class=n>B</span> <span class=n>b</span><span class=p>)</span><span class=o>-&gt;</span><span class=k>decltype</span><span class=p>(</span><span class=n>a</span> <span class=o>+</span> <span class=n>b</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=n>a</span> <span class=o>&gt;</span> <span class=n>b</span> <span class=o>?</span> <span class=nl>a</span> <span class=p>:</span> <span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Here <code>decltype</code> is written inside the
Let&rsquo;s put the function templates aside for now, and let&rsquo;s take a look at what the class template look like.</p><h3 id=class-template class="relative group">Class template <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#class-template aria-label=Anchor>#</a></span></h3><p>Like function templates, class templates contain at least one generic parameter that is scoped to the entire class, meaning that member variables and member functions can be defined using this generic parameter.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Result</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=n>T</span> <span class=n>data</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=kt>int</span> <span class=n>code</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>reason</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>	<span class=n>Result</span><span class=p>(</span><span class=n>T</span> <span class=n>data</span><span class=p>,</span> <span class=kt>int</span> <span class=n>code</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>reason</span> <span class=o>=</span> <span class=s>&#34;success&#34;</span><span class=p>)</span> <span class=o>:</span><span class=n>data</span><span class=p>{</span> <span class=n>data</span> <span class=p>},</span> <span class=n>code</span><span class=p>{</span> <span class=n>code</span> <span class=p>},</span> <span class=n>reason</span><span class=p>{</span> <span class=n>reason</span> <span class=p>}</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>friend</span> <span class=n>std</span><span class=o>::</span><span class=n>ostream</span><span class=o>&amp;</span> <span class=k>operator</span><span class=o>&lt;&lt;</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>ostream</span><span class=o>&amp;</span> <span class=n>os</span><span class=p>,</span> <span class=k>const</span> <span class=n>Result</span> <span class=n>result</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=n>os</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Result(data = &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>result</span><span class=p>.</span><span class=n>data</span> <span class=o>&lt;&lt;</span><span class=s>&#34;, code = &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>result</span><span class=p>.</span><span class=n>code</span> <span class=o>&lt;&lt;</span><span class=s>&#34;, reason = &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>result</span><span class=p>.</span><span class=n>reason</span> <span class=o>&lt;&lt;</span><span class=s>&#34;)&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=n>os</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=n>Result</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>result</span><span class=p>{</span> <span class=mi>9527</span> <span class=p>};</span>
</span></span><span class=line><span class=cl>	<span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>result</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// output
</span></span></span><span class=line><span class=cl><span class=c1>// Result(data = 9527, code = 0, reason = success)
</span></span></span></code></pre></div><p>As you can see, the class template is similar to a regular class in that it has everything that a regular class has - member functions, member variables, constructors, etc. It&rsquo;s still worth mentioning the generic parameter <code>T</code>. The above example is a common data class in the SDK, used to indicate whether an operation was successful or not and to return the result of the operation if necessary. For returning normal data types, this class is sufficient, but if one of our interfaces does not have a return value, and traditionally returns a <code>void</code> type, a problem arises. The actual type of <code>data</code> is <code>void</code>, but we can&rsquo;t find any value to initialize it. Further, when returning <code>void</code>, we don&rsquo;t need the <code>data</code> member variable at all. To solve problems like this one, templates provide specializations.</p><h3 id=specialization-and-partial-specialization class="relative group">Specialization and partial specialization <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#specialization-and-partial-specialization aria-label=Anchor>#</a></span></h3><p><strong>Specialization is the reimplementation of a class template or function template with a specific type instead of a generic parameter, which depends on the original template</strong>. As in the above example, we already have the original template class <code>Result&lt;T></code>, in order to solve the case where <code>void</code> cannot be used, we need to redefine a <code>Result</code> for the <code>void</code> type, i.e., <code>Result&lt;void></code>, then <code>Result&lt;void></code> is known as a kind of specialization of <code>Result&lt;T></code> and the original <code>Result&lt;T></code> is called the original template class. There can be many such specializations, and a type is a specialization which <strong>perfectly combines the advantages of both generality and specificity</strong>. When instantiation is done, if the instantiated type and the specialization type are the same, the instantiation will be done using that class (function) of the specialization, as in the following example</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// Result definition remains unchanged, new specialization version added
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>template</span> <span class=o>&lt;&gt;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Result</span><span class=o>&lt;</span><span class=kt>void</span><span class=o>&gt;</span><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kt>int</span> <span class=n>code</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>reason</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>	<span class=n>Result</span><span class=p>(</span><span class=kt>int</span> <span class=n>code</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>reason</span> <span class=o>=</span> <span class=s>&#34;success&#34;</span><span class=p>)</span><span class=o>:</span> <span class=n>code</span><span class=p>{</span> <span class=n>code</span> <span class=p>},</span> <span class=n>reason</span><span class=p>{</span> <span class=n>reason</span> <span class=p>}{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>friend</span> <span class=n>std</span><span class=o>::</span><span class=n>ostream</span><span class=o>&amp;</span> <span class=k>operator</span><span class=o>&lt;&lt;</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>ostream</span><span class=o>&amp;</span> <span class=n>os</span><span class=p>,</span> <span class=k>const</span> <span class=n>Result</span> <span class=n>result</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=n>os</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Result(&#34;</span><span class=o>&lt;&lt;</span><span class=s>&#34;code = &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>result</span><span class=p>.</span><span class=n>code</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;, reason = &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>result</span><span class=p>.</span><span class=n>reason</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;)&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=n>os</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=n>Result</span><span class=o>&lt;</span><span class=kt>void</span><span class=o>&gt;</span> <span class=n>voidResult</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>Result</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>intResult</span><span class=p>{</span><span class=mi>9527</span><span class=p>};</span>
</span></span><span class=line><span class=cl>	<span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;void = &#34;</span><span class=o>&lt;&lt;</span> <span class=n>voidResult</span><span class=o>&lt;&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=o>&lt;&lt;</span><span class=s>&#34;int = &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>intResult</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// output
</span></span></span><span class=line><span class=cl><span class=c1>// void = Result(code = 0, reason = success)
</span></span></span><span class=line><span class=cl><span class=c1>// int = Result(data = 9527, code = 0, reason = success)
</span></span></span></code></pre></div><p>As you can see, when instantiated to the <code>int</code> type, the original template class is used. And when instantiated as a <code>void</code> type, the specialization version is used.
In addition to specialization, there is also <strong>preferential specialization</strong>. A partial specialization is much like a specialization in that it is a narrower qualification of the type to make it apply to a certain class of types, such as <code>const</code>, pointers, references, etc. Or partial specialization for classes with multiple generic parameters.
Specialization and partial specialization are complementary to template special types and solve some problems with template implementation. Very often if the generic template is not well implemented, you can consider using specialization. Of course, the more versions of specialization, the higher the maintenance cost of the template, it is time to consider whether there is a design flaw.</p><h3 id=type-qualification class="relative group">Type qualification <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#type-qualification aria-label=Anchor>#</a></span></h3><p>The power of C++ templates is not only in the manipulation of types, but sometimes in order to prevent our classes from being abused, we need to qualify these abilities, such as disallowing the instantiation of certain specific types.
In the example above, suppose we specify that <code>Result</code> must return actual data, what would be the best way to prohibit <code>void</code> instantiation? It&rsquo;s easy to think that we would first need a way to <strong>determine whether the type at instantiation is of a particular type</strong>, and then we would need to tell the compiler to fail to compile if <strong>the instantiated type is a forbidden type</strong>. All of this is supported by the standard library <code>type_traits</code>. It provides a number of tools to help us recognize type parameters such as numbers, strings, pointers, etc. It also provides a number of other tools to assist these type parameter tools with more complex functions.
In this case, we want the instantiation type not to be <code>void</code>, and after looking up <code>type_traits</code>, we find that there is a class <code>is_void</code>, which has a <code>value</code> constant that is <code>true</code> if the type parameter is <code>void</code>, and <code>false</code> otherwise. Of course it&rsquo;s not enough to have a determination method, we also need a way for the compiler to report an error if the types don&rsquo;t match, and as it happens, we have <code>enable_if_t</code>. It has two type parameters, the first is a boolean expression and the second is a type parameter. The type parameter is defined when the expression is true, otherwise the compilation fails. So in order to accomplish the function of disabling <code>void</code> instantiation, we need to use two tools, <code>is_void</code> to determine whether the type parameter is <code>void</code> or not, and <code>enable_if_t</code> to accomplish the conversion from boolean expression to type parameter. To summarize, let&rsquo;s take a look at the implementation:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Result</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=n>std</span><span class=o>::</span><span class=n>enable_if_t</span><span class=o>&lt;!</span><span class=n>std</span><span class=o>::</span><span class=n>is_void</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;::</span><span class=n>value</span><span class=p>,</span><span class=n>T</span><span class=o>&gt;</span> <span class=n>data</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=kt>int</span> <span class=n>code</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>reason</span><span class=p>;</span> 
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>	<span class=n>Result</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>enable_if_t</span><span class=o>&lt;</span> <span class=o>!</span><span class=n>std</span><span class=o>::</span><span class=n>is_void</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;::</span><span class=n>value</span><span class=p>,</span><span class=n>T</span><span class=o>&gt;</span> <span class=n>data</span><span class=p>,</span> <span class=kt>int</span> <span class=n>code</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>reason</span> <span class=o>=</span> <span class=s>&#34;success&#34;</span><span class=p>)</span> <span class=o>:</span><span class=n>data</span><span class=p>{</span> <span class=n>data</span> <span class=p>},</span> <span class=n>code</span><span class=p>{</span> <span class=n>code</span> <span class=p>},</span> <span class=n>reason</span><span class=p>{</span> <span class=n>reason</span> <span class=p>}</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>friend</span> <span class=n>std</span><span class=o>::</span><span class=n>ostream</span><span class=o>&amp;</span> <span class=k>operator</span><span class=o>&lt;&lt;</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>ostream</span><span class=o>&amp;</span> <span class=n>os</span><span class=p>,</span> <span class=k>const</span> <span class=n>Result</span><span class=o>&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>enable_if_t</span><span class=o>&lt;</span> <span class=o>!</span><span class=n>std</span><span class=o>::</span><span class=n>is_void</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;::</span><span class=n>value</span><span class=p>,</span> <span class=n>T</span><span class=o>&gt;&gt;</span> <span class=n>result</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=n>os</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Result(data = &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>result</span><span class=p>.</span><span class=n>data</span> <span class=o>&lt;&lt;</span><span class=s>&#34;, code = &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>result</span><span class=p>.</span><span class=n>code</span> <span class=o>&lt;&lt;</span><span class=s>&#34;, reason = &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>result</span><span class=p>.</span><span class=n>reason</span> <span class=o>&lt;&lt;</span><span class=s>&#34;)&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=n>os</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>In the example, lines 3 and 8 both use type qualification, when in fact we only need to qualify <code>T</code> in the constructor. When instantiating <code>Result</code> with <code>void</code>, it will not compile.</p><h3 id=other-issues class="relative group">Other issues <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#other-issues aria-label=Anchor>#</a></span></h3><p>There are two aspects of C++ templates that need to be addressed, one is the template-related issues and the other is working with other features. For example, C++11 introduced right-valued references, but right-valued references passed through parameters can cause references to collapse, losing their right-valued nature and behaving like normal reference types. This is fine for normal functions, but what if it&rsquo;s a template function? C++ also provides the <strong>perfect forwarding</strong> solution.
Perfect forwarding means that a right-valued reference stays a right-valued reference, and a left-valued reference stays a left-valued reference. It needs to be used in conjunction with universal references. Universal references are very similar to right-valued references, except that the <strong>universal reference type is indeterminate and can only be determined at compile time</strong>. Look at the following example</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>test</span><span class=p>(</span><span class=n>T</span><span class=o>&amp;&amp;</span> <span class=n>p</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;p = &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>forward</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=p>(</span><span class=n>p</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kt>int</span> <span class=n>a</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>test</span><span class=p>(</span><span class=n>a</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>test</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>move</span><span class=p>(</span><span class=n>a</span><span class=p>));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// output
</span></span></span><span class=line><span class=cl><span class=c1>// p = 1
</span></span></span><span class=line><span class=cl><span class=c1>// p = 1
</span></span></span></code></pre></div><p><code>T&&</code> is a universal reference because it is of indeterminate type, and then the arguments are forwarded through <code>std::forward&lt;></code>. As you can see in lines 8 and 9, we successfully pass the left and right values to <code>test</code> and also successfully get the expected result without having to write a separate function for the right value to handle it. This feature of templates greatly simplifies function design and is a lifesaver for API design.
In addition, function templates have the problem of overloading. Generally speaking, the priority of ordinary functions will be higher than the priority of function templates, function templates between the more special will be preferred to match and so on. These problems with the depth of understanding of the template, will slowly appear, but in the early stages of learning there is no need to spend too much effort to understand these features, everything to the main practical.</p><h3 id=summary class="relative group">Summary <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#summary aria-label=Anchor>#</a></span></h3><p>Templates are a big topic in C++, combining the type system, the standard library, classes, and a host of other big topics. So writing perfect template code requires a complete understanding of these topics. Secondly, because the template type control is more relaxed, but also need to developers on the scope of application of the template has a global control, what is prohibited, what types need to be specialization of the treatment, should be considered in place, a little inattention will hide a difficult to detect the bugs.
In short, it is a word, the template is always learning, often used often new, need to learn in practice, but also in the learning of things in practice, I wish you every time there are new gains!</p><h3 id=reference class="relative group">Reference <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#reference aria-label=Anchor>#</a></span></h3><ol><li><a href=https://en.cppreference.com/w/cpp/meta#Type_traits target=_blank rel=noreferrer>type_traints</a></li></ol></div></section><footer class="max-w-prose pt-8 print:hidden"><div class=flex><picture class="!mb-0 !mt-0 me-4 w-24 h-auto rounded-full"><img width=1000 height=1000 class="!mb-0 !mt-0 me-4 w-24 h-auto rounded-full" alt="Deep thinking" loading=lazy decoding=async src=/images/logo_hu1444715804356428735.png srcset="/images/logo_hu10122803172005691567.png 330w,/images/logo_hu1444715804356428735.png 660w
,/images/logo.png 1000w
,/images/logo.png 1000w" sizes=100vw></picture><div class=place-self-center><div class="text-[0.6rem] uppercase leading-3 text-neutral-500 dark:text-neutral-400">Author</div><div class="font-semibold leading-6 text-neutral-800 dark:text-neutral-300">Deep thinking</div><div class="text-2xl sm:text-lg"><div class="flex flex-wrap text-neutral-400 dark:text-neutral-500"><a class="px-1 transition-transform hover:scale-125 hover:text-primary-700 dark:hover:text-primary-400" style=will-change:transform href=mailto:honguilee@163.com target=_blank aria-label=Email rel="me noopener noreferrer"><span class="icon relative inline-block px-1 align-text-bottom"><svg viewBox="0 0 512 512"><path fill="currentcolor" d="M207.8 20.73c-93.45 18.32-168.7 93.66-187 187.1-27.64 140.9 68.65 266.2 199.1 285.1 19.01 2.888 36.17-12.26 36.17-31.49l1e-4-.6631c0-15.74-11.44-28.88-26.84-31.24-84.35-12.98-149.2-86.13-149.2-174.2.0-102.9 88.61-185.5 193.4-175.4 91.54 8.869 158.6 91.25 158.6 183.2v16.16c0 22.09-17.94 40.05-40 40.05s-40.01-17.96-40.01-40.05v-120.1c0-8.847-7.161-16.02-16.01-16.02l-31.98.0036c-7.299.0-13.2 4.992-15.12 11.68-24.85-12.15-54.24-16.38-86.06-5.106-38.75 13.73-68.12 48.91-73.72 89.64-9.483 69.01 43.81 128 110.9 128 26.44.0 50.43-9.544 69.59-24.88 24 31.3 65.23 48.69 109.4 37.49C465.2 369.3 496 324.1 495.1 277.2V256.3c0-149.2-133.9-265.632-287.3-235.57zM239.1 304.3c-26.47.0-48-21.56-48-48.05s21.53-48.05 48-48.05 48 21.56 48 48.05-20.6 48.05-48 48.05z"/></svg>
</span></a><a class="px-1 transition-transform hover:scale-125 hover:text-primary-700 dark:hover:text-primary-400" style=will-change:transform href=https://github.com/hongui target=_blank aria-label=Github rel="me noopener noreferrer"><span class="icon relative inline-block px-1 align-text-bottom"><svg viewBox="0 0 496 512"><path fill="currentcolor" d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6.0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6.0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3.0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1.0-6.2-.3-40.4-.3-61.4.0.0-70 15-84.7-29.8.0.0-11.4-29.1-27.8-36.6.0.0-22.9-15.7 1.6-15.4.0.0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5.0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9.0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4.0 33.7-.3 75.4-.3 83.6.0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6.0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9.0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg></span></a></div></div></div></div><div class=pt-8><hr class="border-dotted border-neutral-300 dark:border-neutral-600"><div class="flex justify-between pt-3"><span><a class="group flex" href=/en/post/Modern%20C++%20Study%20Guide%20-%20Standard%20Library.html><span class="me-2 text-neutral-700 transition-transform group-hover:-translate-x-[2px] group-hover:text-primary-600 dark:text-neutral dark:group-hover:text-primary-400"><span class="ltr:inline rtl:hidden">&larr;</span><span class="ltr:hidden rtl:inline">&rarr;</span></span>
<span class="flex flex-col"><span class="mt-[0.1rem] leading-6 group-hover:underline group-hover:decoration-primary-500">Modern C++ Study Guide - Standard Library</span>
<span class="mt-[0.1rem] text-xs text-neutral-500 dark:text-neutral-400"><time datetime="2022-07-20 22:15:05 +0800 +0800">20 July 2022</time>
</span></span></a></span><span><a class="group flex text-right" href=/en/post/learning%20opengles%20on%20the%20android-fill%20the%20window.html><span class="flex flex-col"><span class="mt-[0.1rem] leading-6 group-hover:underline group-hover:decoration-primary-500">Android OpenGLES learning-draw a color</span>
<span class="mt-[0.1rem] text-xs text-neutral-500 dark:text-neutral-400"><time datetime="2023-05-09 22:14:38 +0800 +0800">9 May 2023</time>
</span></span><span class="ms-2 text-neutral-700 transition-transform group-hover:-translate-x-[-2px] group-hover:text-primary-600 dark:text-neutral dark:group-hover:text-primary-400"><span class="ltr:inline rtl:hidden">&rarr;</span><span class="ltr:hidden rtl:inline">&larr;</span></span></a></span></div></div></footer></article></main><div class="pointer-events-none absolute bottom-0 end-0 top-[100vh] w-12" id=to-top hidden=true><a href=#the-top class="pointer-events-auto sticky top-[calc(100vh-5.5rem)] flex h-12 w-12 items-center justify-center rounded-full bg-neutral/50 text-xl text-neutral-700 backdrop-blur hover:text-primary-600 dark:bg-neutral-800/50 dark:text-neutral dark:hover:text-primary-400" aria-label="Scroll to top" title="Scroll to top">&uarr;</a></div><footer class="py-10 print:hidden"><div class="flex items-center justify-between"><div><p class="text-sm text-neutral-500 dark:text-neutral-400">&copy;
2024
Deep thinking</p><p class="text-xs text-neutral-500 dark:text-neutral-400">Powered by <a class="hover:underline hover:decoration-primary-400 hover:text-primary-500" href=https://gohugo.io/ target=_blank rel="noopener noreferrer">Hugo</a> & <a class="hover:underline hover:decoration-primary-400 hover:text-primary-500" href=https://github.com/jpanther/congo target=_blank rel="noopener noreferrer">Congo</a></p></div><div class="flex flex-row items-center"></div></div></footer><div id=search-wrapper class="invisible fixed inset-0 z-50 flex h-screen w-screen cursor-default flex-col bg-neutral-500/50 p-4 backdrop-blur-sm dark:bg-neutral-900/50 sm:p-6 md:p-[10vh] lg:p-[12vh]" data-url=https://bravebuffalo.cc/en/><div id=search-modal class="top-20 mx-auto flex min-h-0 w-full max-w-3xl flex-col rounded-md border border-neutral-200 bg-neutral shadow-lg dark:border-neutral-700 dark:bg-neutral-800"><header class="relative z-10 flex flex-none items-center justify-between px-2"><form class="flex min-w-0 flex-auto items-center"><div class="flex h-8 w-8 items-center justify-center text-neutral-400"><span class="icon relative inline-block px-1 align-text-bottom"><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="search" class="svg-inline--fa fa-search fa-w-16" role="img" viewBox="0 0 512 512"><path fill="currentcolor" d="M505 442.7 405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9.0 208 0S0 93.1.0 208s93.1 208 208 208c48.3.0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9.0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7.0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7.0 128 57.2 128 128 0 70.7-57.2 128-128 128z"/></svg></span></div><input type=search id=search-query class="mx-1 flex h-12 flex-auto appearance-none bg-transparent focus:outline-dotted focus:outline-2 focus:outline-transparent" placeholder=Search tabindex=0></form><button id=close-search-button class="flex h-8 w-8 items-center justify-center text-neutral-700 hover:text-primary-600 dark:text-neutral dark:hover:text-primary-400" title="Close (Esc)">
<span class="icon relative inline-block px-1 align-text-bottom"><svg viewBox="0 0 320 512"><path fill="currentcolor" d="M310.6 361.4c12.5 12.5 12.5 32.75.0 45.25C304.4 412.9 296.2 416 288 416s-16.38-3.125-22.62-9.375L160 301.3 54.63 406.6C48.38 412.9 40.19 416 32 416S15.63 412.9 9.375 406.6c-12.5-12.5-12.5-32.75.0-45.25l105.4-105.4L9.375 150.6c-12.5-12.5-12.5-32.75.0-45.25s32.75-12.5 45.25.0L160 210.8l105.4-105.4c12.5-12.5 32.75-12.5 45.25.0s12.5 32.75.0 45.25l-105.4 105.4L310.6 361.4z"/></svg></span></button></header><section class="flex-auto overflow-auto px-2"><ul id=search-results></ul></section></div></div></div></body></html>