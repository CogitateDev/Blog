<!doctype html><html lang=en dir=ltr class=scroll-smooth data-default-appearance=light data-auto-appearance=true><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=theme-color content="#FFFFFF"><title>A introduction to Android JNI &#183; Deep thinking</title>
<meta name=title content="A introduction to Android JNI &#183; Deep thinking"><script type=text/javascript src=/js/appearance.min.8a082f81b27f3cb2ee528df0b0bdc39787034cf2cc34d4669fbc9977c929023c.js integrity="sha256-iggvgbJ/PLLuUo3wsL3Dl4cDTPLMNNRmn7yZd8kpAjw="></script><link type=text/css rel=stylesheet href=/css/main.bundle.min.b0785c8131a75f72b211435af86269eb2d4b81dda03a8f2cf5ccb1c967747167.css integrity="sha256-sHhcgTGnX3KyEUNa+GJp6y1Lgd2gOo8s9cyxyWd0cWc="><script defer type=text/javascript id=script-bundle src=/js/main.bundle.min.af5d9722112bedac95702865c340bcd6286c4e9b2c15ce26b531ea1fba974cb8.js integrity="sha256-r12XIhEr7ayVcChlw0C81ihsTpssFc4mtTHqH7qXTLg=" data-copy=Copy data-copied=Copied></script><meta name=description content="
      JNI development concepts
    "><link rel=canonical href=https://bravebuffalo.cc/en/post/Android-JNI-development-introduction.html><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><meta property="og:url" content="https://bravebuffalo.cc/en/post/Android-JNI-development-introduction.html"><meta property="og:site_name" content="Deep thinking"><meta property="og:title" content="A introduction to Android JNI"><meta property="og:description" content="JNI development concepts"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-09-12T21:34:45+08:00"><meta property="article:modified_time" content="2021-09-12T21:34:45+08:00"><meta property="article:tag" content="Android"><meta property="article:tag" content="JNI"><meta property="article:tag" content="C/C++"><meta name=twitter:card content="summary"><meta name=twitter:title content="A introduction to Android JNI"><meta name=twitter:description content="JNI development concepts"><script type=application/ld+json>{"@context":"https://schema.org","@type":"Article","articleSection":"Posts","name":"A introduction to Android JNI","headline":"A introduction to Android JNI","description":"JNI development concepts","abstract":"\u003ch1 id=\u0022what-is-jni\u0022 class=\u0022relative group\u0022\u003eWhat is JNI \u003cspan class=\u0022absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100\u0022\u003e\u003ca class=\u0022group-hover:text-primary-300 dark:group-hover:text-neutral-700\u0022 style=\u0022text-decoration-line: none !important;\u0022 href=\u0022#what-is-jni\u0022 aria-label=\u0022Anchor\u0022\u003e#\u003c\/a\u003e\u003c\/span\u003e\u003c\/h1\u003e\u003cp\u003eThe full name of JNI is Java Native Interface, and as the name suggests, it\u0026rsquo;s a programming method that solves the problem of Java and C\/C\u002b\u002b calling each other. \u003cem\u003e\u003cstrong\u003eIt really only solves two aspects of the problem, how to find and how to access.\u003c\/strong\u003e\u003c\/em\u003e Figure out these two topics and we have learned JNI development.\u003cem\u003e\u003cstrong\u003eIt should be noted that JNI development involves only a small part of the C\/C\u002b\u002b development knowledge, when we encounter a problem we first need to determine whether it is a C\/C\u002b\u002b problem or a JNI problem, which can save a lot of time searching and locating.\u003c\/strong\u003e\u003c\/em\u003e\u003c\/p\u003e","inLanguage":"en","url":"https:\/\/bravebuffalo.cc\/en\/post\/Android-JNI-development-introduction.html","author":{"@type":"Person","name":"Deep thinking"},"copyrightYear":"2021","dateCreated":"2021-09-12T21:34:45\u002b08:00","datePublished":"2021-09-12T21:34:45\u002b08:00","dateModified":"2021-09-12T21:34:45\u002b08:00","keywords":["Android","JNI","C/C++"],"mainEntityOfPage":"true","wordCount":"5634"}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","item":"https://bravebuffalo.cc/en/","name":"Deep Thinking","position":1},{"@type":"ListItem","item":"https://bravebuffalo.cc/en/posts/","name":"Posts","position":2},{"@type":"ListItem","item":"https://bravebuffalo.cc/en/categories/c/c++/","name":"C/C++","position":3},{"@type":"ListItem","name":"A Introduction to Android Jni","position":4}]}</script><meta name=author content="Deep thinking"><link href=mailto:honguilee@163.com rel=me><link href=https://github.com/hongui rel=me></head><body class="m-auto flex h-screen max-w-7xl flex-col bg-neutral px-6 text-lg leading-7 text-neutral-900 dark:bg-neutral-800 dark:text-neutral sm:px-14 md:px-24 lg:px-32"><div id=the-top class="absolute flex self-center"><a class="-translate-y-8 rounded-b-lg bg-primary-200 px-3 py-1 text-sm focus:translate-y-0 dark:bg-neutral-600" href=#main-content><span class="pe-2 font-bold text-primary-600 dark:text-primary-400">&darr;</span>Skip to main content</a></div><header class="py-6 font-semibold text-neutral-900 dark:text-neutral sm:py-10 print:hidden"><nav class="flex items-start justify-between sm:items-center"><div class="flex flex-row items-center"><a href=/en/ class=mr-2><img src=/images/logo.png width=500 height=500 class="max-h-[10rem] max-w-[10rem] object-scale-down object-left" alt="Deep thinking">
</a><a class="decoration-primary-500 hover:underline hover:decoration-2 hover:underline-offset-2" rel=me href=/en/>Deep thinking</a></div><ul class="flex list-none flex-col text-end sm:flex-row"><li class="group mb-1 sm:mb-0 sm:me-7 sm:last:me-0.5"><a href=/en/posts/ title><span class="decoration-primary-500 group-hover:underline group-hover:decoration-2 group-hover:underline-offset-2">Blog</span></a></li><li class="group mb-1 sm:mb-0 sm:me-7 sm:last:me-0.5"><a href=/en/categories/ title><span class="decoration-primary-500 group-hover:underline group-hover:decoration-2 group-hover:underline-offset-2">Categories</span></a></li><li class="group mb-1 sm:mb-0 sm:me-7 sm:last:me-0.5"><a href=/en/tags/ title><span class="decoration-primary-500 group-hover:underline group-hover:decoration-2 group-hover:underline-offset-2">Tags</span></a></li><li class="group mb-1 sm:mb-0 sm:me-7 sm:last:me-0.5"><a href=/en/about.html title><span class="decoration-primary-500 group-hover:underline group-hover:decoration-2 group-hover:underline-offset-2">About</span></a></li><li class="group mb-1 sm:mb-0 sm:me-7 sm:last:me-0.5"><button id=search-button-1 title="Search (/)">
<span class="group-dark:hover:text-primary-400 transition-colors group-hover:text-primary-600"><span class="icon relative inline-block px-1 align-text-bottom"><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="search" class="svg-inline--fa fa-search fa-w-16" role="img" viewBox="0 0 512 512"><path fill="currentcolor" d="M505 442.7 405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9.0 208 0S0 93.1.0 208s93.1 208 208 208c48.3.0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9.0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7.0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7.0 128 57.2 128 128 0 70.7-57.2 128-128 128z"/></svg>
</span></span><span class="decoration-primary-500 group-hover:underline group-hover:decoration-2 group-hover:underline-offset-2"></span></button></li><li class="group mb-1 sm:mb-0 sm:me-7 sm:last:me-0.5"><div class="group relative"><button class="group-dark:hover:text-primary-400 flex w-full items-center justify-end transition-colors group-hover:text-primary-600">
<span class="icon relative inline-block px-1 align-text-bottom"><svg viewBox="0 0 16 16"><path fill="currentcolor" d="M4.545 6.714 4.11 8H3l1.862-5h1.284L8 8H6.833l-.435-1.286H4.545zm1.634-.736L5.5 3.956h-.049l-.679 2.022H6.18z"/><path fill="currentcolor" d="M0 2a2 2 0 012-2h7a2 2 0 012 2v3h3a2 2 0 012 2v7a2 2 0 01-2 2H7a2 2 0 01-2-2v-3H2A2 2 0 010 9V2zm2-1A1 1 0 001 2v7a1 1 0 001 1h7a1 1 0 001-1V2A1 1 0 009 1H2zm7.138 9.995c.193.301.402.583.63.846-.748.575-1.673 1.001-2.768 1.292.178.217.451.635.555.867 1.125-.359 2.08-.844 2.886-1.494.777.665 1.739 1.165 2.93 1.472.133-.254.414-.673.629-.89-1.125-.253-2.057-.694-2.82-1.284.681-.747 1.222-1.651 1.621-2.757H14V8h-3v1.047h.765c-.318.844-.74 1.546-1.272 2.13a6.066 6.066.0 01-.415-.492 1.988 1.988.0 01-.94.31z"/></svg>
</span><span class=text-sm>EN</span><span class=text-[0.6rem]><span class="icon relative inline-block px-1 align-text-bottom"><svg viewBox="0 0 512 512"><path fill="currentcolor" d="M233.4 406.6c12.5 12.5 32.8 12.5 45.3.0l192-192c12.5-12.5 12.5-32.8.0-45.3s-32.8-12.5-45.3.0L256 338.7 86.6 169.4c-12.5-12.5-32.8-12.5-45.3.0s-12.5 32.8.0 45.3l192 192z"/></svg></span></span></button><div class="invisible w-full bg-transparent group-hover:visible"></div><div class="invisible absolute z-50 flex flex-col whitespace-nowrap rounded border border-neutral-300 bg-neutral text-start text-base shadow group-hover:visible ltr:right-0 rtl:left-0 dark:border-neutral-600 dark:bg-neutral-800"><div class="flex flex-grow"><a href=/en/post/Android-JNI-development-introduction.html class="flex w-full items-center justify-between bg-primary-100 px-2 py-1 dark:bg-primary-900">English<span class="ms-2 w-6 text-primary-600 dark:text-primary-400"><span class="icon relative inline-block px-1 align-text-bottom"><svg viewBox="0 0 448 512"><path fill="currentcolor" d="M438.6 105.4c12.5 12.5 12.5 32.7.0 45.2l-256 256c-12.5 12.5-32.7 12.5-45.2.0L9.372 278.6c-12.496-12.5-12.496-32.7.0-45.2 12.498-12.5 32.758-12.5 45.258.0L159.1 338.7 393.4 105.4c12.5-12.52 32.7-12.52 45.2.0h0z"/></svg></span></span></a></div><div class="flex flex-grow"><a href=/post/Android-JNI%E5%BC%80%E5%8F%91%E6%A6%82%E8%AE%BA.html class="w-full py-1 pe-10 ps-2 decoration-primary-500 hover:underline hover:decoration-2 hover:underline-offset-2">简体中文</a></div></div></div></li></ul></nav></header><div class="relative flex grow flex-col"><main id=main-content class=grow><article><header class=max-w-prose><h1 class="mb-8 mt-0 text-4xl font-extrabold text-neutral-900 dark:text-neutral">A introduction to Android JNI</h1><div class="mb-10 text-base text-neutral-500 dark:text-neutral-400 print:hidden"><div class="flex flex-row flex-wrap items-center"><time datetime="2021-09-12 21:34:45 +0800 +0800">12 September 2021</time><span class="px-2 text-primary-500">&#183;</span><span title="Reading time">27 mins</span></div></div></header><section class="prose mt-0 flex max-w-full flex-col dark:prose-invert lg:flex-row"><div class="min-h-0 min-w-0 max-w-prose grow"><h1 id=what-is-jni class="relative group">What is JNI <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#what-is-jni aria-label=Anchor>#</a></span></h1><p>The full name of JNI is Java Native Interface, and as the name suggests, it&rsquo;s a programming method that solves the problem of Java and C/C++ calling each other. <em><strong>It really only solves two aspects of the problem, how to find and how to access.</strong></em> Figure out these two topics and we have learned JNI development.<em><strong>It should be noted that JNI development involves only a small part of the C/C++ development knowledge, when we encounter a problem we first need to determine whether it is a C/C++ problem or a JNI problem, which can save a lot of time searching and locating.</strong></em></p><h1 id=look-at-function-calls-through-the-eyes-of-the-jvm class="relative group">Look at function calls through the eyes of the JVM <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#look-at-function-calls-through-the-eyes-of-the-jvm aria-label=Anchor>#</a></span></h1><p>We know that the Java program can not run alone, it needs to run on the JVM, but the JVM needs to run on the physical machine, so it is a very heavy task, both to deal with the Java code, but also to deal with a variety of operating systems, hardware and other issues. It can be said that understanding the JVM, you understand all of Java, including, of course, JNI. so let&rsquo;s start as a JVM to see how the Java code is running it (just rough content, omitted a lot of steps, in order to highlight the part we care about).</p><p>Before running Java code, a JVM is started.After the JVM is started, some necessary classes are loaded.These classes contain a class called the main class, that is, a method containing a static member function with the function signature <code>public static void main(String[] args)</code>. Once the resources are loaded, the JVM calls the <code>main</code> method of the main class and starts executing Java code. As the code executes, one class relies on another, layer upon layer of dependencies that work together to complete the program&rsquo;s functionality. This is the approximate workflow of the JVM, you can say that the JVM is like a bridge, connecting the Java mountain and native mountain.</p><p>Now the question arises, in a Java program, a class needs to access something outside the JVM via JNI technology, so how does it need to tell me (I am now the JVM)? There needs to be a way to mark normal Java methods as special, and that marking is the <code>native</code> keyword (Kotlin has its own keyword, <code>external</code>, although you can use this keyword when using Kotlin). When I execute the method and see that it is marked differently, I look for the executable elsewhere instead of inside the Class, which is a JNI call. That means that for a Java program, just marking a method as <code>native</code> and calling that method where it is needed will complete the JNI call. But for me, what to do with this one JNI call? <em><strong>Actually the above process of finding the executable is a jump problem, and in the world of C/C++, a jump problem is a pointer problem. So where should this pointer it point to?</strong></em></p><p>C/C++ code is a combination of functions (Java methods will be abbreviated directly to methods below, while C/C++ functions will be abbreviated directly to functions), each of which is a pointer, a property that is just right for my needs. But for me, there is such a big world out there that I don&rsquo;t <code>know where, and what to look for</code>, and the information given to me is still not enough. To limit the scope, I made it so that I would only look for functions loaded via <code>System.loadLibrary("xxx")</code>, the rest I would just strike (throw an error). This instantly lightens my workload, at least I know where to look.</p><p>Having determined the scope, the next step is to determine the real target in this scope.How to uniquely identify a class in the Java world? Some people will blurt out the name of the class, which is not entirely correct, because the class name may be renamed, we need to fully-qualify the class name, that is, the package name plus the name of the class, such as the fully-qualified class name of <code>String</code> is <code>java.lang.String</code>, the class name is <code>java.lang.String</code>. class name is <code>java.lang.String</code>. But what does this have to do with looking up native methods. Of course there is a connection, since a fully qualified class name is unique, then its methods are also unique, so if I stipulate that the fully qualified class name plus the method name of the class is the function name of the native function, then I can find the native function by the way of the function name, the answer is yes, but there is a flaw because the Java system supports method overloading, that is, within a class, a method with the same name can be overloaded with the same name, so that the method will be overloaded with the same name. That is, inside a class, there may be more than one method with the same name. So what is the condition that constitutes overloading, is the parameter list is different. Therefore, the result is obvious, I added the parameter list on the basis of the previous, combined into a lookup conditions, I am not the only one can determine a native function it is JNI static registration.</p><p>However, since I only need to determine where the pointer is pointing, can I just assign a value to the pointer instead of looking it up every time, which I don&rsquo;t know is tiring, but it&rsquo;s still time-consuming. Of course I&rsquo;m satisfied with this kind of need. If you tell me directly, I won&rsquo;t look for it, and I&rsquo;m happy to do so. Moreover, since you have found me, I don&rsquo;t need to lay down so many rules, all let go, you say it is I believe you it is. This is the dynamic registration of JNI.</p><h1 id=jni-function-registration class="relative group">JNI function registration <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#jni-function-registration aria-label=Anchor>#</a></span></h1><p>In the previous section, we learned about the origins of JNI function registration by incarnating the JVM and introduced two types of function registration. From the examples, we can also summarize the characteristics of the two registration methods</p><table><thead><tr><th>Registration Type</th><th>Advantages</th><th>Disadvantages</th><th></th></tr></thead><tbody><tr><td>static registration</td><td>automatic JVM lookups</br>simple to implement</td><td>long, restrictive function names</br>time-consuming lookup</td><td></td></tr><tr><td>dynamic registration</td><td>fast running</br>no restriction on function name</td><td>complex implementation</td><td></td></tr></tbody></table><p>So how exactly do you do it? Let&rsquo;s move on.</p><h2 id=static-registration class="relative group">Static registration <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#static-registration aria-label=Anchor>#</a></span></h2><p>Although static registration is more restrictive, they are shallow rules that are easier to implement, so let&rsquo;s start with static registration first.</p><p>Static registration has clear development steps</p><ol><li>Write Java classes that declare `native&rsquo; methods.</li><li>Use <code>java xxx.java</code> to compile Java source files into class files.</li><li>Use <code>javah xxx</code> to generate the corresponding <code>.h</code> file.</li><li>Introduction of the <code>.h</code> file in the build tool</li><li>Implementation of functions in <code>.h</code> files</li></ol><p>The above steps are the basic steps of static development, but in fact, in front of today&rsquo;s powerful IDE, these do not need us to do it manually, in Android Studio, after defining <code>native</code> method, press <code>alt + enter</code> on the method to generate the correct function signature, and directly write the function logic. But to learn a subject, we still need to take a truthful and realistic attitude, so I will use an example to illustrate these rules to deepen the reader&rsquo;s understanding.</p><p><code>Test.java</code></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kn>package</span><span class=w> </span><span class=nn>me.hongui.demo</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>Test</span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>native</span><span class=w> </span><span class=n>String</span><span class=w> </span><span class=nf>jniString</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p><code>native-lib.cpp</code></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;jni.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>extern</span> <span class=s>&#34;C&#34;</span> <span class=n>jstring</span> <span class=n>Java_me_hongui_demo_Test_jniString</span><span class=p>(</span><span class=n>JNIEnv</span> <span class=o>*</span><span class=n>env</span><span class=p>,</span> <span class=n>jobject</span> <span class=n>thiz</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// TODO: implement jniString()
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><p>The above is an example of a JNI function declared on both ends, and it&rsquo;s not hard to see that the</p><ol><li>Function signatures prefixed with <code>Java_</code></li><li>The prefix is followed by the full path of the class, i.e., it contains the package name and the class name.</li><li><code>_</code> as path separator</li><li>The first argument to a function is always of type <code>JNIEnv *</code>, and the second argument varies according to the type of the function; a method of type <code>static</code> corresponds to type <code>jclass</code>, otherwise it corresponds to type <code>jobject</code>. The type system will be expanded in detail later.</li></ol><p>Why Java method corresponds to C/C++ function, there will be two more parameters. We know that the JVM is multi-threaded, and our JNI methods can be called in any thread, so how to ensure that before and after the call JVM can find the corresponding thread, this is the role of the first parameter of the function, which is a kind of encapsulation of the environment of the thread, and the one-to-one correspondence with the thread, which means that you can not use a thread of the <code>JNIEnv</code> object in another thread. In addition, it is a window for C/C++ to access the Java world, and the vast majority of JNI development is dealing with <code>JNIEnv</code>.</p><h2 id=dynamic-registration class="relative group">Dynamic registration <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#dynamic-registration aria-label=Anchor>#</a></span></h2><p>Again following the development process, let&rsquo;s go through it step by step.
We change the name of the <code>Java_me_hongui_demo_Test_jniString</code> function in the previous section to <code>jniString</code> (of course it&rsquo;s OK if we don&rsquo;t change it, there&rsquo;s no restriction after all), and the parameter list stays the same, and at this point, we find that the Java file reports an error saying that the local method is not implemented. Actually, we did implement it, just that the JVM can&rsquo;t find it. In order for the JVM to find it, we need to register it with the JVM.
So how and where do you register, it seems everywhere and nowhere.
As mentioned earlier, the JVM will only look for libraries loaded via <code>System.loadLibrary("xxx"); </code>, so in order to use a native method, you first have to load the library file that contains the method first, and after that, you can use it. Having loaded the library indicates that the Java program is going to start using native methods. After loading the library, before calling the method, theoretically, you can register the method, but how to determine the timing, JNI has long been arranged for us.JVM in the library loaded into the virtual machine, it will call the function <code>jint JNI_OnLoad(JavaVM *vm, void *reserved)</code>, in order to confirm the version of the JNI, the version of the information will be passed to the JVM in the form of return value The version information will be passed to the JVM as a return value. Currently, the available values are <code>JNI_VERSION_1_1</code>,<code>JNI_VERSION_1_2</code>,<code>JNI_VERSION_1_4</code>,<code>JNI_VERSION_1_6</code>. If the library does not define this function, then the default return is <code>JNI_VERSION_1_1</code> and the library will fail to load, so we usually return the higher version in order to support the latest features. Now that we have such a good time to register, the next step is to implement the registration.</p><p>But things are not that simple. From the <code>JNI_OnLoad</code> function parameter list, it is clear that, at the moment, the only thing available is the JVM, but checking the JVM&rsquo;s API, we don&rsquo;t find a function for registering - the registration function is written inside the <code>JNIEnv</code> class. As it happens, the JVM provides functions to get <code>JNIEnv</code> objects.</p><p>JVM has several functions related to <code>JNIEnv</code>, in Android development, we need to use <code>AttachCurrentThread</code> to get the <code>JNIEnv</code> object, this function will return the execution status, when the return value is equal to <code>JNI_OK</code>, it means that the acquisition is successful. With the <code>JNIEnv</code> object, we can register the function.</p><p>Let&rsquo;s start with the declaration of the register function - <code>jint RegisterNatives(jclass clazz, const JNINativeMethod* methods,jint nMethods</code>. The return value is, needless to say, the same as <code>AttachCurrentThread</code>, indicating the execution state. The difficulty is in the parameters, the first parameter is of type <code>jclass</code> and the second is a pointer to <code>JNINativeMethod</code>, both of which are unseen mains.</p><p>Why do you need so many parameters? Doesn&rsquo;t the JVM only need a function pointer. Or the problem of uniqueness, remember the previous static registration, static registration with a fully qualified type and method, parameter list, return value of the combination to determine the uniqueness of the function. But for dynamic registration, these are all unknown, but necessary. In order to determine these values, it can only be done in other ways. The <code>jclass</code> is the scope of existence of the qualified method, and the way to get the <code>jclass</code> object is simple, using the <code>jclass FindClass(const char* name)</code> function of <code>JNIEnv</code>. The argument needs to be the string-qualified class name, and replace <code>. </code>replaced by <code>/</code>, that is, similar to the form of <code>me/hongui/demo/Test</code>, why write this way, later will take a separate section out of the details.</p><p>The second and third parameters combined are the common form of array parameters. Let&rsquo;s start with the definition of <code>JNINativeMethod</code>.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=p>{</span> 
</span></span><span class=line><span class=cl>    <span class=kt>char</span> <span class=o>*</span><span class=n>name</span><span class=p>.</span> 
</span></span><span class=line><span class=cl>    <span class=kt>char</span> <span class=o>*</span><span class=n>signature</span><span class=p>.</span> 
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=o>*</span><span class=n>fnPtr</span><span class=p>.</span> 
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>JNINativeMethod</span><span class=p>.</span> 
</span></span></code></pre></div><p>There&rsquo;s a trick to writing a function where the correlation is from the Java side to the C/C++ side, in order of definition. The <code>name</code> is the name of the <code>native</code> function that corresponds to the Java side only, this is purely a Java side thing, whatever the name is on the Java side is the name here. The second <code>signature</code> represents the signature of the function, which consists of a list of parameters and a return value, such as <code>(I)Ljava/lang/String;</code>, this signature is related to both sides. First, the <code>native</code> method on the Java side defines the type of the parameter list and the return value, that is, it limits the form of the signature. Secondly, Java&rsquo;s data types need to be converted to C/C++ here, that is, the parameter list and return value need to be written in C/C++ form, which is related to C/C++. The last one, <code>fnPtr</code>, is a function pointer, which is purely C/C++, and represents the C/C++ implementation of the <code>native</code> method on the Java side, that is, the jump pointer mentioned above. Knowing all this, we still can&rsquo;t write code, because, we still have the core of JNI left unsaid, that is, the type system.</p><h1 id=jnis-type-system class="relative group">JNI&rsquo;s type system <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#jnis-type-system aria-label=Anchor>#</a></span></h1><p>The type system of JNI is messy due to the two language systems involved, Java and C/C++, but it is not untraceable. The first thing that needs to be made clear is that both ends have their own type systems, <code>boolean</code>, <code>int</code>, <code>String</code> in Java, <code>bool</code>, <code>int</code>, <code>string</code> and so on in C/C++, which unfortunately don&rsquo;t correspond one to the other. In other words, C/C++ does not recognize Java&rsquo;s types. Since the types are not compatible, how can we call them. This is the problem that JNI is trying to deal with.</p><h2 id=jni-type-mapping class="relative group">JNI type mapping <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#jni-type-mapping aria-label=Anchor>#</a></span></h2><p>In order to solve the problem of type incompatibility, JNI introduces its own type system, which defines types compatible with C/C++, and also specifies the type conversion relationship from Java to C/C++. Here&rsquo;s a table showing how the conversion works</p><table><thead><tr><th>Java Types</th><th>C/C++ Types</th><th>Description</th><th></th></tr></thead><tbody><tr><td>boolean</td><td>jboolean</td><td>unsigned 8 bits</td><td></td></tr><tr><td>byte</td><td>jbyte</td><td>signed 8 bits</td><td></td></tr><tr><td>char</td><td>jchar</td><td>unsigned 16 bits</td><td></td></tr><tr><td>short</td><td>jshort</td><td>signed 16 bits</td><td></td></tr><tr><td>int</td><td>jint</td><td>signed 32 bits</td><td></td></tr><tr><td>long</td><td>jlong</td><td>signed 64 bits</td><td></td></tr><tr><td>float</td><td>jfloat</td><td>32 bits</td><td></td></tr><tr><td>double</td><td>jdouble</td><td>64 bits</td><td></td></tr><tr><td>void</td><td>void</td><td>N/A</td><td></td></tr></tbody></table><p>At first glance, there is nothing special, but just add <code>j</code> prefix (except <code>void</code>), but this is only the basic type, we should not forget that Java is a pure object-oriented language. Complex objects of all kinds are the main battlefield of Java. And with complex objects, things get complicated. We know that in Java, any object is a subclass of the <code>Object</code> class. So can we except the above basic types of all complex types are treated as <code>Object</code> class object to deal with it, but can, but not convenient, such as arrays, strings, exceptions and other common classes, if you do not do the conversion to use the more cumbersome. In order to facilitate our development, JNI will be complex types are divided into the following cases</p><pre tabindex=0><code>jobject (all Java objects)
    |
    |--jclass (java.lang.Class)
    |--jstring (java.lang.String)
    |--jarray (array)
    ||
    || jobjectArray (Object array)
    || jbooleanArray (boolean array)
    || jbyteArray (byte array)
    || jcharArray (char array)
    || jshortArray (short array)
    || jintArray (int array)
    || jlongArray (long array)
    || jfloatArray (float array)
    || jdoubleArray (double array)
    |--jthrowable (java.lang.Throwable exception)
</code></pre><p>The two tables together are the type conversion relationship from the Java side to C/C++. That is to say, when we declare <code>native</code> code in Java, the correspondence between <code>native</code> function parameters and return values is also the correspondence between C/C++ calling Java code parameter passing. But after all, the two systems are still separated, the type system only defines the compatibility way, and does not define the conversion way, the two sides of the parameter still can not recognize each other, so the JNI and a type signature, want to deal with the type of automatic conversion problem.</p><h2 id=type-signatures-for-jni class="relative group">Type signatures for JNI <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#type-signatures-for-jni aria-label=Anchor>#</a></span></h2><p>Type signatures are similar to class type mappings in that there are correspondences, so let&rsquo;s look at a correspondence table.</p><table><thead><tr><th>Type Signatures</th><th>Java Types</th></tr></thead><tbody><tr><td>Z</td><td>boolean</td></tr><tr><td>B</td><td>byte</td></tr><tr><td>C</td><td>char</td></tr><tr><td>S</td><td>short</td></tr><tr><td>I</td><td>int</td></tr><tr><td>J</td><td>long</td></tr><tr><td>F</td><td>float</td></tr><tr><td>D</td><td>double</td></tr><tr><td>L fully-qualified-class ;</td><td>fully-qualified-class</td></tr><tr><td>[type</td><td>type[]</td></tr><tr><td>(arg-types)ret-type</td><td>method type</td></tr></tbody></table><p>For basic types, it&rsquo;s also simple to take the initial letter, except for <code>boolean</code> (the initial letter is taken by <code>byte</code>), and <code>long</code> (the letter is used as a prefix identifier for conforming objects).
The important thing to note is the case of a composite type, i.e., a class. <em><strong>Its signature consists of three parts, the prefix <code>L</code>, the fully qualified name of the type in the middle, followed by the suffix <code>;</code>, all three of which are missing, and the qualifier separator is replaced by a /. Note that type signatures and type systems are not the same concept. Types are usually plain strings that are used by the JVM in places like function registration. A type system is the same as a normal type, where variables can be defined and used as parameter lists by the user. Additionally, array objects have their own type signature, also with the type prefix <code>[</code> followed by the type signature. The final method type, which is what we&rsquo;re going to talk about next, also consists of three parts: the <code>()</code> and the parameter list inside the <code>()</code>, and the return value after the <code>()</code>. All the types used here refer to type signatures.</strong></em></p><p>Let&rsquo;s look at an example.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>long</span> <span class=nf>f</span> <span class=p>(</span><span class=kt>int</span> <span class=n>n</span><span class=p>,</span> <span class=n>String</span> <span class=n>s</span><span class=p>,</span> <span class=n>boolean</span><span class=p>[]</span> <span class=n>arr</span><span class=p>);</span> 
</span></span></code></pre></div><p>How does it write its type signature? Let&rsquo;s analyze it step by step</p><ol><li>Determine its type inside Java, find the correspondence in the table and determine the form of the signature.</li><li>Determine the type of its components using the methodology of step 1.</li><li>Putting together the identified signatures</li></ol><p>This example is a method type, which corresponds to the last item in the table, so the signature is of the form <code>(parameter) return value</code>. The method has three parameters, which we determine one by one in the same way as in step 1.</p><ol><li><code>int n</code> corresponds to the type <code>int</code> and is signed <code>I</code>.</li><li><code>String s</code> corresponds to the type <code>String</code>, which is a composite type corresponding to the penultimate item in the table, so its basic signature takes the form <code>L fully qualified name;</code>. The fully qualified name of <code>String</code>, <code>java.lang.String</code>, becomes <code>java/lang/String</code> after replacing <code>,</code> with <code>/</code>. Putting them together is <code>Ljava/lang/String;</code>, as per step 3.</li><li><code>boolean[] arr</code> corresponds to an array type with a signature of the form <code>[type</code>, and <code>boolean</code> has a signature of <code>Z</code>. Combined they are <code>[Z</code>.</li><li>Finally, the return value, which is of type <code>long</code>, is signed <code>J</code>.</li></ol><p>Combining this information according to the signature form is <code>(ILjava/lang/String;[Z)J</code>, <em><strong>Note that there is no separator between the type signature and the signature, nor is it needed; the type signatures are tightly packed</strong></em>.</p><h1 id=look-again-at-dynamic-registration class="relative group">Look again at dynamic registration <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#look-again-at-dynamic-registration aria-label=Anchor>#</a></span></h1><p>With JNI&rsquo;s type system support, go back and move on to the dynamic registration example and let&rsquo;s go on to refine it.</p><ol><li>Get <code>JNIEnv</code> object with JVM object, i.e. <code>auto status=vm->AttachCurrentThread(&amp;jniEnv, nullptr);</code></li><li>Use the <code>JNIEnv</code> object obtained in step 1 to obtain the <code>jclass</code> object, i.e. <code>auto cls=jniEnv->FindClass("me/hongui/demo/Test");</code></li><li>Define the <code>JNINativeMethod</code> array, i.e. <code>JNINativeMethod methods[]={{"jniString", "()Ljava/lang/String;",reinterpret_cast&lt;void *>(jniString)}} ;</code>, see the previous section for method signatures here.</li><li>Call the <code>RegisterNatives</code> function of <code>JNIEnv</code>. That is, <code>status=jniEnv->RegisterNatives(cls,methods,sizeof(methods)/sizeof(methods[0]));</code>.</li><li>Of course, don&rsquo;t forget to implement the corresponding <code>native</code> function, i.e. here <code>jniString</code> - the third parameter of <code>JNINativeMethod</code>.</li></ol><p>These five steps are the template for the implementation of the <code>JNI_OnLoad</code> function in the dynamic registration, the main changes still come from the <code>jclass</code> to get the parameters and <code>JNINativeMethod</code> signatures, etc., must be strictly one-to-one correspondence. Such as the following example</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>extern</span> <span class=s>&#34;C&#34;</span> <span class=n>jint</span> <span class=n>JNI_OnLoad</span><span class=p>(</span><span class=n>JavaVM</span> <span class=o>*</span><span class=n>vm</span><span class=p>,</span> <span class=kt>void</span> <span class=o>*</span><span class=n>reserved</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=n>JNIEnv</span><span class=o>*</span> <span class=n>jniEnv</span><span class=o>=</span> <span class=k>nullptr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>auto</span> <span class=n>status</span><span class=o>=</span><span class=n>vm</span><span class=o>-&gt;</span><span class=n>AttachCurrentThread</span><span class=p>(</span><span class=o>&amp;</span><span class=n>jniEnv</span><span class=p>,</span> <span class=k>nullptr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>JNI_OK</span><span class=o>==</span><span class=n>status</span><span class=p>){</span>
</span></span><span class=line><span class=cl>        <span class=n>JNINativeMethod</span> <span class=n>methods</span><span class=p>[]</span><span class=o>=</span><span class=p>{{</span><span class=s>&#34;jniString&#34;</span><span class=p>,</span> <span class=s>&#34;() Ljava/lang/String;&#34;</span><span class=p>,</span><span class=k>reinterpret_cast</span><span class=o>&lt;</span><span class=kt>void</span> <span class=o>*&gt;</span><span class=p>(</span><span class=n>jniString</span><span class=p>)}};</span>
</span></span><span class=line><span class=cl>        <span class=k>auto</span> <span class=n>cls</span><span class=o>=</span><span class=n>jniEnv</span><span class=o>-&gt;</span><span class=n>FindClass</span><span class=p>(</span><span class=s>&#34;me/hongui/demo/Test&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>status</span><span class=o>=</span><span class=n>jniEnv</span><span class=o>-&gt;</span><span class=n>RegisterNatives</span><span class=p>(</span><span class=n>cls</span><span class=p>,</span><span class=n>methods</span><span class=p>,</span><span class=k>sizeof</span><span class=p>(</span><span class=n>methods</span><span class=p>)</span><span class=o>/</span><span class=k>sizeof</span><span class=p>(</span><span class=n>methods</span><span class=p>[</span><span class=mi>0</span><span class=p>]));</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span><span class=p>(</span><span class=n>JNI_OK</span><span class=o>==</span><span class=n>status</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>JNI_VERSION_1_6</span><span class=p>.</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>JNI_VERSION_1_1</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h1 id=using-data-in-jni class="relative group">Using data in JNI <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#using-data-in-jni aria-label=Anchor>#</a></span></h1><p>After all the previous grating, it&rsquo;s really only about one thing - how to find it. Although complicated, but the good thing is that there is a trace, the big deal is to run the run. The following to talk about this problem is much more tricky, need a little patience and careful. This part can also be divided into two smaller problems - *** accessing the data of a known object and creating a new object. It is important to mention that the access and creation here are for Java programs, that is, the object exists on the heap of the JVM virtual machine, and our operations are based on the operation of the heap object.*** In C/C++ code, the only way to manipulate heap objects is through the methods provided by <code>JNIenv</code>. So, this part is actually an explanation of the application of <code>JNIenv</code> methods.</p><h2 id=java-object-access class="relative group">Java object access <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#java-object-access aria-label=Anchor>#</a></span></h2><p>When we say accessing an object in the object-oriented world, we usually mean two things; accessing the object&rsquo;s properties, and calling the object&rsquo;s methods. These operations are well implemented in the Java world, but not in the C/C++ world. In the section on JNI&rsquo;s type system, we also learned that complex objects in Java correspond to the class <code>jobject</code> in C/C++, so obviously, no matter how awesome that object is in the Java world, it&rsquo;s treated the same in C/C++. In order to realize C/C++ access to Java&rsquo;s complex objects, combined with the way of accessing objects, <code>JNIEnv</code> provides two major classes of methods, one corresponding to properties and one corresponding to methods. With <code>JNIEnv</code>, C/C++ can realize the goal of accessing objects. There is also a more uniform procedure for using them:</p><ol><li>Prepare the corresponding id (fieldid or methodid) according to the content to be accessed.</li><li>Identification of the objects to be accessed and the data to be invoked</li><li>Object access is accomplished through <code>JNIEnv</code> method calls.</li></ol><p>As you can see, this uses a few more preparation stages (steps 1, 2) than the normal object-oriented approach. As mentioned before, this part of the process requires more patience and care, and less cool maneuvers; after all, there is only so much room to play. This is specifically also reflected in steps 1, 2 above. it is this preparation phase that makes the whole C/C++ code ugly and fragile, but - it&rsquo;s not like it doesn&rsquo;t work, is it?</p><p>Look at an example of a <code>Person</code> class defined in Java with the following class definition</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Java data-lang=Java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nf>Person</span><span class=p>(){</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>age</span><span class=p>.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=n>String</span><span class=w> </span><span class=n>name</span><span class=p>.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>setName</span><span class=p>(</span><span class=n>String</span><span class=w> </span><span class=n>name</span><span class=p>){</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=k>this</span><span class=p>.</span><span class=na>name</span><span class=o>=</span><span class=n>name</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>Now, how do we access the object of this class in our C/C++ code. Suppose we need to read the <code>age</code> value of this object and set the <code>name</code> value of this object. Based on the above steps, we have the following steps</p><ol><li>Prepare the <code>fieldid</code> of <code>age</code> and <code>methodid</code> of <code>setName</code>. According to the methods of <code>JNIEnv</code>, we can see four related ones, two for <code>fieldid</code> and two for <code>methodid</code>, divided into normal and static ones. We&rsquo;re all about the normal ones here, so the methods identified are <code>GetFieldID</code> and <code>GetMethodID</code>. The first parameter is the <code>jclass</code> object, which is retrieved as described earlier, i.e., through the <code>FindClass</code> method of <code>JNIEnv</code>, with the parameter being the fully-qualified class name, with <code>/</code> replacing <code>. </code>. The last two parameters correspond to the name and type signature of the Java side, <code>age</code> belongs to field, <code>int</code> type signature is <code>I</code>, <code>setName</code> belongs to method, the signature form is <code>(parameter) return value</code>, here the signature of the parameter is <code>Ljava/lang/String;</code>, the signature of the return value is <code>V</code>, the combination is <code>. "(Ljava/lang/String;)V"</code>.</li><li>Assuming we already have the <code>Person</code> object <code>obj</code>, passed through Java.</li><li>Two methods need to be called, <code>age</code> is a plastic attribute, to get its value, the corresponding <code>GetIntField</code> method needs to be used. <code>setName</code> is a method that returns a <code>void</code> value. So <code>CallVoidMethod</code> should be used.</li></ol><p>The above analysis leads to the following sample code.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>auto</span> <span class=n>cls</span><span class=o>=</span><span class=n>jniEnv</span><span class=o>-&gt;</span><span class=n>FindClass</span><span class=p>(</span><span class=s>&#34;me/hongui/demo/Person&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>auto</span> <span class=n>ageId</span><span class=o>=</span><span class=n>jniEnv</span><span class=o>-&gt;</span><span class=n>GetFieldID</span><span class=p>(</span><span class=n>cls</span><span class=p>,</span> <span class=s>&#34;age&#34;</span><span class=p>,</span> <span class=s>&#34;I&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>auto</span> <span class=n>nameId</span><span class=o>=</span><span class=n>jniEnv</span><span class=o>-&gt;</span><span class=n>GetMethodID</span><span class=p>(</span><span class=n>cls</span><span class=p>,</span> <span class=s>&#34;setName&#34;</span><span class=p>,</span><span class=s>&#34;(Ljava/lang/String;)V&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>jint</span> <span class=n>age</span><span class=o>=</span><span class=n>jniEnv</span><span class=o>-&gt;</span><span class=n>GetIntField</span><span class=p>(</span><span class=n>obj</span><span class=p>,</span><span class=n>ageId</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>auto</span> <span class=n>name</span><span class=o>=</span><span class=n>jniEnv</span><span class=o>-&gt;</span><span class=n>NewStringUTF</span><span class=p>(</span><span class=s>&#34;ZhangSan&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>jniEnv</span><span class=o>-&gt;</span><span class=n>CallVoidMethod</span><span class=p>(</span><span class=n>obj</span><span class=p>,</span><span class=n>nameId</span><span class=p>,</span><span class=n>name</span><span class=p>);</span>
</span></span></code></pre></div><p>From the analysis and examples above, patience and attentiveness are mainly reflected in the</p><ol><li>Be patient in determining the type and name of the property or method to be accessed, and keep the types in the three steps identical. That is, the type of the call to <code>GetFieldID</code> should be consistent with the type of <code>GetXXXField</code>, and the same goes for the method.</li><li>Be careful with static and non-static modifiers of properties or methods, as static ones usually require the use of a method with the <code>static</code> keyword, while normal ones do not. For example, <code>GetStaticIntField</code> corresponds to getting the value of a static integer attribute, while <code>GetIntField</code> gets the value of an integer attribute of a normal object.</li><li>Attribute-related set methods are of the form <code>SetXField</code>, where <code>X</code> stands for the specific type, corresponding to the type in the previous type system, or <code>Object</code> in the case of complex objects, as in <code>SetObjectField</code>. Accessing a property is simply a matter of replacing the prefix <code>Set</code> with <code>Get</code>. For static properties, a fixed <code>Static</code> is added between <code>Set</code> and <code>X</code>, i.e. <code>SetStaticIntField</code>.</li><li>Method calls are prefixed with <code>Call</code> followed by the type of return value, in the form of <code>CallXMethod</code>. Here <code>X</code> stands for the return value. For example, <code>CallVoidMethod</code> calls a method of an object whose return value is of type <code>void</code>. The equivalent static method is <code>Static</code> between <code>Call</code> and <code>X</code>, as in <code>CallStaticVoidMethod</code>.</li></ol><h2 id=passing-data-to-the-java-world class="relative group">Passing data to the Java world <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#passing-data-to-the-java-world aria-label=Anchor>#</a></span></h2><p>Passing data to the Java world requires even more patience. Because we need to keep constructing objects, combining them, and setting properties. And each of these is a form of access to the Java object above.</p><h3 id=constructing-java-objects class="relative group">Constructing Java objects <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#constructing-java-objects aria-label=Anchor>#</a></span></h3><p>C/C++ constructs Java objects and calls methods similarly. However, there are still a lot of details worth paying attention to. According to the previous method, we construct the object, first we need to know the id of the constructor method, and to get the id, we need to get <code>jclass</code>, the name and signature of the constructor method. We know that in the Java world, the constructor method has the same name as the class, but this is not the case in C/C++, it has a special name - <code>&lt;init></code>, note that <code>&lt;></code> can&rsquo;t be missing here. <em><strong>That means that no matter what the class is called, the name of its constructor is <code>&lt;init></code>.</strong></em> And the key point of the function signature is the return value, the return value of the constructor method is <code>void</code> which corresponds to the signature type <code>V</code>.</p><p>Picking up on the previous example of the <code>Person</code> class, how do you construct a <code>Person</code> object.</p><ol><li>Get the <code>jclass</code> object by <code>FindClass</code> of <code>JNIEnv</code>. Remember to replace <code>'</code> with <code>/</code>.</li><li>Get the appropriate id of the constructor method as needed. i don&rsquo;t define a constructor method, then the compiler will provide it with a constructor method with no parameters. That is, the function signature is <code>()V</code>. Call <code>GetMethodID</code> of <code>JNIEnv</code> to get the id.</li><li>Call <code>NewObject</code> of <code>JNIEnv</code> to create the object, remember to pass the constructor parameter. I don&rsquo;t need to pass it here.</li></ol><p>To summarize, this creation process is similar to the following example</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>auto</span> <span class=n>cls</span><span class=o>=</span><span class=n>env</span><span class=o>-&gt;</span><span class=n>FindClass</span><span class=p>(</span><span class=s>&#34;me/hongui/demo/Person&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>auto</span> <span class=n>construct</span><span class=o>=</span><span class=n>env</span><span class=o>-&gt;</span><span class=n>GetMethodID</span><span class=p>(</span><span class=n>cls</span><span class=p>,</span><span class=s>&#34;&lt;init&gt;&#34;</span><span class=p>,</span><span class=s>&#34;()V&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>auto</span> <span class=n>age</span><span class=o>=</span><span class=n>env</span><span class=o>-&gt;</span><span class=n>GetFieldID</span><span class=p>(</span><span class=n>cls</span><span class=p>,</span> <span class=s>&#34;age&#34;</span><span class=p>,</span> <span class=s>&#34;I&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>auto</span> <span class=n>name</span><span class=o>=</span><span class=n>env</span><span class=o>-&gt;</span><span class=n>GetFieldID</span><span class=p>(</span><span class=n>cls</span><span class=p>,</span> <span class=s>&#34;name&#34;</span><span class=p>,</span> <span class=s>&#34;Ljava/lang/String;&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>auto</span> <span class=n>p</span><span class=o>=</span><span class=n>env</span><span class=o>-&gt;</span><span class=n>NewObject</span><span class=p>(</span><span class=n>cls</span><span class=p>,</span><span class=n>construct</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>auto</span> <span class=n>nameValue</span><span class=o>=</span><span class=n>env</span><span class=o>-&gt;</span><span class=n>NewStringUTF</span><span class=p>(</span><span class=s>&#34;ZhangSan&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>env</span><span class=o>-&gt;</span><span class=n>SetIntField</span><span class=p>(</span><span class=n>p</span><span class=p>,</span><span class=n>age</span><span class=p>,</span><span class=mi>18</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>env</span><span class=o>-&gt;</span><span class=n>SetObjectField</span><span class=p>(</span><span class=n>p</span><span class=p>,</span><span class=n>name</span><span class=p>,</span><span class=n>nameValue</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>return</span> <span class=n>p</span>
</span></span></code></pre></div><p>The above example has an interesting point, in fact the example creates two Java objects, one is <code>Person</code> object and the other is <code>String</code> object. Since the probability of a <code>String</code> exit is too high in programming, JNI provides this easy way. Also special is the creation of array objects. And because the type of the array is uncertain, there are multiple versions of the creation method, such as <code>NewIntArray</code> for creating an integer array. The method signatures are also quite regular, all in the form of <code>NewX Array</code>, where <code>X</code> stands for the type of the array, and all of these methods take one parameter, the size of the array. Since we are mentioning arrays, the methods for setting arrays have to be mentioned. There are methods for setting the value of an array element, in the form of <code>SetXArrayRegion</code>, such as <code>SetIntArrayRegion</code> which sets the value of an integer array element. Unlike the Java world, these methods support setting multiple values at the same time. The signature of an integer array looks like this - <code>void SetIntArrayRegion(jintArray array,jsize start, jsize len,const jint* buf)</code> The second parameter represents the start index of the set value, the third parameter is the number, and the fourth argument is a pointer to the true value. The rest of the types are similar.</p><h2 id=take-data-access-a-step-further class="relative group">Take data access a step further <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#take-data-access-a-step-further aria-label=Anchor>#</a></span></h2><p>There are times when we don&rsquo;t access an object when we call a <code>native</code> method, but sometime in the future. This is well realized in the Java world, where there is always a suitable class to hold the object reference passed in during this call, and it can be used directly at a later time. Is it the same in the <code>native</code> world? It&rsquo;s the same in terms of usage flow, but it&rsquo;s very different in terms of implementation.</p><p>The Java world has GC, which means that after passing some temporary object <code>X</code> to some object <code>Y</code>, the life cycle of <code>X</code> is transferred to <code>Y</code>, and <code>X</code> is not destroyed at the end of the call, but is recycled together with <code>Y</code> when <code>Y</code> is recycled. This approach is fine in the pure Java world, but when we pass this temporary object <code>X</code> to the <code>native</code> world and try to get it to work as it does in the Java world, the application crashes, reporting the error <code>JNI DETECTED ERROR IN APPLICATION: native code passing in JNI DETECTED ERROR IN APPLICATION: native code passing in reference to invalid stack indirect reference table or invalid reference: 0xxxxx</code>. Why does the same operation work in Java but not in <code>native</code>? The root of the problem is Java&rsquo;s GC, which can determine whether an object needs to be marked as garbage through various garbage detection algorithms. In the <code>native</code> world, there is no GC, so in order not to cause memory leaks, you have to adopt the strictest policy, <strong>where the <code>native</code> method is called by default is where the Java object is used</strong>. So at the end of the scope of the <code>native</code> method call, the temporary object is marked as garbage by the GC, and if you want to use it again later, it may already be recycled. Luckily, the powerful <code>JNIEnv</code> class also provides methods for us to change this default strategy - <code>NewGlobalRef</code>. All an object needs to do is tell the JVM that it wants to live a little longer in this way, and the JVM will not mark it as garbage when performing garbage detection, and the object will live on. In until <code>DeleteGlobalRef</code> is called.<em><strong>Here <code>NewGlobalRef</code>, <code>DeleteGlobalRef</code> are one-to-one correspondence, and it is better to call <code>DeleteGlobalRef</code> to free memory when the object is no longer needed to avoid memory leaks</strong></em>.</p><h1 id=summary class="relative group">Summary <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#summary aria-label=Anchor>#</a></span></h1><p><em><strong>JNI development will involve knowledge of Java and C/C++ development, in the C/C++ implementation of JNI, the basic idea is to use C/C++ syntax to write Java logic, that is, everything for the service of Java.JNI development process, the main two issues to be dealt with, function registration and data access.</strong></em></p><p>Function registration is recommended to use dynamic registration, use <code>RegisterNatives</code> of <code>JNIEnv</code> to register the function in <code>JNI_OnLoad</code> function, pay attention to keep the consistency of Java&rsquo;s <code>native</code> methods and type signatures, and don&rsquo;t forget to prefix the prefix <code>L</code>, suffix <code>;</code> for composite types, and replace <code>. </code>for <code>/</code>.</p><p>Data access first needs to determine the access period, objects that need to be accessed in multiple places or at different times, remember to use <code>NewGlobalRef</code> to prevent the object from being recycled, and of course remember <code>DeleteGlobalRef</code>. To access an object, you need to get the id of the object and then determine the access method based on the type of access. Setting a property is usually in the form of <code>SetXField</code> and getting the value of a property is usually in the form of <code>GetXField</code>. To call a method, you need to determine the calling method based on the type of the return value, usually in the form of <code>CallXMethod</code>. Of course, all these are for normal objects, if you need to access static properties or methods, you add <code>Static</code> in front of the normal version of <code>X</code>. All <code>X</code>s here refer to types, except for basic types, where <code>Object</code> is substituted.</p><p>When registering functions and accessing data, one of the things you need to keep an eye on is the data type; C/C++ data types, except for the basic types, cannot be passed directly to Java, but need to be passed by creating an object. The general object creation method <code>NewObject</code> can create any object, and there are quick methods <code>NewStringUTF</code> and <code>NewXArray</code> for strings and arrays, which are frequently used. These two methods are essential for passing strings and arrays to Java.</p><p>This all,we will see you in the next post!</p></div></section><footer class="max-w-prose pt-8 print:hidden"><div class=flex><picture class="!mb-0 !mt-0 me-4 w-24 h-auto rounded-full"><img width=1000 height=1000 class="!mb-0 !mt-0 me-4 w-24 h-auto rounded-full" alt="Deep thinking" loading=lazy decoding=async src=/images/logo_hu1444715804356428735.png srcset="/images/logo_hu10122803172005691567.png 330w,/images/logo_hu1444715804356428735.png 660w
,/images/logo.png 1000w
,/images/logo.png 1000w" sizes=100vw></picture><div class=place-self-center><div class="text-[0.6rem] uppercase leading-3 text-neutral-500 dark:text-neutral-400">Author</div><div class="font-semibold leading-6 text-neutral-800 dark:text-neutral-300">Deep thinking</div><div class="text-2xl sm:text-lg"><div class="flex flex-wrap text-neutral-400 dark:text-neutral-500"><a class="px-1 transition-transform hover:scale-125 hover:text-primary-700 dark:hover:text-primary-400" style=will-change:transform href=mailto:honguilee@163.com target=_blank aria-label=Email rel="me noopener noreferrer"><span class="icon relative inline-block px-1 align-text-bottom"><svg viewBox="0 0 512 512"><path fill="currentcolor" d="M207.8 20.73c-93.45 18.32-168.7 93.66-187 187.1-27.64 140.9 68.65 266.2 199.1 285.1 19.01 2.888 36.17-12.26 36.17-31.49l1e-4-.6631c0-15.74-11.44-28.88-26.84-31.24-84.35-12.98-149.2-86.13-149.2-174.2.0-102.9 88.61-185.5 193.4-175.4 91.54 8.869 158.6 91.25 158.6 183.2v16.16c0 22.09-17.94 40.05-40 40.05s-40.01-17.96-40.01-40.05v-120.1c0-8.847-7.161-16.02-16.01-16.02l-31.98.0036c-7.299.0-13.2 4.992-15.12 11.68-24.85-12.15-54.24-16.38-86.06-5.106-38.75 13.73-68.12 48.91-73.72 89.64-9.483 69.01 43.81 128 110.9 128 26.44.0 50.43-9.544 69.59-24.88 24 31.3 65.23 48.69 109.4 37.49C465.2 369.3 496 324.1 495.1 277.2V256.3c0-149.2-133.9-265.632-287.3-235.57zM239.1 304.3c-26.47.0-48-21.56-48-48.05s21.53-48.05 48-48.05 48 21.56 48 48.05-20.6 48.05-48 48.05z"/></svg>
</span></a><a class="px-1 transition-transform hover:scale-125 hover:text-primary-700 dark:hover:text-primary-400" style=will-change:transform href=https://github.com/hongui target=_blank aria-label=Github rel="me noopener noreferrer"><span class="icon relative inline-block px-1 align-text-bottom"><svg viewBox="0 0 496 512"><path fill="currentcolor" d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6.0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6.0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3.0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1.0-6.2-.3-40.4-.3-61.4.0.0-70 15-84.7-29.8.0.0-11.4-29.1-27.8-36.6.0.0-22.9-15.7 1.6-15.4.0.0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5.0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9.0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4.0 33.7-.3 75.4-.3 83.6.0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6.0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9.0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg></span></a></div></div></div></div><div class=pt-8><hr class="border-dotted border-neutral-300 dark:border-neutral-600"><div class="flex justify-between pt-3"><span><a class="group flex" href=/en/post/Personal%20understanding%20and%20useage%20of%20CMake.html><span class="me-2 text-neutral-700 transition-transform group-hover:-translate-x-[2px] group-hover:text-primary-600 dark:text-neutral dark:group-hover:text-primary-400"><span class="ltr:inline rtl:hidden">&larr;</span><span class="ltr:hidden rtl:inline">&rarr;</span></span>
<span class="flex flex-col"><span class="mt-[0.1rem] leading-6 group-hover:underline group-hover:decoration-primary-500">Personal understanding and useage of CMake</span>
<span class="mt-[0.1rem] text-xs text-neutral-500 dark:text-neutral-400"><time datetime="2021-08-09 19:21:49 +0800 +0800">9 August 2021</time>
</span></span></a></span><span><a class="group flex text-right" href=/en/post/horizontal%20scrolling%20tabs%20with%20plain%20HTML,%20JS,%20CSS.html><span class="flex flex-col"><span class="mt-[0.1rem] leading-6 group-hover:underline group-hover:decoration-primary-500">horizontal scrolling tabs with plain HTML, JS, CSS</span>
<span class="mt-[0.1rem] text-xs text-neutral-500 dark:text-neutral-400"><time datetime="2022-02-12 09:23:30 +0800 +0800">12 February 2022</time>
</span></span><span class="ms-2 text-neutral-700 transition-transform group-hover:-translate-x-[-2px] group-hover:text-primary-600 dark:text-neutral dark:group-hover:text-primary-400"><span class="ltr:inline rtl:hidden">&rarr;</span><span class="ltr:hidden rtl:inline">&larr;</span></span></a></span></div></div></footer></article></main><div class="pointer-events-none absolute bottom-0 end-0 top-[100vh] w-12" id=to-top hidden=true><a href=#the-top class="pointer-events-auto sticky top-[calc(100vh-5.5rem)] flex h-12 w-12 items-center justify-center rounded-full bg-neutral/50 text-xl text-neutral-700 backdrop-blur hover:text-primary-600 dark:bg-neutral-800/50 dark:text-neutral dark:hover:text-primary-400" aria-label="Scroll to top" title="Scroll to top">&uarr;</a></div><footer class="py-10 print:hidden"><div class="flex items-center justify-between"><div><p class="text-sm text-neutral-500 dark:text-neutral-400">&copy;
2024
Deep thinking</p><p class="text-xs text-neutral-500 dark:text-neutral-400">Powered by <a class="hover:underline hover:decoration-primary-400 hover:text-primary-500" href=https://gohugo.io/ target=_blank rel="noopener noreferrer">Hugo</a> & <a class="hover:underline hover:decoration-primary-400 hover:text-primary-500" href=https://github.com/jpanther/congo target=_blank rel="noopener noreferrer">Congo</a></p></div><div class="flex flex-row items-center"></div></div></footer><div id=search-wrapper class="invisible fixed inset-0 z-50 flex h-screen w-screen cursor-default flex-col bg-neutral-500/50 p-4 backdrop-blur-sm dark:bg-neutral-900/50 sm:p-6 md:p-[10vh] lg:p-[12vh]" data-url=https://bravebuffalo.cc/en/><div id=search-modal class="top-20 mx-auto flex min-h-0 w-full max-w-3xl flex-col rounded-md border border-neutral-200 bg-neutral shadow-lg dark:border-neutral-700 dark:bg-neutral-800"><header class="relative z-10 flex flex-none items-center justify-between px-2"><form class="flex min-w-0 flex-auto items-center"><div class="flex h-8 w-8 items-center justify-center text-neutral-400"><span class="icon relative inline-block px-1 align-text-bottom"><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="search" class="svg-inline--fa fa-search fa-w-16" role="img" viewBox="0 0 512 512"><path fill="currentcolor" d="M505 442.7 405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9.0 208 0S0 93.1.0 208s93.1 208 208 208c48.3.0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9.0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7.0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7.0 128 57.2 128 128 0 70.7-57.2 128-128 128z"/></svg></span></div><input type=search id=search-query class="mx-1 flex h-12 flex-auto appearance-none bg-transparent focus:outline-dotted focus:outline-2 focus:outline-transparent" placeholder=Search tabindex=0></form><button id=close-search-button class="flex h-8 w-8 items-center justify-center text-neutral-700 hover:text-primary-600 dark:text-neutral dark:hover:text-primary-400" title="Close (Esc)">
<span class="icon relative inline-block px-1 align-text-bottom"><svg viewBox="0 0 320 512"><path fill="currentcolor" d="M310.6 361.4c12.5 12.5 12.5 32.75.0 45.25C304.4 412.9 296.2 416 288 416s-16.38-3.125-22.62-9.375L160 301.3 54.63 406.6C48.38 412.9 40.19 416 32 416S15.63 412.9 9.375 406.6c-12.5-12.5-12.5-32.75.0-45.25l105.4-105.4L9.375 150.6c-12.5-12.5-12.5-32.75.0-45.25s32.75-12.5 45.25.0L160 210.8l105.4-105.4c12.5-12.5 32.75-12.5 45.25.0s12.5 32.75.0 45.25l-105.4 105.4L310.6 361.4z"/></svg></span></button></header><section class="flex-auto overflow-auto px-2"><ul id=search-results></ul></section></div></div></div></body></html>