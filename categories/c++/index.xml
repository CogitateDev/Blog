<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>C++ on 低头沉思</title><link>https://hongui.github.io/categories/c++/</link><description>Recent content in C++ on 低头沉思</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Wed, 20 Jul 2022 22:15:05 +0800</lastBuildDate><atom:link href="https://hongui.github.io/categories/c++/index.xml" rel="self" type="application/rss+xml"/><item><title>现代C++学习指南-标准库</title><link>https://hongui.github.io/post/%E7%8E%B0%E4%BB%A3C++%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97-%E6%A0%87%E5%87%86%E5%BA%93.html</link><pubDate>Wed, 20 Jul 2022 22:15:05 +0800</pubDate><guid>https://hongui.github.io/post/%E7%8E%B0%E4%BB%A3C++%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97-%E6%A0%87%E5%87%86%E5%BA%93.html</guid><description>在[上一章]( https://www.yuque.com/docs/share/adb5b1e4-f3c6-46fd-ba4b-4dabce9b4f2a?# 《现代C++学习指南-类型系统》)我们探讨了C++的类型系统，并提出了从低到高，又从高到低的学习思路，本文就是一篇从高到低的学习指南，希望能提供一种新的视角。
什么是标准库 编程语言一般分为两个部分，一部分是语法部分，如上一章的类型系统，另一部分则是用这套语法完成的预定义的工具集，如本文的主题——标准库。标准库是一堆我们写代码时直接可以用的代码，就像是我们提前写好的一样，不仅如此，标准库还是跨平台的，还是经过工业级测试的，所以标准库有着靠谱，安全的特点。 C++标准库包括很多方面，有类vector、string等,有对象std::cin，std::cout等，还有函数move，copy等，所以一般按功能来对它们分类
容器类 算法类 智能指针 线程相关 其他 当然，这些还不是全部，标准库是在不断扩充和完善的，学习标准库的宗旨也应该是学习它们的使用场景，而不是深入用法。比如容器类中就有很多功能类似的类，不同的业务场景有不同的选择。通过对它们的了解，我们更容易写出高效，简洁的代码。
容器类 容器类就是帮助管理一组数据的类，根据实现方式的不同，分为有序列表，无序列表和映射。 有序列表中的有序是指，数据组保存在一块连续的内存区域里，可以通过插入时的索引直接定位到原数据。因为数据是按顺序存入的，所以中途假如需要删除或者新增数据，在操作位置右边的数据都需要移动，操作的代价就比较大。由此也可看出它们的优势是顺序插入和尾部修改，还有直接查找，这方面的代表就是array，vector。 array是对原始数组的封装，并且解决了传递数组变成指针这样的问题，但是缺点是它的大小是固定的，适合用在数据量已知的情况。而vector又是对array的增强，不仅能完成所有array的操作，并且大小可变，所以绝大部分情况下，选择vector都是理想的选择。 无序列表的元素是单独存储的，相互之间用指针来查找相邻元素，由于指针可以轻易修改指向的指，所以对相邻元素的修改就变得很快捷。同样的道理，查找相邻元素只能靠指针跳转，查找某个值需要从一个指针开始查找，一次跳转一条数据，直到找到目标或者没有数据为止。所以无序列表的优势是快速地删除和插入新数据，不适合查找，其代表有list，forward_list。显然，有序列表和无序列表是互补的，我们在实际项目中，应该根据数据的操作来确定选择哪种容器。 映射则融合了有序列表和无序列表的优点，既可以快速插入和删除，又可以快速查找。为了满足各种使用场景，C++提供了map，multimap，unordered_map，unordered_multimap。从名字上就能看出来它们的差别。为了直观，我直接列了一个表
是否排序 是否支持相同值 速度 unordered_map ❌ ❌ ❤️❤️❤️❤️ map ✅ ❌ ❤️❤️ multimap ✅ ✅ ❤️ unordered_multimap ✅ ✅ ❤️❤️❤️ 映射存储的是两个值，不同的类型实现方式不一样。由于map是需要排序的，所以通常它的实现是一种平衡二叉树，键就是它排序的依据。 而unordered_map是不需要排序的，所以它的实现通常是哈希表，即根据哈希函数的确定索引位置继而确定存储位置。 综上，容器类提供了一种操作多个同类型数据的接口，开发者通过对容器类方法的调用，可以实现对容器内数据的增删改查。大部分情况下，vector都是靠谱的选择，它提供了全功能的数据操作接口，支持动态长度，索引查询，并且简单高效。如果需要频繁地插入或者删除操作，也可以考虑list或者forward_list。map可以让数据保持有序，需要更快的速度而不是排序的话unorderer_map是更好的选择，如果相同值会出现多次就可以使用对应的multi版本。另外容器类也是很好的数据结构学习资源，C++的容器类几乎提供了数据结构中所有的形式，对数据结构越熟悉选择的容器类就越完美。
算法 之所以将算法放在容器类后面，是因为算法大部分是对容器类操作的加强，算法都定义在algorithm文件头里。这些算法都是短小精悍的，可以大大增加代码可读性，并且妥善处理了很多容易遗忘的边界问题。功能上可以分为增删改查几种操作，可以在实际有需要的时候在查看文档，具体可以参阅 这里 智能指针 很早以前，我对智能指针的态度不是很好。因为刚开始学习C++时我就知道，不能单独使用指针，要把指针封装在类里，利用类的构造函数和析构函数管理指针，也就是RAII。最开始我以为这就够了,直到我遇到下面这种情况
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 public: Ptr():p{ new int } {} ~Ptr() { delete p; } int&amp;amp; get() { return *p; } void set(const int value) { *p = value; } private: int* p; }; void use(Ptr p) { //传进来的是复制构造出来的p&amp;#39;,函数返回后p&amp;#39;被销毁啦，两个指针指向的地址被回收，外面的p指针成为了野指针 } int main() { Ptr p; p.</description></item><item><title>现代C++学习指南-类型系统</title><link>https://hongui.github.io/post/%E7%8E%B0%E4%BB%A3C++%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97-%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F.html</link><pubDate>Sun, 26 Jun 2022 11:11:59 +0800</pubDate><guid>https://hongui.github.io/post/%E7%8E%B0%E4%BB%A3C++%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97-%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F.html</guid><description>在前一篇，我们提供了一个方向性的指南，但是学什么，怎么学却没有详细展开。本篇将在前文的基础上，着重介绍下怎样学习C++的类型系统。
写在前面 在进入类型系统之前，我们应该先达成一项共识——尽可能使用C++的现代语法。众所周知，出于兼容性的考虑，C++中很多语法都是合法的。但是随着新版本的推出，有些语法可能是不推荐或者是需要避免使用的。所以本篇也尽可能采用推荐的语法形式（基于C++11或以上版本），这也是现代C++标题的含义。 采用现代语法有两点好处。其一，现代语法可以编译出更快更健壮的代码。编译器也是随着语言的发展而发展的，现代语法可以在一定程度上帮助编译器做更好的优化。其二，现代语法通常更简洁，更直观，也更统一，有助于增强可读性和可维护性。 明确了这点后，让我们一起踏入现代C++的大门吧。
类型系统 程序是一种计算工具，根据输入，和预定义的计算方法，产生计算结果。当程序运行起来后，这三者都需要在内存中表示成合适的值才能让程序正常工作，负责解释的这套工具就是类型系统。数字，字符串，键盘鼠标事件等都是数据，而且在内存中实际存在的形式也是一样的，但是按我们人类的眼光来看的话，对它们的处理是不一样的。数字能进行加减乘除等算术运算，但是对字符串进行算术运算就没有意义，而键盘鼠标的值通常只是读取，不进行计算的。正是由于这些差异，编程语言的第一个任务就是需要定义一套类型系统，告诉计算机怎样处理内存中的数据。 为了让编程语言尽可能简单，编程语言一般把类型系统分为两步实现，一部分是编译器，另一部分是类型。编译器那部分负责将开发者的代码解释成合适的形式，以便可以高效，准确在内存中表示。类型部分则定义一些编译器能处理的类型，以便开发者可以找到合适的数据来完成输入输出的表示和计算方法的描述。这两者相辅相成，相互成就。 类型作为类型系统的重要表现形式，在编程语言中的重要性也就不言而喻了。如果把写程序看成是搭积木的话，那么程序的积木就是类型系统。类型系统是开发者能操作的最小单位，它限制了开发者的操作规则，但是提供了无限的可能。C++有着比积木更灵活的类型系统。
类型 :::info 类型是编程语言的最小单位，任何一句代码都是一种内存使用形式。 ::: 而谈到C++的类型也就不得不谈到它的三种类型表现形式——普通类型，指针，引用。它们是三种不同的内存使用和解释形式，也是C++的最基础的形式。和大部分编程语言不同，C++对内置类型没有做特权处理，只要开发者愿意，所有的类型都可以有一致的语法形式（通过运算符重载），所以下面关于类型的举例适合所有的类型。 普通类型就是没有修饰的类型，如int,long,double等。它们是按值传递的，也就是赋值和函数传参是拷贝一份值，对拷贝后的值进行操作，不会再影响到老值。
1 2 3 4 int a=1; //老值,存在地址1 int b=a; //新值，存在地址2 b=2; //改变新值，改变地址2 //此时a还是1，b变成了2 那假如我们需要修改老值呢，有两种途径，一种是指针，另一种则是引用。 指针是C/C++里面的魔法，一切皆可指针。指针包含两个方面，一方面它是指一块内存，另一方面它可以指允许对这块内存进行的操作。指针的值是一块内存地址，操作指针，操作的是它指向的那块地址。
1 2 3 4 int a=1; //老值,存在地址1 int* b=&amp;amp;a; //&amp;amp;代表取地址，从右往左读，取a的地址——地址1，存在地址2 *b=2; //*是解引用，意思是把存在地址2(b)的值取出来，并把那个地址（地址1）的值改成2 //此时a，*b变成了2 引用则是指针的改进版，引用能避免无效引用，不过引用不能重设，比指针缺少一定的灵活性。
1 2 3 4 int a=1; //老值,存在地址1 int&amp;amp; b=a; //&amp;amp;出现在变量声明的位置，代表该变量是引用变量，引用变量必须在声明时初始化 b=2; //可以像普通变量一样操作引用变量，同时，对它的操作也会反应到原始对象上 //此时a，b变成了2 变量定义 类型仅仅是一种语法定义，而要真正使用这种定义，我们需要用类型来定义变量，即变量定义。 C++变量定义是以下形式：
1 type name[{initial_value}] 这里的关键在于type。type是类型和限定符的组合。看下面的例子：
1 2 3 4 5 6 int a; //普通整型 int* b; //类型是int和*的组合，组成了整型指针 const int* c; //从右往左读，*是指针，const int是常量整型，组成了指向常量整型的指针类型 int *const d; //也是从右往左读，const是常量，后面是指针，说明这个指针是常量指针，指向最左边的int，组成常量指针指向整型 int&amp;amp; e=a; //类型是int和&amp;amp;的组合，组成了整型引用 constexpr int f=a+e; //constexpr代表这个变量需要在编译期求值，并且不再可变。 以上，基本就是变量定义的所有形式了，类型确定了变量的基本属性，而限定符限定了变量的使用范围。 定义变量也是按照这个步骤进行，首先确定我们需要什么类型的变量，其次再进一步确定是否需要对这个变量添加限定，很多时候是需要的。可以按以下步骤来确定添加什么样的限定符：</description></item><item><title>现代C++学习指南-方向篇</title><link>https://hongui.github.io/post/%E7%8E%B0%E4%BB%A3C++%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97-%E6%96%B9%E5%90%91%E7%AF%87.html</link><pubDate>Sat, 25 Jun 2022 08:51:01 +0800</pubDate><guid>https://hongui.github.io/post/%E7%8E%B0%E4%BB%A3C++%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97-%E6%96%B9%E5%90%91%E7%AF%87.html</guid><description>C++是一门有着四十年历史的语言，先后经历过四次版本大升级（诞生、98、11、17（20），14算小升级）。每次升级都是很多问题和解决方案的取舍。了解这些历史，能更好地帮助我们理清语言的发展脉络。所以接下来我将借它的发展历程，谈一谈我对它的理解，最后给出我认为比较合理的学习路线指南。
C++0——诞生 C++诞生的目的是为了解决两个主要问题——性能和抽象。性能指的是拥有像C一样的底层访问能力和执行效率，抽象则意在语言层面提供对问题的描述能力和思考方法。这是C++的立命之本，也是C++经久不衰的原因。对于这两个目标，Bjarne Stroustrup想到的解决方法是充分利用现有的C的技术和工具，然后提供类来解决抽象问题。基于这个前提，我们就可以看出类是C++学习路上的第一个关卡。
C++认为类是一种抽象思维，类的相关特性都是为抽象提供服务的。所以C++中的类比其他面向对象的类提供了更多的能力，所以也具有更多的复杂性。为了描述这种复杂性，就不得不提到C++的两个特点，静态类型安全，资源管理。
静态类型安全可以帮助开发者定义出更合理合法的自定义类，如通过操作符重载，自定义类可以写出和基本类型一样的简洁代码。可以通过构造函数避免隐式类型转换而造成的运行时错误，也可以通过明确阻止某些操作阻止自己的类被滥用。所有的自主权都由开发者决定。所以假如我们是库的使用者，完全可以不用关心这些细节，我们只需要按照一般的语言一样写代码，遇到不合理的，编译器会直接告诉我们，不用担心这些问题会隐匿在程序运行时的某个时刻。
资源管理则可以帮助开发者提供资源管理的指导和支撑。资源有很多种，而在计算机中的资源大部分都是有限的，必须有借有还，而且借和还必须一一对应，不然就是内存泄漏。在C时代，资源管理靠的是开发者对资源的全局掌控力，语言层面没有提供更好的支持。为了更好地支持资源管理，C++提出了构造函数和析构函数，两者分别可以对应资源的获取和回收。但是很多时候资源不仅仅供自己使用，还需要提供给外部使用。为了配合这种资源的转移，C++又提供了移动和复制两种操作来支持。
综上，总结一下，C++的类提供了很多特性，但是不是所有的特性都是开发者需要的。开发者在定义类的时候需要考虑的主要问题是，对这个类提供哪些支持，然后再在这些提供的功能中选择合适的语法特性来实现。构造函数和析构函数可以提供很好的一一对应的操作，移动和复制则提供了资源在对象中怎么共享，操作符重载则可以让类使用更加简洁和优雅。
C++98——标准化 C++98最大的升级是模板和异常，并且搭配了好用的标准库。
模板在C++中的地位怎么强调都不为过。它属于另一种抽象机制。所以它解决的也是抽象问题。C++中的类解决的是相似概念的抽象，更注重概念间的相似性。而模板解决的是通用问题的抽象，更注重概念的通用性。两者共同构成了C++的两大抽象基石。前面已经谈过了类，这里我们着重说一下模板。
得益于C++强大的静态类型安全，模板编写起来也很简单，普通的函数怎么写，它就可以怎么写，无非就是把特定类型换成泛型。但是，另一方面，模板还可以做得更多。模板可以支持多种参数，多个参数，限定参数，并且是类型安全的。更厉害的是，它还可以指定值。合理地配合使用类型和值，基本上就能解决大部分问题了。
说起异常。对于普通开发者没有多大吸引力。因为异常主要解决的问题是怎样告诉调用者发生错误了，是什么错误，并将执行能力转移到调用者一方。而我们大部分时间开发的都是业务代码，我们知道发生了什么，该怎样解决，大部分情况下是不太需要异常的。当然，并非说异常一无是处，异常对库开发者来说异常重要。对于库开发者来说，他需要在异常发生后，告诉调用者发生了错误，操作没有办法顺利执行。但是很多时候，库开发者并不知道调用者该怎样处理这个错误，是忽略呢，还是清理现场。异常机制提供了抛异常和异常捕获两种方式来支持库开发者和使用者。
对于新手来说，可能不太喜欢标准库，而倾向于自己写。这不是个好主意。标准库是经过工业级测试的代码，可以在绝大部分情况下正常工作，而自己手写虽然成就感更好，但是更可能携带BUG。早期的标准库提供的功能有限，只有string，输入输出流，位运算，三大容器，和一些小算法。不过，这些都足够我们日常使用了，尤其是现在标准库功能越来越完善了，大部分编程场景都能找到合适的工具来完成，完全可以放弃手写特定代码了。
C++98更多着眼于标准化，模板是一种标准，标准库也是一种标准。自此，C++的三座大山算是构筑完成了，类，模板，标准库。每一项都为C++带来了无限可能和旺盛生命力。
C++11——全新语言 C++11的改动是革命性的，但是还保留着难以置信的兼容性，是非常不容易的。这里我们不细谈具体的特性和细节，只从大方向上来个笼统的概述。
首先直观的变化是在类型系统上，C++11将类型系统做了尽可能的规范化和统一化。
通过同意初始化规范了对象的初始化形式； 通过auto简化了类型声明的形式； 通过nullptr规范化了空指针的形式； 通过enum class提供了静态类型安全的枚举； 通过别名简化了类型书写的方式； 还有其他更多更多 类型系统的改进意味着开发者可以写出更简洁，更规范，也更安全的代码，但是对编译器的挑战却是巨大的，所以，很长时间内，C++11都没有得到很好的支持，同时也妨碍了C++的发展。
除了类型系统，另一项大改进就是提供了对线程的支持。C++11的标准库中提供了线程，条件对象，锁等线程相关的工具，这对库开发者来说是革命性的。在几乎不损失性能的情况下，提供了跨平台的线程支持，这极大地提高了库的稳定性和性能，也节省了很多平台测试时间，不得不说是顶呱呱。
另一个重要升级就是资源管理了。标准库提供了unique_ptr，shared_ptr来协助资源管理。同时为了更出色的性能，引入了右值引用和移动语义。右值引用和移动语义听起来很高端，实际上就是解决一个问题，避免大对象的反复销创建和销毁，转而使用代价更低的移动。根本思路就是两条，对于直接量提供了右值引用，以增加它的生存时间，使之可以像普通变量一样通过参数传递。而对于变量来说，提供了移动语义，将不再需要使用的对象管理的资源转移到另一个对想象中。同时增加了移动构造，复制构造方式来优化函数的返回值。可谓是榨干了计算机的每一寸内存。
C++11无疑是C++里程碑式的更新，在对历史遗留问题清理的同时，引领了接下来C++的发展方向，它的作用是承上启下的。对类型系统的改进无疑弥补了最开始从C继承来的一些缺陷。同时也充分考虑了现代计算机的发展，引入了线程支持。在内存管理上也是更上一层楼，引入了智能指针，移动语义，右值引用。它基本上抛开了历史束缚，但依旧是不忘使命，依旧是奔着更好的静态类型支持，更多的自主性，更高效的资源管理，更克制的特性支持来展开的。
C++17，20——新生 C++17和C++20应该是相辅相成的，绝大部分特性都已经得到支持和完善了。但是由于编译器的限制，我用的特性比较少。C++17比较期待的是跨平台的文件系统支持，这对于大部分应用开发者来说无疑是激动和喜悦的。另一个我喜欢的特性是结构化绑定，这个特性我在Python里面用得很顺手，当然现在基本上所有现代语言都支持它了。
而对于C++20就用得更少了，更多的是示例性质的。我比较在意的是模块和协程，但是由于了解得不深入，就不详谈了。
什么是C++的基本面 从前几个章节不难看出，我着重夸了C++的类，模板，标准库，类型系统。这些都是我觉得学习C++比较重要的方面。但对于初学者来说，我觉得类型系统和标准库就足够了。
类型系统是一门语言最小的单元了，在C++中它包括类型声明，对象初始化，函数传参，函数返回值。在学习初期学多少特性都是骗人的，实际上手还是需要从这个最小的单元入手。比如声明一个变量，这个变量该是什么类型的，可以是指针吗，可以是引用吗。定义函数的时候，参数列表该怎样确定，返回值是什么，怎样才能让函数传参高效，怎样阻止和避免无用的参数检查，返回值该是什么类型，等等，这些都是在实际项目中需要直接面对的问题。所以对类型系统的学习，是写出高效可用代码的第一步，也是最重要的一步。考虑的问题越深入、全面，得到的回报就越大。
标准库则是提供了很好的算法支持和容器支持，可以帮助我们写更健壮的代码。对标准库接口的学习，一方面可以促进对类型系统的认识，另一方面也是积累好习惯的地方。
有了这两项技能的支持，我觉得已经能够写出很棒的应用程序了。但是对于库设计者来说，写出很好的库还需要对类和模板有着更深刻的理解。
一个定义良好的类需要对对象的生命周期进行严格的控制，构造，转移，销毁都是需要控制的。对于需要支持的操作，类设计者应该提供尽可能便捷和高效的支持，对于类禁止的操作，类设计者应该明确禁止，防止发生误用或者隐藏BUG。所以对于类，着重需要关注的是资源的构造，以及在多个对象间的传递和共享。容易发生问题的地方在于函数传参和返回值上，特别是层层调用的函数上，高效和安全就是必须要考虑的了，所以这就回到了前面提到的类型系统，只有对它有了比较深入的了解，才能设计出比较好的类。
模板则是类的另一方面，它和类的概念虽然是不同的，但是思路上却是相通的。模板和Java里面的泛型相似，却更加灵活和重要，是和类一样的高度。模板需要考虑的问题是，提供什么算法，什么对象可以使用这个算法，怎样避免和阻止错误对象的滥用，在使用过程中怎样尽可能利用编译错误来避免运行时错误。所以它是比类更进一步的抽象概念，对开发者有着比类更高的要求。
C++学习路线图 从上一章节，可以看出我推荐的学习路线是类型系统，到标准库，到类，最后才到模板。其他的语言细节不是说不重要，而是在学习这四大板块的同时会融入到学习过程中，没必要单独去学习和理解，毕竟细节是繁杂而且散乱的，不会增加对语言的掌握，却会打乱学习节奏，分散注意力。
类型系统的学习又可以按以下步骤进行
变量声明（常量和编译时常量） 初始化（统一初始化，赋值） 函数定义，函数参数定义，返回值（引用，指针的使用） 简单类定义，不涉及到内存管理，资源管理 标准库可以按以下步骤进行
智能指针（shared_ptr,unique_ptr等） 字符串 容器类对象（list,map等）。 标准输入输出使用 线程库使用 通用算法（sort，find等） 类可以按以下步骤进行
类的构造函数，移动构造，复制构造 类的运算符重载 继承 虚函数 多继承 模板可以按以下步骤进行
模板函数 模板类 模板递归 模板特化 总结 C++细节繁多，初学者容易一头扎进语法细节而不自知，最终白白浪费了大把时间不算，还严重打击了学习积极性。本篇的主旨是在帮初学者理清这门语言的主要脉络，并提供我认为比较科学的学习路线，希望对初学者有所帮助。
C++语言是一门通用型语言，有着很长的发展历史。这导致了它有着不小的历史包袱，所以在引入语言特性和怎样引入的事情上一直保持着克制。但是为了更好地服务于现代硬件和简化开发者工作，又不得不引入新特性，遗弃一些老特性。基于这种原因，语言表现出了一定的复杂性和杂乱性。但是它的核心方向是明确的，就是为了更好地解决效率和抽象问题。抓住这两个核心，再结合这份指南，先难后易，抓大放小，再加上一点归纳和总结就能很好地掌握这门语言的大部分内容。对于指南外的特性，在实际项目中需要了再学习完全是来得及的，毕竟大部分时间我们用到的特性也是很少的一部分，应该把精力花在性价比最高的部分。</description></item></channel></rss>