<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>C++ on 低头沉思</title><link>https://hongui.github.io/categories/c++/</link><description>Recent content in C++ on 低头沉思</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Wed, 20 Jul 2022 22:15:05 +0800</lastBuildDate><atom:link href="https://hongui.github.io/categories/c++/index.xml" rel="self" type="application/rss+xml"/><item><title>现代C++学习指南-标准库</title><link>https://hongui.github.io/post/%E7%8E%B0%E4%BB%A3C++%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97-%E6%A0%87%E5%87%86%E5%BA%93.html</link><pubDate>Wed, 20 Jul 2022 22:15:05 +0800</pubDate><guid>https://hongui.github.io/post/%E7%8E%B0%E4%BB%A3C++%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97-%E6%A0%87%E5%87%86%E5%BA%93.html</guid><description>&lt;blockquote>
&lt;p>在[上一章](&lt;a class="link" href="https://www.yuque.com/docs/share/adb5b1e4-f3c6-46fd-ba4b-4dabce9b4f2a?#" target="_blank" rel="noopener"
>https://www.yuque.com/docs/share/adb5b1e4-f3c6-46fd-ba4b-4dabce9b4f2a?#&lt;/a> 《现代C++学习指南-类型系统》)我们探讨了C++的类型系统，并提出了从低到高，又从高到低的学习思路，本文就是一篇从高到低的学习指南，希望能提供一种新的视角。&lt;/p>
&lt;/blockquote>
&lt;h3 id="什么是标准库">什么是标准库&lt;/h3>
&lt;p>编程语言一般分为两个部分，一部分是语法部分，如上一章的类型系统，另一部分则是用这套语法完成的预定义的工具集，如本文的主题——标准库。标准库是一堆我们写代码时直接可以用的代码，就像是我们提前写好的一样，不仅如此，标准库还是跨平台的，还是经过工业级测试的，所以标准库有着靠谱，安全的特点。
C++标准库包括很多方面，有类&lt;code>vector&lt;/code>、&lt;code>string&lt;/code>等,有对象&lt;code>std::cin&lt;/code>，&lt;code>std::cout&lt;/code>等，还有函数&lt;code>move&lt;/code>，&lt;code>copy&lt;/code>等，所以一般按功能来对它们分类&lt;/p>
&lt;ul>
&lt;li>容器类&lt;/li>
&lt;li>算法类&lt;/li>
&lt;li>智能指针&lt;/li>
&lt;li>线程相关&lt;/li>
&lt;li>其他&lt;/li>
&lt;/ul>
&lt;p>当然，这些还不是全部，标准库是在不断扩充和完善的，学习标准库的宗旨也应该是学习它们的使用场景，而不是深入用法。比如容器类中就有很多功能类似的类，不同的业务场景有不同的选择。通过对它们的了解，我们更容易写出高效，简洁的代码。&lt;/p>
&lt;h3 id="容器类">容器类&lt;/h3>
&lt;p>容器类就是帮助管理一组数据的类，根据实现方式的不同，分为有序列表，无序列表和映射。
有序列表中的有序是指，数据组保存在一块连续的内存区域里，可以通过插入时的索引直接定位到原数据。因为数据是按顺序存入的，所以中途假如需要删除或者新增数据，在操作位置右边的数据都需要移动，操作的代价就比较大。由此也可看出它们的优势是顺序插入和尾部修改，还有直接查找，这方面的代表就是&lt;code>array&lt;/code>，&lt;code>vector&lt;/code>。
&lt;code>array&lt;/code>是对原始数组的封装，并且解决了传递数组变成指针这样的问题，但是缺点是它的大小是固定的，适合用在数据量已知的情况。而&lt;code>vector&lt;/code>又是对&lt;code>array&lt;/code>的增强，不仅能完成所有&lt;code>array&lt;/code>的操作，并且大小可变，所以绝大部分情况下，选择&lt;code>vector&lt;/code>都是理想的选择。
&lt;img src="https://cdn.nlark.com/yuque/0/2022/jpeg/29458474/1658015351475-f6a5189b-7331-4173-80b4-1a1f83f25f7d.jpeg"
loading="lazy"
>
无序列表的元素是单独存储的，相互之间用指针来查找相邻元素，由于指针可以轻易修改指向的指，所以对相邻元素的修改就变得很快捷。同样的道理，查找相邻元素只能靠指针跳转，查找某个值需要从一个指针开始查找，一次跳转一条数据，直到找到目标或者没有数据为止。所以无序列表的优势是快速地删除和插入新数据，不适合查找，其代表有&lt;code>list&lt;/code>，&lt;code>forward_list&lt;/code>。显然，有序列表和无序列表是互补的，我们在实际项目中，应该&lt;strong>根据数据的操作来确定选择哪种容器。&lt;/strong>
&lt;img src="https://cdn.nlark.com/yuque/0/2022/jpeg/29458474/1658015352400-93e48503-009d-41bb-89b1-4a50bc1ca3d1.jpeg"
loading="lazy"
>&lt;/p>
&lt;p>&lt;strong>映射则融合了有序列表和无序列表的优点，既可以快速插入和删除，又可以快速查找&lt;/strong>。为了满足各种使用场景，C++提供了&lt;code>map&lt;/code>，&lt;code>multimap&lt;/code>，&lt;code>unordered_map&lt;/code>，&lt;code>unordered_multimap&lt;/code>。从名字上就能看出来它们的差别。为了直观，我直接列了一个表&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;/th>
&lt;th>是否排序&lt;/th>
&lt;th>是否支持相同值&lt;/th>
&lt;th>速度&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>unordered_map&lt;/td>
&lt;td>❌&lt;/td>
&lt;td>❌&lt;/td>
&lt;td>❤️❤️❤️❤️&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>map&lt;/td>
&lt;td>✅&lt;/td>
&lt;td>❌&lt;/td>
&lt;td>❤️❤️&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>multimap&lt;/td>
&lt;td>✅&lt;/td>
&lt;td>✅&lt;/td>
&lt;td>❤️&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>unordered_multimap&lt;/td>
&lt;td>✅&lt;/td>
&lt;td>✅&lt;/td>
&lt;td>❤️❤️❤️&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>映射存储的是两个值，不同的类型实现方式不一样。由于&lt;code>map&lt;/code>是需要排序的，所以通常它的实现是一种平衡二叉树，键就是它排序的依据。
&lt;img src="https://cdn.nlark.com/yuque/0/2022/jpeg/29458474/1658015140161-206f2bf1-345d-4fb7-9b6d-50fbfcb81b2e.jpeg"
loading="lazy"
>
而&lt;code>unordered_map&lt;/code>是不需要排序的，所以它的实现通常是哈希表，即根据哈希函数的确定索引位置继而确定存储位置。
&lt;img src="https://cdn.nlark.com/yuque/0/2022/jpeg/29458474/1658015142087-4460ed23-40be-441e-8649-c40eb78dfc9a.jpeg"
loading="lazy"
>
综上，容器类提供了一种操作多个同类型数据的接口，开发者通过对容器类方法的调用，可以实现对容器内数据的增删改查。大部分情况下，&lt;code>vector&lt;/code>都是靠谱的选择，它提供了全功能的数据操作接口，支持动态长度，索引查询，并且简单高效。如果需要频繁地插入或者删除操作，也可以考虑&lt;code>list&lt;/code>或者&lt;code>forward_list&lt;/code>。&lt;code>map&lt;/code>可以让数据保持有序，需要更快的速度而不是排序的话&lt;code>unorderer_map&lt;/code>是更好的选择，如果相同值会出现多次就可以使用对应的&lt;code>multi&lt;/code>版本。另外容器类也是很好的数据结构学习资源，C++的容器类几乎提供了数据结构中所有的形式，对数据结构越熟悉选择的容器类就越完美。&lt;/p>
&lt;h3 id="算法">算法&lt;/h3>
&lt;p>之所以将算法放在容器类后面，是因为算法大部分是对容器类操作的加强，算法都定义在&lt;code>algorithm&lt;/code>文件头里。这些算法都是短小精悍的，可以大大增加代码可读性，并且妥善处理了很多容易遗忘的边界问题。功能上可以分为增删改查几种操作，可以在实际有需要的时候在查看文档，具体可以参阅&lt;a class="link" href="https://cplusplus.com/reference/algorithm/" target="_blank" rel="noopener"
>这里&lt;/a>&lt;/p>
&lt;h3 id="智能指针">智能指针&lt;/h3>
&lt;p>很早以前，我对智能指针的态度不是很好。因为刚开始学习C++时我就知道，不能单独使用指针，要把指针封装在类里，利用类的构造函数和析构函数管理指针，也就是&lt;code>RAII&lt;/code>。最开始我以为这就够了,直到我遇到下面这种情况&lt;/p>
&lt;div class="highlight">&lt;div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
&lt;table style="border-spacing:0;padding:0;margin:0;border:0;">&lt;tr>&lt;td style="vertical-align:top;padding:0;margin:0;border:0;">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">13
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">14
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">15
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">16
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">17
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">18
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">19
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">20
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">21
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">22
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">23
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">24
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">25
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">26
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">public&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Ptr()&lt;span style="color:#000;font-weight:bold">:&lt;/span>p{ &lt;span style="color:#000;font-weight:bold">new&lt;/span> &lt;span style="color:#458;font-weight:bold">int&lt;/span> } {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">~&lt;/span>Ptr() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">delete&lt;/span> p;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#458;font-weight:bold">int&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;amp;&lt;/span> get() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">return&lt;/span> &lt;span style="color:#000;font-weight:bold">*&lt;/span>p;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#458;font-weight:bold">void&lt;/span> &lt;span style="color:#900;font-weight:bold">set&lt;/span>(&lt;span style="color:#000;font-weight:bold">const&lt;/span> &lt;span style="color:#458;font-weight:bold">int&lt;/span> value) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">*&lt;/span>p &lt;span style="color:#000;font-weight:bold">=&lt;/span> value;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">private&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#458;font-weight:bold">int&lt;/span>&lt;span style="color:#000;font-weight:bold">*&lt;/span> p;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#458;font-weight:bold">void&lt;/span> &lt;span style="color:#900;font-weight:bold">use&lt;/span>(Ptr p) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#998;font-style:italic">//传进来的是复制构造出来的p&amp;#39;,函数返回后p&amp;#39;被销毁啦，两个指针指向的地址被回收，外面的p指针成为了野指针
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#998;font-style:italic">&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#458;font-weight:bold">int&lt;/span> &lt;span style="color:#900;font-weight:bold">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Ptr p;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> p.set(&lt;span style="color:#099">1&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> use(p); &lt;span style="color:#998;font-style:italic">//p按值传递，调用了Ptr的复制构造函数，构造出了新对象p&amp;#39;,它的指针和p的指针指向同一个地方
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#998;font-style:italic">&lt;/span> std&lt;span style="color:#000;font-weight:bold">::&lt;/span>cout &lt;span style="color:#000;font-weight:bold">&amp;lt;&amp;lt;&lt;/span> p.get() &lt;span style="color:#000;font-weight:bold">&amp;lt;&amp;lt;&lt;/span> std&lt;span style="color:#000;font-weight:bold">::&lt;/span>endl; &lt;span style="color:#998;font-style:italic">//p已经被销毁了，访问p的地址非法
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#998;font-style:italic">&lt;/span> &lt;span style="color:#000;font-weight:bold">return&lt;/span> &lt;span style="color:#099">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>调用&lt;code>use&lt;/code>时，变量&lt;code>p&lt;/code>被拷贝，也就出现了两个指针同时指向一块内存地址的情况。&lt;code>use&lt;/code>函数执行完后，它的参数&lt;code>p&lt;/code>被回收。也就是调用了&lt;code>Ptr&lt;/code>的析构函数，也就是两个指针指向的地址被回收。所以24行调用&lt;code>get&lt;/code>读取那个已经被回收了的地址就是非法操作，程序崩溃。
这可能是新手比较常遇到的一个问题，当然，解决这个问题也很简单，还用不到智能指针，只需要将函数&lt;code>use&lt;/code>的参数改为引用类型就可以了，因为引用只是别名，不会产生新的指针，这也是我在类型系统篇中极力推荐引用为首选参数类型的原因之一。对于此例，数据不大，直接重写复制构造函数，重新申请一块内存也是一种思路。
此例中用到Ptr的地方只有一个，实际项目中Ptr往往需要用到很多次，我们不能保证不会出现忘记使用引用类型的情况，这种情况下重新申请内存也不适用，所以这个时候就需要智能指针来帮忙了。
现在思考另一种情况，某些操作我们不得不暴露出我们的指针供外部使用，随着业务的嵌套和调用链增加，很多时候会忘记或者不确定在什么时候调用&lt;code>delete&lt;/code>释放内存。这也是用智能指针的一个场景。以上两种情况都是需要分享指针，对应智能指针中的&lt;code>shared_ptr&lt;/code>。
&lt;code>shared_ptr&lt;/code>顾名思义，它可以帮助开发者完成指针共享的问题，并且完美解决提前释放，不知何时释放，谁负责释放的问题。它的对应关系是一对多，一个实际的内存可以被多个&lt;code>shared_ptr&lt;/code>共享
&lt;img src="https://cdn.nlark.com/yuque/0/2022/jpeg/29458474/1658146077740-b934d6d5-fc6e-4cff-9863-4e263b5c3848.jpeg"
loading="lazy"
>
另外一种场景是我们希望&lt;strong>自始至终某个指针某个时刻只属于一个对象&lt;/strong>，外部想要使用它要么通过拥有该指针的对象方法，要么把指针的所有权转移到自己身上，这种场景对应智能指针中的&lt;code>unique_ptr&lt;/code>。
&lt;img src="https://cdn.nlark.com/yuque/0/2022/jpeg/29458474/1658147416713-1b6a7866-1cd8-4be6-b2dc-bdfe41db69d6.jpeg"
loading="lazy"
>
&lt;code>unique_ptr&lt;/code>的对应关系是一对一，无论哪个时刻，只能有一个管理者拥有指针，也就只能由它负责释放了。假如想转移这种对应关系，只能通过&lt;code>std::move&lt;/code>操作，不过这个操作之后，原先对象的指针就失效了，它也不再负责管理，所有的任务移交给了新的对象。这种特性特别适合资源敏感型的应用。&lt;/p>
&lt;h3 id="线程库">线程库&lt;/h3>
&lt;p>除了内存，线程是开发中另一个重要的课题。线程的难点在于不仅要管理线程对象，还要管理线程对象管理的资源，并且保证线程间数据同步。当然标准库已经做得足够好了，我们需要理解的是使用场景的问题。线程库主要包括线程对象&lt;code>thread&lt;/code>，条件对象&lt;code>condition_variable&lt;/code>，锁对象&lt;code>mutex&lt;/code>。
使用&lt;code>thread&lt;/code>可以很方便地把程序写成多线程，只需要三步：&lt;/p>
&lt;div class="highlight">&lt;div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
&lt;table style="border-spacing:0;padding:0;margin:0;border:0;">&lt;tr>&lt;td style="vertical-align:top;padding:0;margin:0;border:0;">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">13
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">14
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">15
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">16
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#458;font-weight:bold">void&lt;/span> &lt;span style="color:#900;font-weight:bold">plus&lt;/span>(&lt;span style="color:#458;font-weight:bold">int&lt;/span> a,&lt;span style="color:#458;font-weight:bold">int&lt;/span> b){ &lt;span style="color:#998;font-style:italic">//第一步：定义线程中要运行的函数
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#998;font-style:italic">&lt;/span> std&lt;span style="color:#000;font-weight:bold">::&lt;/span>cout&lt;span style="color:#000;font-weight:bold">&amp;lt;&amp;lt;&lt;/span>&lt;span style="color:#d14">&amp;#34;running at sub thread&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;lt;&amp;lt;&lt;/span>std&lt;span style="color:#000;font-weight:bold">::&lt;/span>endl;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#000;font-weight:bold">::&lt;/span>cout&lt;span style="color:#000;font-weight:bold">&amp;lt;&amp;lt;&lt;/span>&lt;span style="color:#d14">&amp;#34;a + b = &amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;lt;&amp;lt;&lt;/span>a&lt;span style="color:#000;font-weight:bold">+&lt;/span>b&lt;span style="color:#000;font-weight:bold">&amp;lt;&amp;lt;&lt;/span>std&lt;span style="color:#000;font-weight:bold">::&lt;/span>endl;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#458;font-weight:bold">int&lt;/span> &lt;span style="color:#900;font-weight:bold">main&lt;/span>(){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#000;font-weight:bold">::&lt;/span>&lt;span style="color:#000;font-weight:bold">thread&lt;/span> &lt;span style="color:#000;font-weight:bold">thread&lt;/span>{plus,&lt;span style="color:#099">1&lt;/span>,&lt;span style="color:#099">1&lt;/span>}; &lt;span style="color:#998;font-style:italic">//第二步，定义std::thread对象，将函数作为参数
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#998;font-style:italic">&lt;/span> std&lt;span style="color:#000;font-weight:bold">::&lt;/span>cout&lt;span style="color:#000;font-weight:bold">&amp;lt;&amp;lt;&lt;/span>&lt;span style="color:#d14">&amp;#34;continue running at main thread&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;lt;&amp;lt;&lt;/span>std&lt;span style="color:#000;font-weight:bold">::&lt;/span>endl;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">thread&lt;/span>.join(); &lt;span style="color:#998;font-style:italic">//第三步调用线程对象的join函数或者detach函数
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#998;font-style:italic">&lt;/span> std&lt;span style="color:#000;font-weight:bold">::&lt;/span>cout&lt;span style="color:#000;font-weight:bold">&amp;lt;&amp;lt;&lt;/span>&lt;span style="color:#d14">&amp;#34;sub thread finished!&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;lt;&amp;lt;&lt;/span>std&lt;span style="color:#000;font-weight:bold">::&lt;/span>endl;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#998;font-style:italic">//输出
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#998;font-style:italic">// continue running at main thread
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#998;font-style:italic">// running at sub thread
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#998;font-style:italic">// a + b = 2
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#998;font-style:italic">// sub thread finished!
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>难点在线程间通信，也就是解决两个问题&lt;/p>
&lt;ol>
&lt;li>线程1更新了变量v的值&lt;/li>
&lt;li>线程2马上能读取到正确的变量v的值，即线程1更新的那个最新值&lt;/li>
&lt;/ol>
&lt;p>为了协调这两个过程，就出现了锁对象&lt;code>mutex&lt;/code>和条件对象&lt;code>condition_variable&lt;/code>。锁对象&lt;code>mutex&lt;/code>保证变量按照正确的顺序更改。条件对象&lt;code>condition_variable&lt;/code>保证更改能被其他线程监听到。&lt;/p>
&lt;div class="highlight">&lt;div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
&lt;table style="border-spacing:0;padding:0;margin:0;border:0;">&lt;tr>&lt;td style="vertical-align:top;padding:0;margin:0;border:0;">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">13
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">14
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">15
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">16
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">17
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">18
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">19
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">20
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">21
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">22
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">23
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">24
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">25
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">26
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">27
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">28
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">29
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">30
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">31
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">32
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">33
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">34
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">35
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#458;font-weight:bold">int&lt;/span> a,b;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#458;font-weight:bold">bool&lt;/span> ready &lt;span style="color:#000;font-weight:bold">=&lt;/span> &lt;span style="color:#0086b3">false&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>std&lt;span style="color:#000;font-weight:bold">::&lt;/span>mutex mux;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>std&lt;span style="color:#000;font-weight:bold">::&lt;/span>condition_variable con;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#458;font-weight:bold">void&lt;/span> &lt;span style="color:#900;font-weight:bold">plus&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#000;font-weight:bold">::&lt;/span>cout &lt;span style="color:#000;font-weight:bold">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#d14">&amp;#34;running at sub thread&amp;#34;&lt;/span> &lt;span style="color:#000;font-weight:bold">&amp;lt;&amp;lt;&lt;/span> std&lt;span style="color:#000;font-weight:bold">::&lt;/span>endl;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#998;font-style:italic">//因为我们要读取ready的最新值，所以要用锁保证读取结果的有效性
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#998;font-style:italic">&lt;/span> std&lt;span style="color:#000;font-weight:bold">::&lt;/span>unique_lock&lt;span style="color:#000;font-weight:bold">&amp;lt;&lt;/span>std&lt;span style="color:#000;font-weight:bold">::&lt;/span>mutex&lt;span style="color:#000;font-weight:bold">&amp;gt;&lt;/span> guard{ mux };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">if&lt;/span> (&lt;span style="color:#000;font-weight:bold">!&lt;/span>ready) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#998;font-style:italic">//数据没准备好，休息一下！
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#998;font-style:italic">&lt;/span> con.wait(guard);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#998;font-style:italic">//这里就可以正确读变量a,b了
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#998;font-style:italic">&lt;/span> std&lt;span style="color:#000;font-weight:bold">::&lt;/span>cout &lt;span style="color:#000;font-weight:bold">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#d14">&amp;#34;a + b =&amp;#34;&lt;/span> &lt;span style="color:#000;font-weight:bold">&amp;lt;&amp;lt;&lt;/span> a &lt;span style="color:#000;font-weight:bold">+&lt;/span> b &lt;span style="color:#000;font-weight:bold">&amp;lt;&amp;lt;&lt;/span> std&lt;span style="color:#000;font-weight:bold">::&lt;/span>endl;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#458;font-weight:bold">int&lt;/span> &lt;span style="color:#900;font-weight:bold">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#000;font-weight:bold">::&lt;/span>&lt;span style="color:#000;font-weight:bold">thread&lt;/span> &lt;span style="color:#000;font-weight:bold">thread&lt;/span>{ plus};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#000;font-weight:bold">::&lt;/span>cout &lt;span style="color:#000;font-weight:bold">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#d14">&amp;#34;continue running at main thread&amp;#34;&lt;/span> &lt;span style="color:#000;font-weight:bold">&amp;lt;&amp;lt;&lt;/span> std&lt;span style="color:#000;font-weight:bold">::&lt;/span>endl;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#000;font-weight:bold">::&lt;/span>cout &lt;span style="color:#000;font-weight:bold">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#d14">&amp;#34;input a = &amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#000;font-weight:bold">::&lt;/span>cin &lt;span style="color:#000;font-weight:bold">&amp;gt;&amp;gt;&lt;/span> a;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#000;font-weight:bold">::&lt;/span>cout &lt;span style="color:#000;font-weight:bold">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#d14">&amp;#34;input b = &amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#000;font-weight:bold">::&lt;/span>cin &lt;span style="color:#000;font-weight:bold">&amp;gt;&amp;gt;&lt;/span> b;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#998;font-style:italic">//数据准备好了，该通知子线程干活了，用大括号是因为想让锁因为guard的销毁即使释放，从未保证plus里面能重新获得锁
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#998;font-style:italic">&lt;/span> std&lt;span style="color:#000;font-weight:bold">::&lt;/span>unique_lock&lt;span style="color:#000;font-weight:bold">&amp;lt;&lt;/span>std&lt;span style="color:#000;font-weight:bold">::&lt;/span>mutex&lt;span style="color:#000;font-weight:bold">&amp;gt;&lt;/span> guard{ mux };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#998;font-style:italic">//更新数据
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#998;font-style:italic">&lt;/span> ready &lt;span style="color:#000;font-weight:bold">=&lt;/span> &lt;span style="color:#0086b3">true&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#998;font-style:italic">//通知
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#998;font-style:italic">&lt;/span> con.notify_all();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">thread&lt;/span>.join();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#000;font-weight:bold">::&lt;/span>cout &lt;span style="color:#000;font-weight:bold">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#d14">&amp;#34;sub thread finished!&amp;#34;&lt;/span> &lt;span style="color:#000;font-weight:bold">&amp;lt;&amp;lt;&lt;/span> std&lt;span style="color:#000;font-weight:bold">::&lt;/span>endl;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>多线程另一个需要注意的问题就是死锁。死锁的前提是有两个锁&lt;/p>
&lt;ol>
&lt;li>线程1得到了锁a，还想得锁b&lt;/li>
&lt;li>线程2得到了锁b，还想得锁a&lt;/li>
&lt;/ol>
&lt;p>然后，再加上一个前提：某一时刻，只有一个线程能拥有某个锁，就不难得出以下结论：线程a，b除非某一个放弃已得的锁，不然两个线程都会因为没得到需要的锁而一直死等，形成死锁。同时解决死锁的思路也呼之欲出：既然一个得了a，一个得了b，而锁同一时间只能被一个线程得到，那么所有线程都按先得a，再得b的顺序来就不会有锁被占用的问题了。另一个思路则可以从放弃上入手，既然都得不到，那么接下来的任务也做不了，不如直接放弃已经得到的，所以可以考虑使用&lt;code>timed_mutex&lt;/code>。&lt;/p>
&lt;h3 id="其他">其他&lt;/h3>
&lt;p>还有很多常用的库，如字符串&lt;code>string&lt;/code>，时间&lt;code>chrono&lt;/code>，还有在定义函数变量时常用的&lt;code>functional&lt;/code>,异常&lt;code>exception&lt;/code>，更多的内容可以在&lt;a class="link" href="https://cplusplus.com/reference/" target="_blank" rel="noopener"
>cplusplus&lt;/a>找的参考。&lt;/p>
&lt;h3 id="总结">总结&lt;/h3>
&lt;p>总的来说，标准库提供了一个展现C++语言能力的平台：帮助开发者更好更快完成开发任务的同时，还能启迪开发者实现更好的抽象和实践。如我就从标准库中学到了更规范地定义函数参数，更好的封装，以及其他好的思路。学习标准库不仅更好地掌握了语言本身，还掌握了更全面地分析问题，解决问题的方法，是值得花费一段时间学习的。
容器类是几乎所有项目都会用到的，也是比较好掌握的，主要可以从数据结构方面对照学习；智能指针则是处理指针问题的好帮手；线程相关的库是比较难掌握的，关键是要想明白使用场景和极端情况下的边界问题。很多时候边界问题可能不那么直观。如线程要求获得锁的情况就分为：锁空闲，锁被其他线程占有，锁被自己占有。不同的边界对于不同的锁，预期结果也是不同的，只有在明确场景的情况下，才能更好地理清锁的关系，从而解决好问题。
最好的学习还是在实践中主动使用。对于我，通常在遇到新问题的时候会先查查标准库有没有相应的库，有的话就是学习这个库的好时机。可以先概览库的定义和解决的问题，然后分析它提供的类，函数，对象等，再将自己的理解转换为项目中的代码，最后在实际效果中检验和修正想法，完成库的学习。&lt;/p></description></item><item><title>现代C++学习指南-类型系统</title><link>https://hongui.github.io/post/%E7%8E%B0%E4%BB%A3C++%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97-%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F.html</link><pubDate>Sun, 26 Jun 2022 11:11:59 +0800</pubDate><guid>https://hongui.github.io/post/%E7%8E%B0%E4%BB%A3C++%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97-%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F.html</guid><description>&lt;blockquote>
&lt;p>在前一篇，我们提供了一个方向性的指南，但是学什么，怎么学却没有详细展开。本篇将在前文的基础上，着重介绍下怎样学习C++的类型系统。&lt;/p>
&lt;/blockquote>
&lt;h3 id="写在前面">写在前面&lt;/h3>
&lt;p>在进入类型系统之前，我们应该先达成一项共识——尽可能使用C++的现代语法。众所周知，出于兼容性的考虑，C++中很多语法都是合法的。但是随着新版本的推出，有些语法可能是不推荐或者是需要避免使用的。所以本篇也尽可能采用推荐的语法形式（基于C++11或以上版本），这也是现代C++标题的含义。
采用现代语法有两点好处。其一，现代语法可以编译出更快更健壮的代码。编译器也是随着语言的发展而发展的，现代语法可以在一定程度上帮助编译器做更好的优化。其二，现代语法通常更简洁，更直观，也更统一，有助于增强可读性和可维护性。
明确了这点后，让我们一起踏入现代C++的大门吧。&lt;/p>
&lt;h3 id="类型系统">类型系统&lt;/h3>
&lt;p>&lt;strong>程序是一种计算工具，根据输入，和预定义的计算方法，产生计算结果&lt;/strong>。当程序运行起来后，这三者都需要在内存中表示成合适的值才能让程序正常工作，负责解释的这套工具就是类型系统。数字，字符串，键盘鼠标事件等都是数据，而且在内存中实际存在的形式也是一样的，但是按我们人类的眼光来看的话，对它们的处理是不一样的。数字能进行加减乘除等算术运算，但是对字符串进行算术运算就没有意义，而键盘鼠标的值通常只是读取，不进行计算的。正是由于这些差异，编程语言的第一个任务就是需要定义一套类型系统，告诉计算机怎样处理内存中的数据。
为了让编程语言尽可能简单，编程语言一般把类型系统分为两步实现，一部分是编译器，另一部分是类型。编译器那部分负责将开发者的代码解释成合适的形式，以便可以高效，准确在内存中表示。类型部分则定义一些编译器能处理的类型，以便开发者可以找到合适的数据来完成输入输出的表示和计算方法的描述。这两者相辅相成，相互成就。
类型作为类型系统的重要表现形式，在编程语言中的重要性也就不言而喻了。如果把写程序看成是搭积木的话，那么程序的积木就是类型系统。类型系统是开发者能操作的最小单位，它限制了开发者的操作规则，但是提供了无限的可能。C++有着比积木更灵活的类型系统。&lt;/p>
&lt;h3 id="类型">类型&lt;/h3>
&lt;p>:::info
类型是编程语言的最小单位，任何一句代码都是一种内存使用形式。
:::
而谈到C++的类型也就不得不谈到它的三种类型表现形式——普通类型，指针，引用。它们是三种不同的内存使用和解释形式，也是C++的最基础的形式。和大部分编程语言不同，C++对内置类型没有做特权处理，只要开发者愿意，所有的类型都可以有一致的语法形式（通过运算符重载），所以下面关于类型的举例适合所有的类型。
普通类型就是没有修饰的类型，如&lt;code>int&lt;/code>,&lt;code>long&lt;/code>,&lt;code>double&lt;/code>等。它们是按值传递的，也就是赋值和函数传参是拷贝一份值，对拷贝后的值进行操作，不会再影响到老值。&lt;/p>
&lt;div class="highlight">&lt;div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
&lt;table style="border-spacing:0;padding:0;margin:0;border:0;">&lt;tr>&lt;td style="vertical-align:top;padding:0;margin:0;border:0;">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#458;font-weight:bold">int&lt;/span> a&lt;span style="color:#000;font-weight:bold">=&lt;/span>&lt;span style="color:#099">1&lt;/span>; &lt;span style="color:#998;font-style:italic">//老值,存在地址1
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#998;font-style:italic">&lt;/span>&lt;span style="color:#458;font-weight:bold">int&lt;/span> b&lt;span style="color:#000;font-weight:bold">=&lt;/span>a; &lt;span style="color:#998;font-style:italic">//新值，存在地址2
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#998;font-style:italic">&lt;/span>b&lt;span style="color:#000;font-weight:bold">=&lt;/span>&lt;span style="color:#099">2&lt;/span>; &lt;span style="color:#998;font-style:italic">//改变新值，改变地址2
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#998;font-style:italic">//此时a还是1，b变成了2
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;img src="https://cdn.nlark.com/yuque/0/2022/jpeg/29458474/1656843295159-ac2e516f-5226-4a08-9b72-d38d138627f6.jpeg"
loading="lazy"
>&lt;/p>
&lt;p>那假如我们需要修改老值呢，有两种途径，一种是指针，另一种则是引用。
指针是C/C++里面的魔法，一切皆可指针。指针包含两个方面，一方面它是指一块内存，另一方面它可以指允许对这块内存进行的操作。指针的值是一块内存地址，操作指针，操作的是它指向的那块地址。&lt;/p>
&lt;div class="highlight">&lt;div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
&lt;table style="border-spacing:0;padding:0;margin:0;border:0;">&lt;tr>&lt;td style="vertical-align:top;padding:0;margin:0;border:0;">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#458;font-weight:bold">int&lt;/span> a&lt;span style="color:#000;font-weight:bold">=&lt;/span>&lt;span style="color:#099">1&lt;/span>; &lt;span style="color:#998;font-style:italic">//老值,存在地址1
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#998;font-style:italic">&lt;/span>&lt;span style="color:#458;font-weight:bold">int&lt;/span>&lt;span style="color:#000;font-weight:bold">*&lt;/span> b&lt;span style="color:#000;font-weight:bold">=&amp;amp;&lt;/span>a; &lt;span style="color:#998;font-style:italic">//&amp;amp;代表取地址，从右往左读，取a的地址——地址1，存在地址2
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#998;font-style:italic">&lt;/span>&lt;span style="color:#000;font-weight:bold">*&lt;/span>b&lt;span style="color:#000;font-weight:bold">=&lt;/span>&lt;span style="color:#099">2&lt;/span>; &lt;span style="color:#998;font-style:italic">//*是解引用，意思是把存在地址2(b)的值取出来，并把那个地址（地址1）的值改成2
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#998;font-style:italic">//此时a，*b变成了2
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;img src="https://cdn.nlark.com/yuque/0/2022/jpeg/29458474/1656842930791-9b5ed632-8d54-466a-960e-dfb58f5609c5.jpeg"
loading="lazy"
>
引用则是指针的改进版，引用能避免无效引用，不过引用不能重设，比指针缺少一定的灵活性。&lt;/p>
&lt;div class="highlight">&lt;div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
&lt;table style="border-spacing:0;padding:0;margin:0;border:0;">&lt;tr>&lt;td style="vertical-align:top;padding:0;margin:0;border:0;">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#458;font-weight:bold">int&lt;/span> a&lt;span style="color:#000;font-weight:bold">=&lt;/span>&lt;span style="color:#099">1&lt;/span>; &lt;span style="color:#998;font-style:italic">//老值,存在地址1
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#998;font-style:italic">&lt;/span>&lt;span style="color:#458;font-weight:bold">int&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;amp;&lt;/span> b&lt;span style="color:#000;font-weight:bold">=&lt;/span>a; &lt;span style="color:#998;font-style:italic">//&amp;amp;出现在变量声明的位置，代表该变量是引用变量，引用变量必须在声明时初始化
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#998;font-style:italic">&lt;/span>b&lt;span style="color:#000;font-weight:bold">=&lt;/span>&lt;span style="color:#099">2&lt;/span>; &lt;span style="color:#998;font-style:italic">//可以像普通变量一样操作引用变量，同时，对它的操作也会反应到原始对象上
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#998;font-style:italic">//此时a，b变成了2
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="变量定义">变量定义&lt;/h3>
&lt;p>类型仅仅是一种语法定义，而要真正使用这种定义，我们需要用类型来定义变量，即变量定义。
C++变量定义是以下形式：&lt;/p>
&lt;div class="highlight">&lt;div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
&lt;table style="border-spacing:0;padding:0;margin:0;border:0;">&lt;tr>&lt;td style="vertical-align:top;padding:0;margin:0;border:0;">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>type name[{initial_value}]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这里的关键在于&lt;code>type&lt;/code>。&lt;code>type&lt;/code>是类型和限定符的组合。看下面的例子：&lt;/p>
&lt;div class="highlight">&lt;div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
&lt;table style="border-spacing:0;padding:0;margin:0;border:0;">&lt;tr>&lt;td style="vertical-align:top;padding:0;margin:0;border:0;">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">5
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#458;font-weight:bold">int&lt;/span> a; &lt;span style="color:#998;font-style:italic">//普通整型
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#998;font-style:italic">&lt;/span>&lt;span style="color:#458;font-weight:bold">int&lt;/span>&lt;span style="color:#000;font-weight:bold">*&lt;/span> b; &lt;span style="color:#998;font-style:italic">//类型是int和*的组合，组成了整型指针
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#998;font-style:italic">&lt;/span>&lt;span style="color:#000;font-weight:bold">const&lt;/span> &lt;span style="color:#458;font-weight:bold">int&lt;/span>&lt;span style="color:#000;font-weight:bold">*&lt;/span> c; &lt;span style="color:#998;font-style:italic">//从右往左读，*是指针，const int是常量整型，组成了指向常量整型的指针类型
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#998;font-style:italic">&lt;/span>&lt;span style="color:#458;font-weight:bold">int&lt;/span> &lt;span style="color:#000;font-weight:bold">*&lt;/span>&lt;span style="color:#000;font-weight:bold">const&lt;/span> d; &lt;span style="color:#998;font-style:italic">//也是从右往左读，const是常量，后面是指针，说明这个指针是常量指针，指向最左边的int，组成常量指针指向整型
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#998;font-style:italic">&lt;/span>&lt;span style="color:#458;font-weight:bold">int&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;amp;&lt;/span> e&lt;span style="color:#000;font-weight:bold">=&lt;/span>a; &lt;span style="color:#998;font-style:italic">//类型是int和&amp;amp;的组合，组成了整型引用
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#998;font-style:italic">&lt;/span>&lt;span style="color:#000;font-weight:bold">constexpr&lt;/span> &lt;span style="color:#458;font-weight:bold">int&lt;/span> f&lt;span style="color:#000;font-weight:bold">=&lt;/span>a&lt;span style="color:#000;font-weight:bold">+&lt;/span>e; &lt;span style="color:#998;font-style:italic">//constexpr代表这个变量需要在编译期求值，并且不再可变。
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>以上，基本就是变量定义的所有形式了，类型确定了变量的基本属性，而限定符限定了变量的使用范围。
定义变量也是按照这个步骤进行，&lt;strong>首先确定我们需要什么类型的变量，其次再进一步确定是否需要对这个变量添加限定，很多时候是需要的&lt;/strong>。可以按以下步骤来确定添加什么样的限定符：&lt;/p>
&lt;ol>
&lt;li>是个大对象，可以考虑把变量声明成引用类型。通常引用类型是比指针类型更优的选择。&lt;/li>
&lt;li>大对象可能需要被重置，可以考虑声明为指针。&lt;/li>
&lt;li>只想要个常量，添加&lt;code>constexpr&lt;/code>。&lt;/li>
&lt;li>只想读这个变量，添加&lt;code>const&lt;/code>。&lt;/li>
&lt;/ol>
&lt;h3 id="变量初始化">变量初始化&lt;/h3>
&lt;p>变量定义往往伴随着初始化，这对于局部变量来说很重要，因为局部变量的初值是不确定的，在没有对变量进行有效初始化前就使用变量，会导致不可控的问题。所以严格来说，前面的变量定义是不完全正确的。
C++11推出了全新的，统一的初始化方式，即在变量名后面跟着大括号，大括号里包着初始化的值。这种方式可以用在任何变量上，称之为统一初始化，如：&lt;/p>
&lt;div class="highlight">&lt;div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
&lt;table style="border-spacing:0;padding:0;margin:0;border:0;">&lt;tr>&lt;td style="vertical-align:top;padding:0;margin:0;border:0;">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#458;font-weight:bold">int&lt;/span> a{&lt;span style="color:#099">9527&lt;/span>}; &lt;span style="color:#998;font-style:italic">//普通类型
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#998;font-style:italic">&lt;/span>string b&lt;span style="color:#000;font-weight:bold">=&lt;/span>{&lt;span style="color:#d14">&amp;#34;abc&amp;#34;&lt;/span>}; &lt;span style="color:#998;font-style:italic">//另一种写法，等价但是不推荐
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#998;font-style:italic">&lt;/span>Student c{&lt;span style="color:#d14">&amp;#34;张三&amp;#34;&lt;/span>,&lt;span style="color:#d14">&amp;#34;20220226&amp;#34;&lt;/span>,&lt;span style="color:#099">18&lt;/span>}; &lt;span style="color:#998;font-style:italic">//大括号中是构造函数参数
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>当然，除了用类型名来定义变量外，还可以将定义和初始化合二为一，变成下面这种最简洁的形式：&lt;/p>
&lt;div class="highlight">&lt;div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
&lt;table style="border-spacing:0;padding:0;margin:0;border:0;">&lt;tr>&lt;td style="vertical-align:top;padding:0;margin:0;border:0;">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">auto&lt;/span> a&lt;span style="color:#000;font-weight:bold">=&lt;/span>{&lt;span style="color:#099">1&lt;/span>}; &lt;span style="color:#998;font-style:italic">//推导为整型
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#998;font-style:italic">&lt;/span>&lt;span style="color:#000;font-weight:bold">auto&lt;/span> b&lt;span style="color:#000;font-weight:bold">=&lt;/span>string{&lt;span style="color:#d14">&amp;#34;abc&amp;#34;&lt;/span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">auto&lt;/span> c&lt;span style="color:#000;font-weight:bold">=&lt;/span>Student{&lt;span style="color:#d14">&amp;#34;张三&amp;#34;&lt;/span>,&lt;span style="color:#d14">&amp;#34;20220226&amp;#34;&lt;/span>,&lt;span style="color:#099">18&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这里&lt;code>auto&lt;/code>是让编译器自己确定类型的意思。上面这种写法是完全利用了C++的类型推导，这也是好多现代语言推荐的形式。不过需要注意的是，使用类型推导后，&lt;code>=&lt;/code>就不能省略了。
有了初始化的变量后，我们就可以用它们完成各种计算任务了。C++为开发者实现了很多内置的计算支持。如数字的加减乘除运算，数组的索引，指针的操作等。还提供了分支&lt;code>if&lt;/code>，&lt;code>switch&lt;/code>，循环&lt;code>while&lt;/code>，&lt;code>for&lt;/code>等语句，为我们提供了更灵活的操作。&lt;/p>
&lt;h3 id="函数">函数&lt;/h3>
&lt;p>变量是编程语言中的最小单位，随着业务的复杂度增加，有些时候中间计算会分散业务的逻辑，增加复杂度。为了更好地组织代码，类型系统增加了 函数来解决这个问题。
函数也是类型，是一种复合类型。它的类型由参数列表，返回值组合而成，也就是说两个函数，假如参数列表和返回值一样，那么它们从编译器的角度来看是等价的。当然光有它们还不够，不然怎么能出现两个参数列表和返回值一样的函数呢。一个完整的函数还需要有个函数体和函数名。所以函数一般是下面这种形式：&lt;/p>
&lt;div class="highlight">&lt;div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
&lt;table style="border-spacing:0;padding:0;margin:0;border:0;">&lt;tr>&lt;td style="vertical-align:top;padding:0;margin:0;border:0;">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">5
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">6
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#998;font-style:italic">//常规函数形式
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#998;font-style:italic">&lt;/span>[&lt;span style="color:#000;font-weight:bold">constexpr&lt;/span>] &lt;span style="color:#a61717;background-color:#e3d2d2">返回值&lt;/span> &lt;span style="color:#a61717;background-color:#e3d2d2">函数名&lt;/span>(&lt;span style="color:#a61717;background-color:#e3d2d2">参数列表&lt;/span>)[&lt;span style="color:#000;font-weight:bold">noexcept&lt;/span>]{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a61717;background-color:#e3d2d2">函数体&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#998;font-style:italic">//返回值后置形式
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#998;font-style:italic">&lt;/span>&lt;span style="color:#000;font-weight:bold">auto&lt;/span> &lt;span style="color:#a61717;background-color:#e3d2d2">函数名&lt;/span>(&lt;span style="color:#a61717;background-color:#e3d2d2">参数列表&lt;/span>)&lt;span style="color:#000;font-weight:bold">-&amp;gt;&lt;/span>&lt;span style="color:#a61717;background-color:#e3d2d2">返回值&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>当一个函数没有函数体的时候，我们通常称之为函数声明。加上函数体就是一个函数定义。&lt;/p>
&lt;div class="highlight">&lt;div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
&lt;table style="border-spacing:0;padding:0;margin:0;border:0;">&lt;tr>&lt;td style="vertical-align:top;padding:0;margin:0;border:0;">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#458;font-weight:bold">void&lt;/span> &lt;span style="color:#900;font-weight:bold">f&lt;/span>(&lt;span style="color:#458;font-weight:bold">int&lt;/span>); &lt;span style="color:#998;font-style:italic">//函数声明
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#998;font-style:italic">&lt;/span>&lt;span style="color:#458;font-weight:bold">void&lt;/span> &lt;span style="color:#900;font-weight:bold">fun&lt;/span>(&lt;span style="color:#458;font-weight:bold">int&lt;/span> value){ &lt;span style="color:#998;font-style:italic">//函数定义，因为有大括号代表的函数体
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#998;font-style:italic">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>以上就是函数的基本框架，接下来我们分别来看一看组成它的各部分。
先说最简单的函数名，&lt;strong>它其实是函数这种类型的一个变量，这个变量的值表示从内存地址的某个位置开始的一段代码块&lt;/strong>。前面也说过之所以能出现两个参数列表和返回值都相同的函数，但是编译器能识别，其主要功劳就在函数名上，所以函数名也和变量名一样，是一种标识符。那假如反过来，函数名相同，但是参数列表或者返回值不同呢，这种情况有个专有名词——函数重载。基于函数是复合类型的认识，它们中只要其中一种不同就算重载。另外，在C++11，还有一种没有名字的函数，称为lambda表达式。lambda表达式是一种类似于直接量的函数值，就像13，&amp;lsquo;c&amp;rsquo;这种，是一种不提前定义函数，直接在调用处定义并使用的函数形式。
参数列表是前面类型定义的升级款。所有前面说的关于变量定义的都适用于它，三种形式的变量定义，多个变量，变量初始化等。不过，它们都有了新名词。参数列表的变量称为形式参数，初始化称为默认参数。同样形参在实际使用的时候需要初始化，不过初始化来自调用方。形式参数没有默认值就需要在调用的时候提供参数，有默认值的可以省略。&lt;/p>
&lt;div class="highlight">&lt;div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
&lt;table style="border-spacing:0;padding:0;margin:0;border:0;">&lt;tr>&lt;td style="vertical-align:top;padding:0;margin:0;border:0;">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#458;font-weight:bold">int&lt;/span> &lt;span style="color:#900;font-weight:bold">plus&lt;/span>(&lt;span style="color:#458;font-weight:bold">int&lt;/span> a,&lt;span style="color:#458;font-weight:bold">int&lt;/span> b&lt;span style="color:#000;font-weight:bold">=&lt;/span>&lt;span style="color:#099">1&lt;/span>){ &lt;span style="color:#998;font-style:italic">//b是一个默认参数
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#998;font-style:italic">&lt;/span> &lt;span style="color:#000;font-weight:bold">return&lt;/span> a&lt;span style="color:#000;font-weight:bold">+&lt;/span>b;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#458;font-weight:bold">int&lt;/span> &lt;span style="color:#900;font-weight:bold">main&lt;/span>(&lt;span style="color:#458;font-weight:bold">void&lt;/span>){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#458;font-weight:bold">int&lt;/span> c&lt;span style="color:#000;font-weight:bold">=&lt;/span>plus(&lt;span style="color:#099">1&lt;/span>); &lt;span style="color:#998;font-style:italic">//没有提供b的值，所以b初始化为1，结果是2
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#998;font-style:italic">&lt;/span> &lt;span style="color:#458;font-weight:bold">int&lt;/span> d&lt;span style="color:#000;font-weight:bold">=&lt;/span>plus(&lt;span style="color:#099">2&lt;/span>,&lt;span style="color:#099">2&lt;/span>); &lt;span style="color:#998;font-style:italic">//a,b都初始化为2，结果是4
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#998;font-style:italic">&lt;/span> &lt;span style="color:#998;font-style:italic">//int f=plus(1,2,3); //plus只有两个形参，也就是两个变量，没法保存三个值，所以编译错误
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#998;font-style:italic">&lt;/span> &lt;span style="color:#000;font-weight:bold">return&lt;/span> &lt;span style="color:#099">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>和参数列表一样，返回值也是一个变量，这个变量会通过&lt;code>return&lt;/code>语句返回给调用者，所以从内存操作来看，它是一个赋值操作。&lt;/p>
&lt;div class="highlight">&lt;div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
&lt;table style="border-spacing:0;padding:0;margin:0;border:0;">&lt;tr>&lt;td style="vertical-align:top;padding:0;margin:0;border:0;">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>std&lt;span style="color:#000;font-weight:bold">::&lt;/span>string msg(){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#000;font-weight:bold">::&lt;/span>string input;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#000;font-weight:bold">::&lt;/span>cin&lt;span style="color:#000;font-weight:bold">&amp;gt;&amp;gt;&lt;/span>input;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">return&lt;/span> input;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#458;font-weight:bold">int&lt;/span> &lt;span style="color:#900;font-weight:bold">main&lt;/span>(&lt;span style="color:#458;font-weight:bold">void&lt;/span>){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">auto&lt;/span> a&lt;span style="color:#000;font-weight:bold">=&lt;/span>msg();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#000;font-weight:bold">::&lt;/span>string b&lt;span style="color:#000;font-weight:bold">=&lt;/span>msg();&lt;span style="color:#998;font-style:italic">//msg返回的input复制到了b中
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#998;font-style:italic">&lt;/span> &lt;span style="color:#000;font-weight:bold">return&lt;/span> &lt;span style="color:#099">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>遗憾的是C++只支持单返回值，也就是一个函数调用最多只能返回一个值，假如有多个值就只能以形参形式返回了，这种方式对于函数调用就不是很友好，所以C++提出了新的解决思路。&lt;/p>
&lt;h3 id="类">类&lt;/h3>
&lt;p>随着业务的复杂度再次增加，函数形参个数可能会增加，或者可能需要返回多个值，然后在多个不同的函数间传递。这样会导致数据容易错乱，并且增加使用者的学习成本。
为了解决这些问题，工程师们提出了面向对象——多个数据打包的技术。表现在语言层面上，就是&lt;strong>用类把一组操作和完成这组操作需要的数据打包在一起&lt;/strong>。数据作为类的属性，操作作为类的方法，使用者通过方法操作内部数据，数据不再需要使用者自己传递，管理。这对于开发者无疑是大大简化了操作。我们称之为面向对象编程，而在函数间传递数据的方式称为面向过程编程。这两种方式底层逻辑其实是一致的，该传递的参数和函数调用一样都不少，但是面向对象的区别是这些繁琐、容易出错的工作交给编译器来做，开发者只需要按照面向对象的规则做好设计工作就好了，剩下的交给编译器。至此，我们的类型系统又向上提升了一级。类不仅是多个类型的聚合体，还是多个函数的聚合体，是比函数更高级的抽象。
可以看下面面向过程编程和面向对象编程的代码对比&lt;/p>
&lt;div class="highlight">&lt;div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
&lt;table style="border-spacing:0;padding:0;margin:0;border:0;">&lt;tr>&lt;td style="vertical-align:top;padding:0;margin:0;border:0;">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">13
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">14
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">15
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">16
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">17
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">18
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">19
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">20
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">21
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">22
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">23
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">24
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">25
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">26
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">27
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">28
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">29
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">30
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">31
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">struct&lt;/span> &lt;span style="color:#458;font-weight:bold">Computer&lt;/span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#458;font-weight:bold">bool&lt;/span> booted;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">friend&lt;/span> std&lt;span style="color:#000;font-weight:bold">::&lt;/span>ostream&lt;span style="color:#000;font-weight:bold">&amp;amp;&lt;/span> &lt;span style="color:#000;font-weight:bold">operator&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;lt;&amp;lt;&lt;/span>(std&lt;span style="color:#000;font-weight:bold">::&lt;/span>ostream&lt;span style="color:#000;font-weight:bold">&amp;amp;&lt;/span> os,&lt;span style="color:#000;font-weight:bold">const&lt;/span> Computer &lt;span style="color:#000;font-weight:bold">&amp;amp;&lt;/span> c){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> os&lt;span style="color:#000;font-weight:bold">&amp;lt;&amp;lt;&lt;/span>&lt;span style="color:#d14">&amp;#34;Computing&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">return&lt;/span> os;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#458;font-weight:bold">void&lt;/span> &lt;span style="color:#900;font-weight:bold">boot&lt;/span>(Computer&lt;span style="color:#000;font-weight:bold">&amp;amp;&lt;/span> c){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> c.booted&lt;span style="color:#000;font-weight:bold">=&lt;/span>&lt;span style="color:#0086b3">true&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#000;font-weight:bold">::&lt;/span>cout&lt;span style="color:#000;font-weight:bold">&amp;lt;&amp;lt;&lt;/span>&lt;span style="color:#d14">&amp;#34;Booting...&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#458;font-weight:bold">void&lt;/span> &lt;span style="color:#900;font-weight:bold">compute&lt;/span>(&lt;span style="color:#000;font-weight:bold">const&lt;/span> Computer&lt;span style="color:#000;font-weight:bold">&amp;amp;&lt;/span> c){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">if&lt;/span>(c.booted){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#000;font-weight:bold">::&lt;/span>cout&lt;span style="color:#000;font-weight:bold">&amp;lt;&amp;lt;&lt;/span>&lt;span style="color:#d14">&amp;#34;Compute with &amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;lt;&amp;lt;&lt;/span>c;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#458;font-weight:bold">void&lt;/span> &lt;span style="color:#900;font-weight:bold">shutdown&lt;/span>(Computer&lt;span style="color:#000;font-weight:bold">&amp;amp;&lt;/span> c){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> c.booted&lt;span style="color:#000;font-weight:bold">=&lt;/span>&lt;span style="color:#0086b3">false&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#000;font-weight:bold">::&lt;/span>cout&lt;span style="color:#000;font-weight:bold">&amp;lt;&amp;lt;&lt;/span>&lt;span style="color:#d14">&amp;#34;Shutdown...&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#458;font-weight:bold">int&lt;/span> &lt;span style="color:#900;font-weight:bold">main&lt;/span>(&lt;span style="color:#458;font-weight:bold">void&lt;/span>){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">auto&lt;/span> c&lt;span style="color:#000;font-weight:bold">=&lt;/span>Computer();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> boot(c);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> compute(c);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> shutdown(c);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">return&lt;/span> &lt;span style="color:#099">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>面向过程最主要的表现就是，开发者需要在函数间传递数据，并维护数据状态，上面例子中的数据是&lt;code>c&lt;/code>。&lt;/p>
&lt;div class="highlight">&lt;div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
&lt;table style="border-spacing:0;padding:0;margin:0;border:0;">&lt;tr>&lt;td style="vertical-align:top;padding:0;margin:0;border:0;">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">13
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">14
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">15
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">16
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">17
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">18
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">19
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">20
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">21
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">22
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">23
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">24
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">25
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">26
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">27
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">28
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">29
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">30
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">31
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">32
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">struct&lt;/span> &lt;span style="color:#458;font-weight:bold">Computer&lt;/span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#458;font-weight:bold">bool&lt;/span> booted;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">friend&lt;/span> std&lt;span style="color:#000;font-weight:bold">::&lt;/span>ostream&lt;span style="color:#000;font-weight:bold">&amp;amp;&lt;/span> &lt;span style="color:#000;font-weight:bold">operator&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;lt;&amp;lt;&lt;/span>(std&lt;span style="color:#000;font-weight:bold">::&lt;/span>ostream&lt;span style="color:#000;font-weight:bold">&amp;amp;&lt;/span> os,&lt;span style="color:#000;font-weight:bold">const&lt;/span> Computer &lt;span style="color:#000;font-weight:bold">&amp;amp;&lt;/span> c){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> os&lt;span style="color:#000;font-weight:bold">&amp;lt;&amp;lt;&lt;/span>&lt;span style="color:#d14">&amp;#34;Computing&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">return&lt;/span> os;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#458;font-weight:bold">void&lt;/span> &lt;span style="color:#900;font-weight:bold">boot&lt;/span>(){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> booted&lt;span style="color:#000;font-weight:bold">=&lt;/span>&lt;span style="color:#0086b3">true&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#000;font-weight:bold">::&lt;/span>cout&lt;span style="color:#000;font-weight:bold">&amp;lt;&amp;lt;&lt;/span>&lt;span style="color:#d14">&amp;#34;Booting...&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#458;font-weight:bold">void&lt;/span> &lt;span style="color:#900;font-weight:bold">compute&lt;/span>(){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">if&lt;/span>(booted){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#000;font-weight:bold">::&lt;/span>cout&lt;span style="color:#000;font-weight:bold">&amp;lt;&amp;lt;&lt;/span>&lt;span style="color:#d14">&amp;#34;Compute with &amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;lt;&amp;lt;&lt;/span>&lt;span style="color:#000;font-weight:bold">this&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#458;font-weight:bold">void&lt;/span> &lt;span style="color:#900;font-weight:bold">shutdown&lt;/span>(){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> booted&lt;span style="color:#000;font-weight:bold">=&lt;/span>&lt;span style="color:#0086b3">false&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#000;font-weight:bold">::&lt;/span>cout&lt;span style="color:#000;font-weight:bold">&amp;lt;&amp;lt;&lt;/span>&lt;span style="color:#d14">&amp;#34;Shutdown...&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#458;font-weight:bold">int&lt;/span> &lt;span style="color:#900;font-weight:bold">main&lt;/span>(&lt;span style="color:#458;font-weight:bold">void&lt;/span>){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">auto&lt;/span> c&lt;span style="color:#000;font-weight:bold">=&lt;/span>Computer();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> c.boot();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> c.compute();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> c.shutdown();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">return&lt;/span> &lt;span style="color:#099">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>可以看出面向对象的代码最主要的变化是，方法的参数变少了，但是可以在方法里面直接访问到类定义的数据。另一个变化发生在调用端。调用端是用数据调用方法，而不是往方法里面传递数据。这也是面向对象的本质——以数据为中心。
当然，类的封装功能只是类功能的一小部分，后面我们会涉及到更多的类知识。作为初学者，我们了解到这一步就能读懂大部分代码了。&lt;/p>
&lt;h3 id="总结">总结&lt;/h3>
&lt;p>类型系统是一门语言的基本构成部分，它支撑着整个系统的高级功能，很多高级特性都是在类型系统的基础上演化而来的。所以学习语言的类型系统有个从低到高，又从高到低的过程，从最基础的类型开始，学习如何从低级类型构筑出高级类型，然后站在高级类型的高度上，审视高级类型是怎样由低级类型构筑的。这一上一下，一高一低基本上就能把语言的大部分特性了解清楚了。
低级类型更偏向于让编译器更好地工作，高级类型偏向于让开发者更好地工作，C++从普通类型，函数，类提供了各个层级的支持，让开发者有更多自由的选择，当然也就增加了开发者的学习难度。但是开发者并不是都需要所有选择的，所以我觉得正确的学习应该是以项目规模为指导的。一些项目，完全用不到面向对象，就可以把精力放在打造好用的函数集上。而有的项目，面向对象是很好的选择，就需要在类上花费时间。回到开头的积木例子，选用什么积木完全看我们想搭什么模型，要是没有合适的积木，我们可以自己创造。这就是C++的迷人之处。&lt;/p></description></item><item><title>现代C++学习指南-方向篇</title><link>https://hongui.github.io/post/%E7%8E%B0%E4%BB%A3C++%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97-%E6%96%B9%E5%90%91%E7%AF%87.html</link><pubDate>Sat, 25 Jun 2022 08:51:01 +0800</pubDate><guid>https://hongui.github.io/post/%E7%8E%B0%E4%BB%A3C++%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97-%E6%96%B9%E5%90%91%E7%AF%87.html</guid><description>&lt;p>C++是一门有着四十年历史的语言，先后经历过四次版本大升级（诞生、98、11、17（20），14算小升级）。每次升级都是很多问题和解决方案的取舍。了解这些历史，能更好地帮助我们理清语言的发展脉络。所以接下来我将借它的发展历程，谈一谈我对它的理解，最后给出我认为比较合理的学习路线指南。&lt;/p>
&lt;h3 id="c0诞生">C++0——诞生&lt;/h3>
&lt;p>C++诞生的目的是为了解决两个主要问题——性能和抽象。性能指的是拥有像C一样的底层访问能力和执行效率，抽象则意在语言层面提供对问题的描述能力和思考方法。这是C++的立命之本，也是C++经久不衰的原因。对于这两个目标，Bjarne Stroustrup想到的解决方法是充分利用现有的C的技术和工具，然后提供类来解决抽象问题。基于这个前提，我们就可以看出类是C++学习路上的第一个关卡。&lt;/p>
&lt;p>C++认为类是一种抽象思维，类的相关特性都是为抽象提供服务的。所以C++中的类比其他面向对象的类提供了更多的能力，所以也具有更多的复杂性。为了描述这种复杂性，就不得不提到C++的两个特点，静态类型安全，资源管理。&lt;/p>
&lt;p>静态类型安全可以帮助开发者定义出更合理合法的自定义类，如通过操作符重载，自定义类可以写出和基本类型一样的简洁代码。可以通过构造函数避免隐式类型转换而造成的运行时错误，也可以通过明确阻止某些操作阻止自己的类被滥用。所有的自主权都由开发者决定。所以假如我们是库的使用者，完全可以不用关心这些细节，我们只需要按照一般的语言一样写代码，遇到不合理的，编译器会直接告诉我们，不用担心这些问题会隐匿在程序运行时的某个时刻。&lt;/p>
&lt;p>资源管理则可以帮助开发者提供资源管理的指导和支撑。资源有很多种，而在计算机中的资源大部分都是有限的，必须有借有还，而且借和还必须一一对应，不然就是内存泄漏。在C时代，资源管理靠的是开发者对资源的全局掌控力，语言层面没有提供更好的支持。为了更好地支持资源管理，C++提出了构造函数和析构函数，两者分别可以对应资源的获取和回收。但是很多时候资源不仅仅供自己使用，还需要提供给外部使用。为了配合这种资源的转移，C++又提供了移动和复制两种操作来支持。&lt;/p>
&lt;p>综上，总结一下，C++的类提供了很多特性，但是不是所有的特性都是开发者需要的。&lt;code>开发者在定义类的时候需要考虑的主要问题是，对这个类提供哪些支持，然后再在这些提供的功能中选择合适的语法特性来实现。&lt;/code>构造函数和析构函数可以提供很好的一一对应的操作，移动和复制则提供了资源在对象中怎么共享，操作符重载则可以让类使用更加简洁和优雅。&lt;/p>
&lt;h3 id="c98标准化">C++98——标准化&lt;/h3>
&lt;p>C++98最大的升级是模板和异常，并且搭配了好用的标准库。&lt;/p>
&lt;p>模板在C++中的地位怎么强调都不为过。它属于另一种抽象机制。所以它解决的也是抽象问题。C++中的类解决的是相似概念的抽象，更注重概念间的相似性。而模板解决的是通用问题的抽象，更注重概念的通用性。两者共同构成了C++的两大抽象基石。前面已经谈过了类，这里我们着重说一下模板。&lt;/p>
&lt;p>得益于C++强大的静态类型安全，模板编写起来也很简单，普通的函数怎么写，它就可以怎么写，无非就是把特定类型换成泛型。但是，另一方面，模板还可以做得更多。模板可以支持多种参数，多个参数，限定参数，并且是类型安全的。更厉害的是，它还可以指定值。合理地配合使用类型和值，基本上就能解决大部分问题了。&lt;/p>
&lt;p>说起异常。对于普通开发者没有多大吸引力。因为异常主要解决的问题是怎样告诉调用者发生错误了，是什么错误，并将执行能力转移到调用者一方。而我们大部分时间开发的都是业务代码，我们知道发生了什么，该怎样解决，大部分情况下是不太需要异常的。当然，并非说异常一无是处，异常对库开发者来说异常重要。对于库开发者来说，他需要在异常发生后，告诉调用者发生了错误，操作没有办法顺利执行。但是很多时候，库开发者并不知道调用者该怎样处理这个错误，是忽略呢，还是清理现场。异常机制提供了抛异常和异常捕获两种方式来支持库开发者和使用者。&lt;/p>
&lt;p>对于新手来说，可能不太喜欢标准库，而倾向于自己写。这不是个好主意。标准库是经过工业级测试的代码，可以在绝大部分情况下正常工作，而自己手写虽然成就感更好，但是更可能携带BUG。早期的标准库提供的功能有限，只有&lt;code>string&lt;/code>，输入输出流，位运算，三大容器，和一些小算法。不过，这些都足够我们日常使用了，尤其是现在标准库功能越来越完善了，大部分编程场景都能找到合适的工具来完成，完全可以放弃手写特定代码了。&lt;/p>
&lt;p>C++98更多着眼于标准化，模板是一种标准，标准库也是一种标准。自此，&lt;code>C++的三座大山算是构筑完成了，类，模板，标准库。&lt;/code>每一项都为C++带来了无限可能和旺盛生命力。&lt;/p>
&lt;h3 id="c11全新语言">C++11——全新语言&lt;/h3>
&lt;p>C++11的改动是革命性的，但是还保留着难以置信的兼容性，是非常不容易的。这里我们不细谈具体的特性和细节，只从大方向上来个笼统的概述。&lt;/p>
&lt;p>首先直观的变化是在类型系统上，C++11将类型系统做了尽可能的规范化和统一化。&lt;/p>
&lt;ul>
&lt;li>通过同意初始化规范了对象的初始化形式；&lt;/li>
&lt;li>通过&lt;code>auto&lt;/code>简化了类型声明的形式；&lt;/li>
&lt;li>通过&lt;code>nullptr&lt;/code>规范化了空指针的形式；&lt;/li>
&lt;li>通过&lt;code>enum class&lt;/code>提供了静态类型安全的枚举；&lt;/li>
&lt;li>通过别名简化了类型书写的方式；&lt;/li>
&lt;li>还有其他更多更多&lt;/li>
&lt;/ul>
&lt;p>类型系统的改进意味着开发者可以写出更简洁，更规范，也更安全的代码，但是对编译器的挑战却是巨大的，所以，很长时间内，C++11都没有得到很好的支持，同时也妨碍了C++的发展。&lt;/p>
&lt;p>除了类型系统，另一项大改进就是提供了对线程的支持。C++11的标准库中提供了线程，条件对象，锁等线程相关的工具，这对库开发者来说是革命性的。在几乎不损失性能的情况下，提供了跨平台的线程支持，这极大地提高了库的稳定性和性能，也节省了很多平台测试时间，不得不说是顶呱呱。&lt;/p>
&lt;p>另一个重要升级就是资源管理了。标准库提供了&lt;code>unique_ptr&lt;/code>，&lt;code>shared_ptr&lt;/code>来协助资源管理。同时为了更出色的性能，引入了右值引用和移动语义。右值引用和移动语义听起来很高端，实际上就是解决一个问题，避免大对象的反复销创建和销毁，转而使用代价更低的移动。根本思路就是两条，对于直接量提供了右值引用，以增加它的生存时间，使之可以像普通变量一样通过参数传递。而对于变量来说，提供了移动语义，将不再需要使用的对象管理的资源转移到另一个对想象中。同时增加了移动构造，复制构造方式来优化函数的返回值。可谓是榨干了计算机的每一寸内存。&lt;/p>
&lt;p>C++11无疑是C++里程碑式的更新，在对历史遗留问题清理的同时，引领了接下来C++的发展方向，它的作用是承上启下的。对类型系统的改进无疑弥补了最开始从C继承来的一些缺陷。同时也充分考虑了现代计算机的发展，引入了线程支持。在内存管理上也是更上一层楼，引入了智能指针，移动语义，右值引用。它基本上抛开了历史束缚，但依旧是不忘使命，依旧是奔着&lt;code>更好的静态类型支持，更多的自主性，更高效的资源管理，更克制的特性支持来展开的&lt;/code>。&lt;/p>
&lt;h3 id="c1720新生">C++17，20——新生&lt;/h3>
&lt;p>C++17和C++20应该是相辅相成的，绝大部分特性都已经得到支持和完善了。但是由于编译器的限制，我用的特性比较少。C++17比较期待的是跨平台的文件系统支持，这对于大部分应用开发者来说无疑是激动和喜悦的。另一个我喜欢的特性是结构化绑定，这个特性我在Python里面用得很顺手，当然现在基本上所有现代语言都支持它了。&lt;/p>
&lt;p>而对于C++20就用得更少了，更多的是示例性质的。我比较在意的是模块和协程，但是由于了解得不深入，就不详谈了。&lt;/p>
&lt;h3 id="什么是c的基本面">什么是C++的基本面&lt;/h3>
&lt;p>从前几个章节不难看出，我着重夸了C++的类，模板，标准库，类型系统。这些都是我觉得学习C++比较重要的方面。但对于初学者来说，我觉得&lt;code>类型系统和标准库&lt;/code>就足够了。&lt;/p>
&lt;p>类型系统是一门语言最小的单元了，在C++中它包括类型声明，对象初始化，函数传参，函数返回值。在学习初期学多少特性都是骗人的，实际上手还是需要从这个最小的单元入手。比如声明一个变量，这个变量该是什么类型的，可以是指针吗，可以是引用吗。定义函数的时候，参数列表该怎样确定，返回值是什么，怎样才能让函数传参高效，怎样阻止和避免无用的参数检查，返回值该是什么类型，等等，这些都是在实际项目中需要直接面对的问题。所以对类型系统的学习，是写出高效可用代码的第一步，也是最重要的一步。考虑的问题越深入、全面，得到的回报就越大。&lt;/p>
&lt;p>标准库则是提供了很好的算法支持和容器支持，可以帮助我们写更健壮的代码。对标准库接口的学习，一方面可以促进对类型系统的认识，另一方面也是积累好习惯的地方。&lt;/p>
&lt;p>有了这两项技能的支持，我觉得已经能够写出很棒的应用程序了。但是对于库设计者来说，写出很好的库还需要对类和模板有着更深刻的理解。&lt;/p>
&lt;p>一个定义良好的类需要对对象的生命周期进行严格的控制，构造，转移，销毁都是需要控制的。对于需要支持的操作，类设计者应该提供尽可能便捷和高效的支持，对于类禁止的操作，类设计者应该明确禁止，防止发生误用或者隐藏BUG。所以对于类，着重需要关注的是资源的构造，以及在多个对象间的传递和共享。容易发生问题的地方在于函数传参和返回值上，特别是层层调用的函数上，高效和安全就是必须要考虑的了，所以这就回到了前面提到的类型系统，只有对它有了比较深入的了解，才能设计出比较好的类。&lt;/p>
&lt;p>模板则是类的另一方面，它和类的概念虽然是不同的，但是思路上却是相通的。模板和Java里面的泛型相似，却更加灵活和重要，是和类一样的高度。模板需要考虑的问题是，提供什么算法，什么对象可以使用这个算法，怎样避免和阻止错误对象的滥用，在使用过程中怎样尽可能利用编译错误来避免运行时错误。所以它是比类更进一步的抽象概念，对开发者有着比类更高的要求。&lt;/p>
&lt;h3 id="c学习路线图">C++学习路线图&lt;/h3>
&lt;p>从上一章节，可以看出我推荐的学习路线是类型系统，到标准库，到类，最后才到模板。其他的语言细节不是说不重要，而是在学习这四大板块的同时会融入到学习过程中，没必要单独去学习和理解，毕竟细节是繁杂而且散乱的，不会增加对语言的掌握，却会打乱学习节奏，分散注意力。&lt;/p>
&lt;p>类型系统的学习又可以按以下步骤进行&lt;/p>
&lt;ul>
&lt;li>变量声明（常量和编译时常量）&lt;/li>
&lt;li>初始化（统一初始化，赋值）&lt;/li>
&lt;li>函数定义，函数参数定义，返回值（引用，指针的使用）&lt;/li>
&lt;li>简单类定义，不涉及到内存管理，资源管理&lt;/li>
&lt;/ul>
&lt;p>标准库可以按以下步骤进行&lt;/p>
&lt;ul>
&lt;li>智能指针（&lt;code>shared_ptr&lt;/code>,&lt;code>unique_ptr&lt;/code>等）&lt;/li>
&lt;li>字符串&lt;/li>
&lt;li>容器类对象（&lt;code>list&lt;/code>,&lt;code>map&lt;/code>等）。&lt;/li>
&lt;li>标准输入输出使用&lt;/li>
&lt;li>线程库使用&lt;/li>
&lt;li>通用算法（&lt;code>sort&lt;/code>，&lt;code>find&lt;/code>等）&lt;/li>
&lt;/ul>
&lt;p>类可以按以下步骤进行&lt;/p>
&lt;ul>
&lt;li>类的构造函数，移动构造，复制构造&lt;/li>
&lt;li>类的运算符重载&lt;/li>
&lt;li>继承&lt;/li>
&lt;li>虚函数&lt;/li>
&lt;li>多继承&lt;/li>
&lt;/ul>
&lt;p>模板可以按以下步骤进行&lt;/p>
&lt;ul>
&lt;li>模板函数&lt;/li>
&lt;li>模板类&lt;/li>
&lt;li>模板递归&lt;/li>
&lt;li>模板特化&lt;/li>
&lt;/ul>
&lt;h3 id="总结">总结&lt;/h3>
&lt;p>C++细节繁多，初学者容易一头扎进语法细节而不自知，最终白白浪费了大把时间不算，还严重打击了学习积极性。本篇的主旨是在帮初学者理清这门语言的主要脉络，并提供我认为比较科学的学习路线，希望对初学者有所帮助。&lt;/p>
&lt;p>C++语言是一门通用型语言，有着很长的发展历史。这导致了它有着不小的历史包袱，所以在引入语言特性和怎样引入的事情上一直保持着克制。但是为了更好地服务于现代硬件和简化开发者工作，又不得不引入新特性，遗弃一些老特性。基于这种原因，语言表现出了一定的复杂性和杂乱性。但是它的核心方向是明确的，就是为了更好地解决效率和抽象问题。抓住这两个核心，再结合这份指南，先难后易，抓大放小，再加上一点归纳和总结就能很好地掌握这门语言的大部分内容。对于指南外的特性，在实际项目中需要了再学习完全是来得及的，毕竟大部分时间我们用到的特性也是很少的一部分，应该把精力花在性价比最高的部分。&lt;/p></description></item></channel></rss>