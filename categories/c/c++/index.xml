<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>C/C++ on 低头沉思</title><link>https://hongui.github.io/categories/c/c++/</link><description>Recent content in C/C++ on 低头沉思</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><atom:link href="https://hongui.github.io/categories/c/c++/index.xml" rel="self" type="application/rss+xml"/><item><title>Android-JNI开发概论</title><link>https://hongui.github.io/post/Android-JNI%E5%BC%80%E5%8F%91%E6%A6%82%E8%AE%BA.html</link><pubDate>Sun, 12 Sep 2021 21:34:45 +0800</pubDate><guid>https://hongui.github.io/post/Android-JNI%E5%BC%80%E5%8F%91%E6%A6%82%E8%AE%BA.html</guid><description>什么是JNI开发 JNI的全称是Java Native Interface，顾名思义，这是一种解决Java和C/C++相互调用的编程方式。它其实只解决两个方面的问题，怎么找到和怎么访问。 弄清楚这两个话题，我们就学会了JNI开发。需要注意的是，JNI开发只涉及到一小部分C/C++开发知识，遇到问题的时候我们首先要判断是C/C++的问题还是JNI的问题，这可以节省很多搜索和定位的时间。
用JVM的眼光看函数调用 我们知道Java程序是不能单独运行的，它需要运行在JVM上的，而JVM却又需要跑在物理机上，所以它的任务很重，既要处理Java代码，又要处理各种操作系统，硬件等问题。可以说了解了JVM，就了解了Java的全部，当然包括JNI。所以我们先以JVM的身份来看看Java代码是怎样跑起来的吧（只是粗略的内容，省去了很多步骤，为了突出我们在意的部分）。
运行Java代码前，会先启动一个JVM。在JVM启动后，会加载一些必要的类，这些类中包含一个叫主类的类，也就是含有一个静态成员函数，函数签名为public static void main(String[] args)的方法。资源加载完成后，JVM就会调用主类的main方法，开始执行Java代码。随着代码的执行，一个类依赖另一个类，层层依赖，共同完成了程序功能。这就是JVM的大概工作流程，可以说JVM就好比一座大桥，连接着Java大山和native大山。
现在问题来了，在Java程序中，某个类需要通过JNI技术访问JVM以外的东西，那么它需要怎样告诉我（我现在是JVM）呢？需要一种方法　把普通的Java方法标记成特殊，这个标记就是native关键字（使用Kotlin时虽然也可以使用这个关键字，但是Kotlin有自己的关键字external）。当我执行到这个方法时，看到它不一样的标记，我就会从其他地方而不是Class里面寻找执行体，这就是一次JNI调用。也就是说对于Java程序来说，只需要将一个方法标记为native，在需要的地方调用这个方法，就可以完成JNI调用了。但是对于我，该怎样处理这一次JNI调用呢？其实上面的寻找执行体的过程是一个跳转问题，在C/C++的世界，跳转问题就是指针问题。那么这个指针它应该指向哪里呢？
C/C++代码是一个个函数（下文会将Java方法直接用方法简称，而C/C++函数直接用函数简称）组合起来的，每一个函数都是一个指针，这个特性恰好满足我的需要。但是对于我，外面世界那么大，我并不知道从哪里，找什么东西，给我的信息还是不够。为了限定范围，我规定，只有通过System.loadLibrary(“xxx”)加载的函数，我才会查找，其余的我直接罢工（抛错）。这一下子减轻了我的工作量，至少我知道从哪里找了。
确定了范围，下一步就是在这个范围里确定真正的目标了。Java世界里怎样唯一标识一个类呢，有的人会脱口而出——类名，其实不全对，因为类名可能会重名，我们需要全限定的类名，也就是包名加类名，如String的全限定类名就是java.lang.String。但是这和我们查找native的方法有什么联系呢。当然有联系，既然一个全限定的类名是唯一的，那么它的方法也是唯一的，那么假如我规定以这个类的全限定类名加上方法名作为native函数的函数名，这样我是不是就可以通过函数名的方式找到native的函数看呢，答案是肯定的，但是有瑕疵，因为Java系统支持方法重载，也就是一个类里面，同名的方法可能有多个。那么构成重载的条件是什么呢，是参数列表不同。所以，结果就很显然了，我在前面的基础上再加上参数列表，组合成查找条件，我是不是就可以唯一确定某一个native函数了呢，这就是JNI的静态注册。
不过，既然我只需要确定指针的指向，那么我能不能直接给指针赋值，而不是每次都去查找呢，虽然我不知道累，但是还是很耗费时间的。对于这种需求，我当然也是满足的啦，你直接告诉我，我就不找了，我还乐意呢。而且，既然你都给我找到了，我就不需要下那么多规定了，都放开，你说是我就相信你它是。这就是JNI的动态注册。
JNI的函数注册 上一节我们通过化身JVM的方式了解了JNI函数注册的渊源，并且引出了两种函数注册方式。从例子上，我们也可以总结出两种注册方式的特点
注册类型 优点 缺点 静态注册 JVM自动查找 实现简单 函数名贼长，限制较多 查找耗时 动态注册 运行快 对函数名无限制 实现复杂 那么具体怎么做呢？我们接着往下说。
静态注册 虽然静态注册限制比较多，但是都是一些浅显的规则，更容易实施，所以先从静态注册开始讲解。
静态注册有着明确的开发步骤
编写Java类，声明native方法; 使用java xxx.java将Java源文件编译为class文件 使用javah xxx生成对应的.h文件 构建工具中引入.h文件 实现.h文件中的函数 上面的这个步骤是静态开发的基本步骤，但是其实在如今强大的IDE面前，这些都不需要我们手动完成了，在Android Studio中，定义好native方法后，在方法上按alt + enter就可以生成正确的函数签名，直接写函数逻辑就可以了。但是学习一门学问，我们还是要抱着求真，求实的态度，所以我用一个例子来阐述一下这些规则，以加深读者的理解。
Test.java
1 2 3 4 5 package me.hongui.demo public class Test{ native String jniString(); } native-lib.cpp
1 2 3 4 5 #include &amp;lt;jni.h&amp;gt; extern &amp;#34;C&amp;#34; jstring Java_me_hongui_demo_Test_jniString(JNIEnv *env, jobject thiz) { // TODO: implement jniString() } 上面就是一个JNI函数在两端声明的例子，不难发现</description></item><item><title>CMake个人理解和使用</title><link>https://hongui.github.io/post/CMake%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3%E5%92%8C%E4%BD%BF%E7%94%A8.html</link><pubDate>Mon, 09 Aug 2021 19:21:49 +0800</pubDate><guid>https://hongui.github.io/post/CMake%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3%E5%92%8C%E4%BD%BF%E7%94%A8.html</guid><description>前言 CMake是一个构建工具，通过它可以很容易创建跨平台的项目。通常使用它构建项目要分两步，通过源代码生成工程文件，通过工程文件构建目标产物（可能是动态库，静态库，也可能是可执行程序）。使用CMake的一个主要优势是在多平台或者多人协作的项目中，开发人员可以根据自己的喜好来使选择IDE，不用受其他人工程配置的影响，它有点像跨平台的IDE，通过它配置好相关设置之后，可以在多个平台无缝衔接，提高开发效率。
最简单的CMake工程 项目搭建 一个用CMake来管理的项目，其项目根目录通常会包含一个CMakeLists.txt的文件，当然子目录可能也有，这种情况我们稍后再说。我们先从最简单的项目开始。以下就是一个最简单的工程示例：
CMakeProject | CMakeLists.txt | main.cpp 这就是完整的可以跑起来的最小项目了。按照顺序，我们来看看文件里的内容
CMakeLists.txt
# 设置版本号 cmake_minimum_required(VERSION 3.10) # 设置项目名 project(CMakeProject) # 设置产物和源码的关联 add_executable(${CMAKE_PROJECT_NAME} main.cpp) 说明：
CMake中命令不区分大小写 以#开始的是备注 引用变量语法${变量名} 所以文档中真正的有效内容就三行，
cmake_minimum_required(VERSION 3.10)设置了CMake支持的最低版本，VERSION是参数名，后面是版本号，可以根据自己的需要修改。 注意参数名和参数是以空白符分隔的，不是逗号， 不然会报错。 project(CMakeProject)CMake中字符串可以带引号或者不带，效果是一致的，这一行就是配置了项目名，如生成的Visual Studio的工程名就是依据这个名字来的。 add_executable(${CMAKE_PROJECT_NAME} main.cpp) 才是真正管理源码和目标产物的地方，这里我们使用了引用变量的写法，而文件中没有定义这个变量，说明这个变量存在于CMake中，在CMake还有很多预定义的变量，我们可以直接通过这种方式引用，上面的写法是将项目名设置为产物的名字，当然也可以直接填字符串，取个另外的名字都是可以的。后面的main.cpp则是用来生成产物的源码路径，这就是CMake最灵活的地方。源码路径可以是多样的，查找出来的，直接写的，相对路径，绝对路径都可以。 多个源码的话就用空白符分隔，依次写就行了。 在上面的配置文件中，我们配置了它的源文件为main.cpp，我们想通过它来生成一个可执行的程序，内容也很简单: #include &amp;lt;iostream&amp;gt; int main() { std::cout&amp;lt;&amp;lt;&amp;#34;hello CMake&amp;#34;&amp;lt;&amp;lt;std::endl; return 0; } 项目编译与执行 准备工作已经做完，接下来我们就要使用CMake生成可执行文件了。
第一步当然是要安装CMake啦，这是下载地址 !Download ，根据自己的平台选择下载即可，安装完成之后需要把它添加到环境变量中，便于我们在任何地方都能方便使用。 安装了CMake以后，打开命令行工具，进入到刚才创建的项目根目录，也就是进入到存着CMakeLists.txt和main.cpp的目录，下一步准备生成项目。
通常为了不影响和污染当前的工作环境，我们会选择新建一个目录来存放生成的工程文件，以下我主要以Windows平台为主要平台讲解，其他平台基本一致。
mkdir build #创建文件夹，存储工程文件； cd build #切换cmake工作目录; cmake .. #生成项目文件； 这三步执行完后，我们就可以在build文件夹下看到里面已经生成了一个Visual Studio的工程，我们可以直接用Visual Studio打开这个工程，按照我们的习惯执行编译和调试。当然，假如想最快地生成可执行文件，我还是推荐使用CMake。
使用CMake执行编译，只需要在上一步的基础上（也就是已经成功执行了上面的三个步骤）再执行一个命令cmake --build .</description></item></channel></rss>