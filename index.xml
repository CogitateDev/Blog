<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>低头沉思</title><link>https://hongui.github.io/</link><description>Recent content on 低头沉思</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Wed, 20 Jul 2022 22:15:05 +0800</lastBuildDate><atom:link href="https://hongui.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>关于我</title><link>https://hongui.github.io/about.html</link><pubDate>Tue, 26 Jul 2022 23:35:00 +0800</pubDate><guid>https://hongui.github.io/about.html</guid><description>个人简介 喜欢编程，喜欢一个人
技术栈 Android Kotlin C++ Python JavaScript HTML/CSS 联系方式 QQ:632518410
E-Mail:honguilee@163.com</description></item><item><title>现代C++学习指南-标准库</title><link>https://hongui.github.io/post/%E7%8E%B0%E4%BB%A3C++%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97-%E6%A0%87%E5%87%86%E5%BA%93.html</link><pubDate>Wed, 20 Jul 2022 22:15:05 +0800</pubDate><guid>https://hongui.github.io/post/%E7%8E%B0%E4%BB%A3C++%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97-%E6%A0%87%E5%87%86%E5%BA%93.html</guid><description>在[上一章]( https://www.yuque.com/docs/share/adb5b1e4-f3c6-46fd-ba4b-4dabce9b4f2a?# 《现代C++学习指南-类型系统》)我们探讨了C++的类型系统，并提出了从低到高，又从高到低的学习思路，本文就是一篇从高到低的学习指南，希望能提供一种新的视角。
什么是标准库 编程语言一般分为两个部分，一部分是语法部分，如上一章的类型系统，另一部分则是用这套语法完成的预定义的工具集，如本文的主题——标准库。标准库是一堆我们写代码时直接可以用的代码，就像是我们提前写好的一样，不仅如此，标准库还是跨平台的，还是经过工业级测试的，所以标准库有着靠谱，安全的特点。 C++标准库包括很多方面，有类vector、string等,有对象std::cin，std::cout等，还有函数move，copy等，所以一般按功能来对它们分类
容器类 算法类 智能指针 线程相关 其他 当然，这些还不是全部，标准库是在不断扩充和完善的，学习标准库的宗旨也应该是学习它们的使用场景，而不是深入用法。比如容器类中就有很多功能类似的类，不同的业务场景有不同的选择。通过对它们的了解，我们更容易写出高效，简洁的代码。
容器类 容器类就是帮助管理一组数据的类，根据实现方式的不同，分为有序列表，无序列表和映射。 有序列表中的有序是指，数据组保存在一块连续的内存区域里，可以通过插入时的索引直接定位到原数据。因为数据是按顺序存入的，所以中途假如需要删除或者新增数据，在操作位置右边的数据都需要移动，操作的代价就比较大。由此也可看出它们的优势是顺序插入和尾部修改，还有直接查找，这方面的代表就是array，vector。 array是对原始数组的封装，并且解决了传递数组变成指针这样的问题，但是缺点是它的大小是固定的，适合用在数据量已知的情况。而vector又是对array的增强，不仅能完成所有array的操作，并且大小可变，所以绝大部分情况下，选择vector都是理想的选择。 无序列表的元素是单独存储的，相互之间用指针来查找相邻元素，由于指针可以轻易修改指向的指，所以对相邻元素的修改就变得很快捷。同样的道理，查找相邻元素只能靠指针跳转，查找某个值需要从一个指针开始查找，一次跳转一条数据，直到找到目标或者没有数据为止。所以无序列表的优势是快速地删除和插入新数据，不适合查找，其代表有list，forward_list。显然，有序列表和无序列表是互补的，我们在实际项目中，应该根据数据的操作来确定选择哪种容器。 映射则融合了有序列表和无序列表的优点，既可以快速插入和删除，又可以快速查找。为了满足各种使用场景，C++提供了map，multimap，unordered_map，unordered_multimap。从名字上就能看出来它们的差别。为了直观，我直接列了一个表
是否排序 是否支持相同值 速度 unordered_map ❌ ❌ ❤️❤️❤️❤️ map ✅ ❌ ❤️❤️ multimap ✅ ✅ ❤️ unordered_multimap ✅ ✅ ❤️❤️❤️ 映射存储的是两个值，不同的类型实现方式不一样。由于map是需要排序的，所以通常它的实现是一种平衡二叉树，键就是它排序的依据。 而unordered_map是不需要排序的，所以它的实现通常是哈希表，即根据哈希函数的确定索引位置继而确定存储位置。 综上，容器类提供了一种操作多个同类型数据的接口，开发者通过对容器类方法的调用，可以实现对容器内数据的增删改查。大部分情况下，vector都是靠谱的选择，它提供了全功能的数据操作接口，支持动态长度，索引查询，并且简单高效。如果需要频繁地插入或者删除操作，也可以考虑list或者forward_list。map可以让数据保持有序，需要更快的速度而不是排序的话unorderer_map是更好的选择，如果相同值会出现多次就可以使用对应的multi版本。另外容器类也是很好的数据结构学习资源，C++的容器类几乎提供了数据结构中所有的形式，对数据结构越熟悉选择的容器类就越完美。
算法 之所以将算法放在容器类后面，是因为算法大部分是对容器类操作的加强，算法都定义在algorithm文件头里。这些算法都是短小精悍的，可以大大增加代码可读性，并且妥善处理了很多容易遗忘的边界问题。功能上可以分为增删改查几种操作，可以在实际有需要的时候在查看文档，具体可以参阅 这里 智能指针 很早以前，我对智能指针的态度不是很好。因为刚开始学习C++时我就知道，不能单独使用指针，要把指针封装在类里，利用类的构造函数和析构函数管理指针，也就是RAII。最开始我以为这就够了,直到我遇到下面这种情况
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 public: Ptr():p{ new int } {} ~Ptr() { delete p; } int&amp;amp; get() { return *p; } void set(const int value) { *p = value; } private: int* p; }; void use(Ptr p) { //传进来的是复制构造出来的p&amp;#39;,函数返回后p&amp;#39;被销毁啦，两个指针指向的地址被回收，外面的p指针成为了野指针 } int main() { Ptr p; p.</description></item><item><title>现代C++学习指南-类型系统</title><link>https://hongui.github.io/post/%E7%8E%B0%E4%BB%A3C++%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97-%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F.html</link><pubDate>Sun, 26 Jun 2022 11:11:59 +0800</pubDate><guid>https://hongui.github.io/post/%E7%8E%B0%E4%BB%A3C++%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97-%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F.html</guid><description>在前一篇，我们提供了一个方向性的指南，但是学什么，怎么学却没有详细展开。本篇将在前文的基础上，着重介绍下怎样学习C++的类型系统。
写在前面 在进入类型系统之前，我们应该先达成一项共识——尽可能使用C++的现代语法。众所周知，出于兼容性的考虑，C++中很多语法都是合法的。但是随着新版本的推出，有些语法可能是不推荐或者是需要避免使用的。所以本篇也尽可能采用推荐的语法形式（基于C++11或以上版本），这也是现代C++标题的含义。 采用现代语法有两点好处。其一，现代语法可以编译出更快更健壮的代码。编译器也是随着语言的发展而发展的，现代语法可以在一定程度上帮助编译器做更好的优化。其二，现代语法通常更简洁，更直观，也更统一，有助于增强可读性和可维护性。 明确了这点后，让我们一起踏入现代C++的大门吧。
类型系统 程序是一种计算工具，根据输入，和预定义的计算方法，产生计算结果。当程序运行起来后，这三者都需要在内存中表示成合适的值才能让程序正常工作，负责解释的这套工具就是类型系统。数字，字符串，键盘鼠标事件等都是数据，而且在内存中实际存在的形式也是一样的，但是按我们人类的眼光来看的话，对它们的处理是不一样的。数字能进行加减乘除等算术运算，但是对字符串进行算术运算就没有意义，而键盘鼠标的值通常只是读取，不进行计算的。正是由于这些差异，编程语言的第一个任务就是需要定义一套类型系统，告诉计算机怎样处理内存中的数据。 为了让编程语言尽可能简单，编程语言一般把类型系统分为两步实现，一部分是编译器，另一部分是类型。编译器那部分负责将开发者的代码解释成合适的形式，以便可以高效，准确在内存中表示。类型部分则定义一些编译器能处理的类型，以便开发者可以找到合适的数据来完成输入输出的表示和计算方法的描述。这两者相辅相成，相互成就。 类型作为类型系统的重要表现形式，在编程语言中的重要性也就不言而喻了。如果把写程序看成是搭积木的话，那么程序的积木就是类型系统。类型系统是开发者能操作的最小单位，它限制了开发者的操作规则，但是提供了无限的可能。C++有着比积木更灵活的类型系统。
类型 :::info 类型是编程语言的最小单位，任何一句代码都是一种内存使用形式。 ::: 而谈到C++的类型也就不得不谈到它的三种类型表现形式——普通类型，指针，引用。它们是三种不同的内存使用和解释形式，也是C++的最基础的形式。和大部分编程语言不同，C++对内置类型没有做特权处理，只要开发者愿意，所有的类型都可以有一致的语法形式（通过运算符重载），所以下面关于类型的举例适合所有的类型。 普通类型就是没有修饰的类型，如int,long,double等。它们是按值传递的，也就是赋值和函数传参是拷贝一份值，对拷贝后的值进行操作，不会再影响到老值。
1 2 3 4 int a=1; //老值,存在地址1 int b=a; //新值，存在地址2 b=2; //改变新值，改变地址2 //此时a还是1，b变成了2 那假如我们需要修改老值呢，有两种途径，一种是指针，另一种则是引用。 指针是C/C++里面的魔法，一切皆可指针。指针包含两个方面，一方面它是指一块内存，另一方面它可以指允许对这块内存进行的操作。指针的值是一块内存地址，操作指针，操作的是它指向的那块地址。
1 2 3 4 int a=1; //老值,存在地址1 int* b=&amp;amp;a; //&amp;amp;代表取地址，从右往左读，取a的地址——地址1，存在地址2 *b=2; //*是解引用，意思是把存在地址2(b)的值取出来，并把那个地址（地址1）的值改成2 //此时a，*b变成了2 引用则是指针的改进版，引用能避免无效引用，不过引用不能重设，比指针缺少一定的灵活性。
1 2 3 4 int a=1; //老值,存在地址1 int&amp;amp; b=a; //&amp;amp;出现在变量声明的位置，代表该变量是引用变量，引用变量必须在声明时初始化 b=2; //可以像普通变量一样操作引用变量，同时，对它的操作也会反应到原始对象上 //此时a，b变成了2 变量定义 类型仅仅是一种语法定义，而要真正使用这种定义，我们需要用类型来定义变量，即变量定义。 C++变量定义是以下形式：
1 type name[{initial_value}] 这里的关键在于type。type是类型和限定符的组合。看下面的例子：
1 2 3 4 5 6 int a; //普通整型 int* b; //类型是int和*的组合，组成了整型指针 const int* c; //从右往左读，*是指针，const int是常量整型，组成了指向常量整型的指针类型 int *const d; //也是从右往左读，const是常量，后面是指针，说明这个指针是常量指针，指向最左边的int，组成常量指针指向整型 int&amp;amp; e=a; //类型是int和&amp;amp;的组合，组成了整型引用 constexpr int f=a+e; //constexpr代表这个变量需要在编译期求值，并且不再可变。 以上，基本就是变量定义的所有形式了，类型确定了变量的基本属性，而限定符限定了变量的使用范围。 定义变量也是按照这个步骤进行，首先确定我们需要什么类型的变量，其次再进一步确定是否需要对这个变量添加限定，很多时候是需要的。可以按以下步骤来确定添加什么样的限定符：</description></item><item><title>现代C++学习指南-方向篇</title><link>https://hongui.github.io/post/%E7%8E%B0%E4%BB%A3C++%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97-%E6%96%B9%E5%90%91%E7%AF%87.html</link><pubDate>Sat, 25 Jun 2022 08:51:01 +0800</pubDate><guid>https://hongui.github.io/post/%E7%8E%B0%E4%BB%A3C++%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97-%E6%96%B9%E5%90%91%E7%AF%87.html</guid><description>C++是一门有着四十年历史的语言，先后经历过四次版本大升级（诞生、98、11、17（20），14算小升级）。每次升级都是很多问题和解决方案的取舍。了解这些历史，能更好地帮助我们理清语言的发展脉络。所以接下来我将借它的发展历程，谈一谈我对它的理解，最后给出我认为比较合理的学习路线指南。
C++0——诞生 C++诞生的目的是为了解决两个主要问题——性能和抽象。性能指的是拥有像C一样的底层访问能力和执行效率，抽象则意在语言层面提供对问题的描述能力和思考方法。这是C++的立命之本，也是C++经久不衰的原因。对于这两个目标，Bjarne Stroustrup想到的解决方法是充分利用现有的C的技术和工具，然后提供类来解决抽象问题。基于这个前提，我们就可以看出类是C++学习路上的第一个关卡。
C++认为类是一种抽象思维，类的相关特性都是为抽象提供服务的。所以C++中的类比其他面向对象的类提供了更多的能力，所以也具有更多的复杂性。为了描述这种复杂性，就不得不提到C++的两个特点，静态类型安全，资源管理。
静态类型安全可以帮助开发者定义出更合理合法的自定义类，如通过操作符重载，自定义类可以写出和基本类型一样的简洁代码。可以通过构造函数避免隐式类型转换而造成的运行时错误，也可以通过明确阻止某些操作阻止自己的类被滥用。所有的自主权都由开发者决定。所以假如我们是库的使用者，完全可以不用关心这些细节，我们只需要按照一般的语言一样写代码，遇到不合理的，编译器会直接告诉我们，不用担心这些问题会隐匿在程序运行时的某个时刻。
资源管理则可以帮助开发者提供资源管理的指导和支撑。资源有很多种，而在计算机中的资源大部分都是有限的，必须有借有还，而且借和还必须一一对应，不然就是内存泄漏。在C时代，资源管理靠的是开发者对资源的全局掌控力，语言层面没有提供更好的支持。为了更好地支持资源管理，C++提出了构造函数和析构函数，两者分别可以对应资源的获取和回收。但是很多时候资源不仅仅供自己使用，还需要提供给外部使用。为了配合这种资源的转移，C++又提供了移动和复制两种操作来支持。
综上，总结一下，C++的类提供了很多特性，但是不是所有的特性都是开发者需要的。开发者在定义类的时候需要考虑的主要问题是，对这个类提供哪些支持，然后再在这些提供的功能中选择合适的语法特性来实现。构造函数和析构函数可以提供很好的一一对应的操作，移动和复制则提供了资源在对象中怎么共享，操作符重载则可以让类使用更加简洁和优雅。
C++98——标准化 C++98最大的升级是模板和异常，并且搭配了好用的标准库。
模板在C++中的地位怎么强调都不为过。它属于另一种抽象机制。所以它解决的也是抽象问题。C++中的类解决的是相似概念的抽象，更注重概念间的相似性。而模板解决的是通用问题的抽象，更注重概念的通用性。两者共同构成了C++的两大抽象基石。前面已经谈过了类，这里我们着重说一下模板。
得益于C++强大的静态类型安全，模板编写起来也很简单，普通的函数怎么写，它就可以怎么写，无非就是把特定类型换成泛型。但是，另一方面，模板还可以做得更多。模板可以支持多种参数，多个参数，限定参数，并且是类型安全的。更厉害的是，它还可以指定值。合理地配合使用类型和值，基本上就能解决大部分问题了。
说起异常。对于普通开发者没有多大吸引力。因为异常主要解决的问题是怎样告诉调用者发生错误了，是什么错误，并将执行能力转移到调用者一方。而我们大部分时间开发的都是业务代码，我们知道发生了什么，该怎样解决，大部分情况下是不太需要异常的。当然，并非说异常一无是处，异常对库开发者来说异常重要。对于库开发者来说，他需要在异常发生后，告诉调用者发生了错误，操作没有办法顺利执行。但是很多时候，库开发者并不知道调用者该怎样处理这个错误，是忽略呢，还是清理现场。异常机制提供了抛异常和异常捕获两种方式来支持库开发者和使用者。
对于新手来说，可能不太喜欢标准库，而倾向于自己写。这不是个好主意。标准库是经过工业级测试的代码，可以在绝大部分情况下正常工作，而自己手写虽然成就感更好，但是更可能携带BUG。早期的标准库提供的功能有限，只有string，输入输出流，位运算，三大容器，和一些小算法。不过，这些都足够我们日常使用了，尤其是现在标准库功能越来越完善了，大部分编程场景都能找到合适的工具来完成，完全可以放弃手写特定代码了。
C++98更多着眼于标准化，模板是一种标准，标准库也是一种标准。自此，C++的三座大山算是构筑完成了，类，模板，标准库。每一项都为C++带来了无限可能和旺盛生命力。
C++11——全新语言 C++11的改动是革命性的，但是还保留着难以置信的兼容性，是非常不容易的。这里我们不细谈具体的特性和细节，只从大方向上来个笼统的概述。
首先直观的变化是在类型系统上，C++11将类型系统做了尽可能的规范化和统一化。
通过同意初始化规范了对象的初始化形式； 通过auto简化了类型声明的形式； 通过nullptr规范化了空指针的形式； 通过enum class提供了静态类型安全的枚举； 通过别名简化了类型书写的方式； 还有其他更多更多 类型系统的改进意味着开发者可以写出更简洁，更规范，也更安全的代码，但是对编译器的挑战却是巨大的，所以，很长时间内，C++11都没有得到很好的支持，同时也妨碍了C++的发展。
除了类型系统，另一项大改进就是提供了对线程的支持。C++11的标准库中提供了线程，条件对象，锁等线程相关的工具，这对库开发者来说是革命性的。在几乎不损失性能的情况下，提供了跨平台的线程支持，这极大地提高了库的稳定性和性能，也节省了很多平台测试时间，不得不说是顶呱呱。
另一个重要升级就是资源管理了。标准库提供了unique_ptr，shared_ptr来协助资源管理。同时为了更出色的性能，引入了右值引用和移动语义。右值引用和移动语义听起来很高端，实际上就是解决一个问题，避免大对象的反复销创建和销毁，转而使用代价更低的移动。根本思路就是两条，对于直接量提供了右值引用，以增加它的生存时间，使之可以像普通变量一样通过参数传递。而对于变量来说，提供了移动语义，将不再需要使用的对象管理的资源转移到另一个对想象中。同时增加了移动构造，复制构造方式来优化函数的返回值。可谓是榨干了计算机的每一寸内存。
C++11无疑是C++里程碑式的更新，在对历史遗留问题清理的同时，引领了接下来C++的发展方向，它的作用是承上启下的。对类型系统的改进无疑弥补了最开始从C继承来的一些缺陷。同时也充分考虑了现代计算机的发展，引入了线程支持。在内存管理上也是更上一层楼，引入了智能指针，移动语义，右值引用。它基本上抛开了历史束缚，但依旧是不忘使命，依旧是奔着更好的静态类型支持，更多的自主性，更高效的资源管理，更克制的特性支持来展开的。
C++17，20——新生 C++17和C++20应该是相辅相成的，绝大部分特性都已经得到支持和完善了。但是由于编译器的限制，我用的特性比较少。C++17比较期待的是跨平台的文件系统支持，这对于大部分应用开发者来说无疑是激动和喜悦的。另一个我喜欢的特性是结构化绑定，这个特性我在Python里面用得很顺手，当然现在基本上所有现代语言都支持它了。
而对于C++20就用得更少了，更多的是示例性质的。我比较在意的是模块和协程，但是由于了解得不深入，就不详谈了。
什么是C++的基本面 从前几个章节不难看出，我着重夸了C++的类，模板，标准库，类型系统。这些都是我觉得学习C++比较重要的方面。但对于初学者来说，我觉得类型系统和标准库就足够了。
类型系统是一门语言最小的单元了，在C++中它包括类型声明，对象初始化，函数传参，函数返回值。在学习初期学多少特性都是骗人的，实际上手还是需要从这个最小的单元入手。比如声明一个变量，这个变量该是什么类型的，可以是指针吗，可以是引用吗。定义函数的时候，参数列表该怎样确定，返回值是什么，怎样才能让函数传参高效，怎样阻止和避免无用的参数检查，返回值该是什么类型，等等，这些都是在实际项目中需要直接面对的问题。所以对类型系统的学习，是写出高效可用代码的第一步，也是最重要的一步。考虑的问题越深入、全面，得到的回报就越大。
标准库则是提供了很好的算法支持和容器支持，可以帮助我们写更健壮的代码。对标准库接口的学习，一方面可以促进对类型系统的认识，另一方面也是积累好习惯的地方。
有了这两项技能的支持，我觉得已经能够写出很棒的应用程序了。但是对于库设计者来说，写出很好的库还需要对类和模板有着更深刻的理解。
一个定义良好的类需要对对象的生命周期进行严格的控制，构造，转移，销毁都是需要控制的。对于需要支持的操作，类设计者应该提供尽可能便捷和高效的支持，对于类禁止的操作，类设计者应该明确禁止，防止发生误用或者隐藏BUG。所以对于类，着重需要关注的是资源的构造，以及在多个对象间的传递和共享。容易发生问题的地方在于函数传参和返回值上，特别是层层调用的函数上，高效和安全就是必须要考虑的了，所以这就回到了前面提到的类型系统，只有对它有了比较深入的了解，才能设计出比较好的类。
模板则是类的另一方面，它和类的概念虽然是不同的，但是思路上却是相通的。模板和Java里面的泛型相似，却更加灵活和重要，是和类一样的高度。模板需要考虑的问题是，提供什么算法，什么对象可以使用这个算法，怎样避免和阻止错误对象的滥用，在使用过程中怎样尽可能利用编译错误来避免运行时错误。所以它是比类更进一步的抽象概念，对开发者有着比类更高的要求。
C++学习路线图 从上一章节，可以看出我推荐的学习路线是类型系统，到标准库，到类，最后才到模板。其他的语言细节不是说不重要，而是在学习这四大板块的同时会融入到学习过程中，没必要单独去学习和理解，毕竟细节是繁杂而且散乱的，不会增加对语言的掌握，却会打乱学习节奏，分散注意力。
类型系统的学习又可以按以下步骤进行
变量声明（常量和编译时常量） 初始化（统一初始化，赋值） 函数定义，函数参数定义，返回值（引用，指针的使用） 简单类定义，不涉及到内存管理，资源管理 标准库可以按以下步骤进行
智能指针（shared_ptr,unique_ptr等） 字符串 容器类对象（list,map等）。 标准输入输出使用 线程库使用 通用算法（sort，find等） 类可以按以下步骤进行
类的构造函数，移动构造，复制构造 类的运算符重载 继承 虚函数 多继承 模板可以按以下步骤进行
模板函数 模板类 模板递归 模板特化 总结 C++细节繁多，初学者容易一头扎进语法细节而不自知，最终白白浪费了大把时间不算，还严重打击了学习积极性。本篇的主旨是在帮初学者理清这门语言的主要脉络，并提供我认为比较科学的学习路线，希望对初学者有所帮助。
C++语言是一门通用型语言，有着很长的发展历史。这导致了它有着不小的历史包袱，所以在引入语言特性和怎样引入的事情上一直保持着克制。但是为了更好地服务于现代硬件和简化开发者工作，又不得不引入新特性，遗弃一些老特性。基于这种原因，语言表现出了一定的复杂性和杂乱性。但是它的核心方向是明确的，就是为了更好地解决效率和抽象问题。抓住这两个核心，再结合这份指南，先难后易，抓大放小，再加上一点归纳和总结就能很好地掌握这门语言的大部分内容。对于指南外的特性，在实际项目中需要了再学习完全是来得及的，毕竟大部分时间我们用到的特性也是很少的一部分，应该把精力花在性价比最高的部分。</description></item><item><title>Android-NDk开发——基本概念</title><link>https://hongui.github.io/post/Android-NDk%E5%BC%80%E5%8F%91%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5.html</link><pubDate>Sun, 06 Mar 2022 11:30:40 +0800</pubDate><guid>https://hongui.github.io/post/Android-NDk%E5%BC%80%E5%8F%91%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5.html</guid><description>在Android开发中,有时候出于安全，性能，代码共用的考虑，需要使用C/C++编写的库。虽然在现代化工具链的支持下，这个工作的难度已经大大降低，但是毕竟万事开头难，初学者往往还是会遇到很多不可预测的问题。本篇就是基于此背景下写的一份简陋指南，希望能对刚开始编写C/C++库的读者有所帮助。同时为了尽可能减少认知断层，本篇将试着从一个最简单的功能开始，逐步添加工具链，直到实现最终功能，真正做到知其然且之所以然。
目标 本篇的目标很简单，就是能在Android应用中调用到C/C++的函数——接收两个整型值，返回两者相加后的值，暂定这个函数为plus。
从C++源文件开始 为了从我们最熟悉的地方开始,我们先不用复杂工具,先从最原始的C++源文件开始.
打开你喜欢的任何一个文本编辑器，VS Code，Notpad++，记事本都行，新建一个文本文件，并另存为math.cpp。接下来,就可以在这个文件中编写代码了.
前面我们的目标已经说得很清楚,实现个plus函数，接收两个整型值，返回两者之和，所以它可能是下面这样
1 2 3 4 int plus(int left,int right) { return left + right; } 我们的源文件就这样完成了，是不是很简单。
但是仅仅有源文件是不够的，因为这个只是给人看的，机器看不懂。所以我们就需要第一个工具——编译器。编译器能帮我们把人看得懂的转化成机器也能看得懂的东西。
编译器 编译器是个复杂工程，但是都是服务于两个基本功能
理解源文件的内容（人能看懂的）——检查出源文件中的语法错误 理解二进制的内容（机器能看懂的）——生成二进制的机器码。 基于这两个朴素的功能，编译器却是挠断了头。难点在于功能2。基于这个难点编译器分成了很多种，常见的像Windows平台的VS，Linux平台的G++,Apple的Clang。而对于Android来说，情况略有不同，前面这些编译器都是运行在特定系统上的，编译出来的程序通常也只能运行在对应的系统上。以我现在的机器为例，我现在是在Deepin上写的C++代码，但是我们的目标是让代码跑在Android手机上，是两个不同的平台。更悲观的是，目前为止，还没有一款可以在手机上运行的编译器。那我们是不是就不能在手机上运行C++代码了？当然不是，因为有交叉编译。
交叉编译就是在一个平台上将代码生成另一个平台可执行对象的技术。它和普通编译最大的不同是在链接上。因为一般的链接直接可以去系统库找到合适的库文件，而交叉编译不行，因为当前的平台不是最终运行代码的平台。所以交叉编译还需要有目标平台的常用库。当然，这些Google都替我们准备好了，称为NDK。
NDK NDK全称是Native Development Kit，里面有很多工具，编译器，链接器，标准库，共享库。这些都是交叉编译必不可少的部分。为了理解方便，我们首先来看看它的文件结构。以我这台机器上的版本为例——/home/Andy/Android/Sdk/ndk/21.4.7075529（Windows上默认位置则是c:\Users\xxx\AppData\Local\Android\Sdk\）。 NDK就保存在Sdk目录下，以ndk命名，并且使用版本号作为该版本的根目录，如示例中，我安装的NDK版本就是21.4.7075529。同时该示例还是ANDROID_NDK这个环境变量的值。也就是说，在确定环境变量前，我们需要先确定选用的NDK版本，并且路径的值取到版本号目录。
了解了它的存储位置，接下来我们需要认识两个重要的目录
build/cmake/，这个文件夹，稍后我们再展开。 toolchains/llvm/prebuild/linux-x86_64，最后的linux-x86_64根据平台不同，名称也不同，如Windows平台上就是以Windows开头，但是一般不会找错，因为这个路径下就一个文件夹，并且前面都是一样的。这里有我们心心念念的编译器，链接器，库，文件头等。如编译器就存在这个路径下的bin目录里，它们都是以clang和clang++结尾的，如aarch64-linux-android21-clang++ aarch64代表着这个编译器能生成用在arm64架构机器上的二进制文件，其他对应的还有armv7a，x86_64等。不同的平台要使用相匹配的编译器。它就是交叉编译中所说的目标平台。
linux代表我们执行编译这个操作发生在linux机器上，它就是交叉编译中所说的主机平台。
android21这个显然就是目标系统版本了
clang++代表它是个C++编译器，对应的C编译器是clang。
可以看到，对于Android来说，不同的主机，不同的指令集，不同的Android版本，都对应着一个编译器。 了解了这么多，终于到激动人性的时刻啦，接下来，我们来编译一下前面的C++文件看看。
编译 通过aarch64-linux-android21-clang++ --help查看参数，会发现它有很多参数和选项，现在我们只想验证下我们的C++源文件有没有语法错误，所以就不管那些复杂的东西，直接一个aarch64-linux-android21-clang++ -c math.cpp执行编译。
命令执行完后，假如一切顺利，就会在math.cpp相同目录下生成math.o对象文件，说明我们的源码没有语法错误，可进行到下一步的链接。
不过，在此之前，先打断一下。通常我们的项目会包含很多源文件，引用一些第三方库，每次都用手工的形式编译，链接显然是低效且容易出错的。在工具已经很成熟的现在，我们应该尽量使用成熟的工具，将重心放在我们的业务逻辑上来，CMake就是这样的一个工具。
CMake CMake是个跨平台的项目构建工具。怎么理解呢？编写C++代码时，有时候需要引用其他目录的文件头，但是在编译阶段，编译器是不知道该去哪里查找文件头的，所以需要一种配置告诉编译器文件头的查找位置。再者，分布在不同目录的源码，需要根据一定的需求打包成不同的库。又或者，项目中引用了第三方库，需要在链接阶段告诉链接器从哪个位置查找库，种种这些都是需要配置的东西。
而不同的系统，不同的IDE对于上述配置的支持是不尽相同的，如Windows上的Visual Studio就是需要在项目的属性里面配置。在开发者使用同样的工具时，问题还不是很大。但是一旦涉及到多平台，多IDE的情况，协同开发就会花费大把的时间在配置上。CMake就是为了解决这些问题应运而生的。
CMake的配置信息都是写在名为CMakeLists.txt的文件中。如前面提到头文件引用，源码依赖，库依赖等等，只需要在CmakeLists.txt中写一次，就可以在Windows，MacOS，Linux平台上的主流IDE上无缝使用。如我在Windows的Visual Studio上创建了一个CMake的项目，配置好了依赖信息,传给同事。同事用MacOS开发，他可以在一点不修改的情况下，马上完成编译，打包，测试等工作。这就是CMake跨平台的威力——简洁，高效，灵活。
使用CMake管理项目 建CMake项目 我们前面已经有了math.cpp，又有了CMake，现在就把他们结合一下。
怎样建立一个CMake项目呢？一共分三步：
建一个文件夹 示例中我们就建一个math的文件夹吧。
在新建的文件夹里新建CMakeLists.txt文本文件。注意，这里的文件名不能变。
在新建的CMakeLists.txt文件里配置项目信息。 最简单的CMake项目信息需要包括至少三个东西 1）、支持的最低CMake版本
1 cmake_minimum_required(VERSION 3.18。1) 2）、项目名称</description></item><item><title>Linux批量文件操作——基于find,xargs</title><link>https://hongui.github.io/post/Linux%E6%89%B9%E9%87%8F%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E2%80%94%E2%80%94%E5%9F%BA%E4%BA%8Efind,xargs.html</link><pubDate>Fri, 18 Feb 2022 21:19:39 +0800</pubDate><guid>https://hongui.github.io/post/Linux%E6%89%B9%E9%87%8F%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E2%80%94%E2%80%94%E5%9F%BA%E4%BA%8Efind,xargs.html</guid><description>前言 在项目初创阶段，经常会遇到各种文件操作，拷贝头文件，库，批量重命名等。文件结构一复杂，这就将是个无聊的工作。
查找文件 find可以在目录结构中搜索文件，这是它在man里面的作用描述。那么怎么搜索呢？有多种方式，按文件时间，大小，按文件名，路径名，按文件类型，权限，按用户。而这些方式又可以通过与或非的逻辑相互组合，完成更苛刻的查找工作，简直是文件查找的福音。 通常介绍一种命令都会以命令形式开始，find的格式如下
1 find [-H] [-L] [-P] [-D debugopts] [-Olevel] [starting-point...] [expression] [-H] [-L] [-P] [-D debugopts] [-Olevel]这一些统统不重要， [-H] [-L] [-P]是针对软连接的，不常用。[-D debugopts]是显示运行期间的额外信息，信息太乱太杂，用处不大。[-Olevel]则是用于优化查找的，默认的已经够用，所以也没必要深究。 find的最大魔法在最后的[expression],下面将以实例的形式讲解这个[expression]到底该怎么玩，原始的文件结构如下
1 2 3 4 5 6 7 8 9 10 11 12 ├── alice.h ├── andy │ ├── jack │ │ └── mary.h │ ├── mark.cpp │ ├── mark.h │ └── pony.txt ├── andy.c ├── bill.cpp ├── bill.h ├── mark.h └── mary 现在，我想找到以andy命名的文件，命令该怎么写呢。直觉告诉我们应该是
1 find andy 但是直觉对吗，我们来看输出</description></item><item><title>用纯HTML，JS，CSS实现横向滚动标签页</title><link>https://hongui.github.io/post/%E7%94%A8%E7%BA%AFHTML%EF%BC%8CJS%EF%BC%8CCSS%E5%AE%9E%E7%8E%B0%E6%A8%AA%E5%90%91%E6%BB%9A%E5%8A%A8%E6%A0%87%E7%AD%BE%E9%A1%B5.html</link><pubDate>Sat, 12 Feb 2022 09:23:30 +0800</pubDate><guid>https://hongui.github.io/post/%E7%94%A8%E7%BA%AFHTML%EF%BC%8CJS%EF%BC%8CCSS%E5%AE%9E%E7%8E%B0%E6%A8%AA%E5%90%91%E6%BB%9A%E5%8A%A8%E6%A0%87%E7%AD%BE%E9%A1%B5.html</guid><description>前言 前不久，在我的一个项目中，需要展示一个横向滚动的标签页，它支持鼠标横向拖动和点击切换。在实现的过程中，我发现这个小功能需要同时用到前端的三辆马车，但是实现难度不高，而且最终效果还不错，是个难得的初学者项目，于是萌生了写这篇文章的想法，希望对初学者有所帮助。同时为了避免初学者学习框架，我打算用纯原生的方式实现它。
我们最终的效果应该类似于下面： 需求分析 需求分析就是细化我们需要完成的功能，某个功能的完成需要哪些技术的参与。对于初学者，需求分析至关重要，它可以帮助我们理清思路，找到解决问题的突破口，所以应该引起足够的重视。以本篇目标为例，标签页的需求分析就可以像下面这样：
我们的展示主体是标签页，HTML就是实现主体的主要技术； 标签页需要可以拖动和点击，这涉及到鼠标事件的监听和处理，是JS的主场； 既然标签页可以拖动了，那是否要隐藏那个丑陋的滚动条，加个活动指示器，给鼠标变一个样式？很明显，这些都是CSS的优势。 如上，通过对展示，操作，样式的划分，我们进一步明确了HTML，JS，CSS需要完成的工作，甚至连实现都明朗了，所以对需求拆分得越详细，对实现就越有掌控力。
基本框架 对于前端来说，HTML始终是万物之源，所以一言不合先构筑个标准的HTML页面总是没错的。为了便于演示，我将所有的内容都放在一个HTML文件中，文件结构如下
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&amp;#34;utf-8&amp;#34;&amp;gt; &amp;lt;meta name=&amp;#34;viewport&amp;#34; content=&amp;#34;width=device-width, initial-scale=1&amp;#34;&amp;gt; &amp;lt;title&amp;gt;Tab演示&amp;lt;/title&amp;gt; &amp;lt;!-- 这里是样式区，后续css代码会添加到这里 --&amp;gt; &amp;lt;style type=&amp;#34;text/css&amp;#34;&amp;gt; &amp;lt;/style&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;!-- 这里是页面区，后续HTML代码会添加到这里 --&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;!-- 这里是脚本区，后续JS代码会添加到这里,放在这里是因为方便写代码 --&amp;gt; &amp;lt;script type=&amp;#34;text/javascript&amp;#34;&amp;gt; &amp;lt;/script&amp;gt; &amp;lt;/html&amp;gt; 这里和以往不同，我将script放到了最后，这是因为我想在写脚本的时候，页面标签直接可用，减少对页面加载的监听，降低复杂性。
实现基本功能 有了基本结构，下一步当然是画页面啦。从效果图中不难看出，页面主要包括一个一个的选项卡，对于HTML来说，这不就是列表嘛。于是，突破口就出现了，我们先往HTML里面加入列表
1 2 3 4 5 6 7 8 9 10 11 12 &amp;lt;ul&amp;gt; &amp;lt;li&amp;gt;肖申克的救赎&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;霸王别姬&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;阿甘正传&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;泰坦尼克号&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;这个杀手不太冷&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;美丽人生&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;千与千寻&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;辛德勒的名单&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;盗梦空间&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;忠犬八公的故事&amp;lt;/li&amp;gt; &amp;lt;/ul&amp;gt; 于是，我们有了原始的标签页。但是标签页是竖向的，并且有着丑陋的小黑点，不符合需求。 发现了这些问题，下一步当然解决这些问题了，这当然就是CSS的强项啦。首要问题就是让列表横过来。横过来就是改变了元素的相对位置，也就是对应CSS的布局功能。那说起布局，CSS的布局方式有很多，像float,position等等。标签页是横向多个紧密排列的，一个挨着一个，这当然是用flex啦。至于讨厌的小黑点，这是新东西，需要百度一下。查阅文档发现，ul有个属性list-style-type，只需把它设置为none就可以去除小黑点。 此时，页面上的所有选项卡都紧密排列了。为了让它更像一个选项卡，需要给它居中，限制一下宽度，加个背景色，加点padding。下面就是改完样式的代码</description></item><item><title>Android-JNI开发概论</title><link>https://hongui.github.io/post/Android-JNI%E5%BC%80%E5%8F%91%E6%A6%82%E8%AE%BA.html</link><pubDate>Sun, 12 Sep 2021 21:34:45 +0800</pubDate><guid>https://hongui.github.io/post/Android-JNI%E5%BC%80%E5%8F%91%E6%A6%82%E8%AE%BA.html</guid><description>什么是JNI开发 JNI的全称是Java Native Interface，顾名思义，这是一种解决Java和C/C++相互调用的编程方式。它其实只解决两个方面的问题，怎么找到和怎么访问。 弄清楚这两个话题，我们就学会了JNI开发。需要注意的是，JNI开发只涉及到一小部分C/C++开发知识，遇到问题的时候我们首先要判断是C/C++的问题还是JNI的问题，这可以节省很多搜索和定位的时间。
用JVM的眼光看函数调用 我们知道Java程序是不能单独运行的，它需要运行在JVM上的，而JVM却又需要跑在物理机上，所以它的任务很重，既要处理Java代码，又要处理各种操作系统，硬件等问题。可以说了解了JVM，就了解了Java的全部，当然包括JNI。所以我们先以JVM的身份来看看Java代码是怎样跑起来的吧（只是粗略的内容，省去了很多步骤，为了突出我们在意的部分）。
运行Java代码前，会先启动一个JVM。在JVM启动后，会加载一些必要的类，这些类中包含一个叫主类的类，也就是含有一个静态成员函数，函数签名为public static void main(String[] args)的方法。资源加载完成后，JVM就会调用主类的main方法，开始执行Java代码。随着代码的执行，一个类依赖另一个类，层层依赖，共同完成了程序功能。这就是JVM的大概工作流程，可以说JVM就好比一座大桥，连接着Java大山和native大山。
现在问题来了，在Java程序中，某个类需要通过JNI技术访问JVM以外的东西，那么它需要怎样告诉我（我现在是JVM）呢？需要一种方法　把普通的Java方法标记成特殊，这个标记就是native关键字（使用Kotlin时虽然也可以使用这个关键字，但是Kotlin有自己的关键字external）。当我执行到这个方法时，看到它不一样的标记，我就会从其他地方而不是Class里面寻找执行体，这就是一次JNI调用。也就是说对于Java程序来说，只需要将一个方法标记为native，在需要的地方调用这个方法，就可以完成JNI调用了。但是对于我，该怎样处理这一次JNI调用呢？其实上面的寻找执行体的过程是一个跳转问题，在C/C++的世界，跳转问题就是指针问题。那么这个指针它应该指向哪里呢？
C/C++代码是一个个函数（下文会将Java方法直接用方法简称，而C/C++函数直接用函数简称）组合起来的，每一个函数都是一个指针，这个特性恰好满足我的需要。但是对于我，外面世界那么大，我并不知道从哪里，找什么东西，给我的信息还是不够。为了限定范围，我规定，只有通过System.loadLibrary(“xxx”)加载的函数，我才会查找，其余的我直接罢工（抛错）。这一下子减轻了我的工作量，至少我知道从哪里找了。
确定了范围，下一步就是在这个范围里确定真正的目标了。Java世界里怎样唯一标识一个类呢，有的人会脱口而出——类名，其实不全对，因为类名可能会重名，我们需要全限定的类名，也就是包名加类名，如String的全限定类名就是java.lang.String。但是这和我们查找native的方法有什么联系呢。当然有联系，既然一个全限定的类名是唯一的，那么它的方法也是唯一的，那么假如我规定以这个类的全限定类名加上方法名作为native函数的函数名，这样我是不是就可以通过函数名的方式找到native的函数看呢，答案是肯定的，但是有瑕疵，因为Java系统支持方法重载，也就是一个类里面，同名的方法可能有多个。那么构成重载的条件是什么呢，是参数列表不同。所以，结果就很显然了，我在前面的基础上再加上参数列表，组合成查找条件，我是不是就可以唯一确定某一个native函数了呢，这就是JNI的静态注册。
不过，既然我只需要确定指针的指向，那么我能不能直接给指针赋值，而不是每次都去查找呢，虽然我不知道累，但是还是很耗费时间的。对于这种需求，我当然也是满足的啦，你直接告诉我，我就不找了，我还乐意呢。而且，既然你都给我找到了，我就不需要下那么多规定了，都放开，你说是我就相信你它是。这就是JNI的动态注册。
JNI的函数注册 上一节我们通过化身JVM的方式了解了JNI函数注册的渊源，并且引出了两种函数注册方式。从例子上，我们也可以总结出两种注册方式的特点
注册类型 优点 缺点 静态注册 JVM自动查找 实现简单 函数名贼长，限制较多 查找耗时 动态注册 运行快 对函数名无限制 实现复杂 那么具体怎么做呢？我们接着往下说。
静态注册 虽然静态注册限制比较多，但是都是一些浅显的规则，更容易实施，所以先从静态注册开始讲解。
静态注册有着明确的开发步骤
编写Java类，声明native方法; 使用java xxx.java将Java源文件编译为class文件 使用javah xxx生成对应的.h文件 构建工具中引入.h文件 实现.h文件中的函数 上面的这个步骤是静态开发的基本步骤，但是其实在如今强大的IDE面前，这些都不需要我们手动完成了，在Android Studio中，定义好native方法后，在方法上按alt + enter就可以生成正确的函数签名，直接写函数逻辑就可以了。但是学习一门学问，我们还是要抱着求真，求实的态度，所以我用一个例子来阐述一下这些规则，以加深读者的理解。
Test.java
1 2 3 4 5 package me.hongui.demo public class Test{ native String jniString(); } native-lib.cpp
1 2 3 4 5 #include &amp;lt;jni.h&amp;gt; extern &amp;#34;C&amp;#34; jstring Java_me_hongui_demo_Test_jniString(JNIEnv *env, jobject thiz) { // TODO: implement jniString() } 上面就是一个JNI函数在两端声明的例子，不难发现</description></item><item><title>CMake个人理解和使用</title><link>https://hongui.github.io/post/CMake%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3%E5%92%8C%E4%BD%BF%E7%94%A8.html</link><pubDate>Mon, 09 Aug 2021 19:21:49 +0800</pubDate><guid>https://hongui.github.io/post/CMake%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3%E5%92%8C%E4%BD%BF%E7%94%A8.html</guid><description>前言 CMake是一个构建工具，通过它可以很容易创建跨平台的项目。通常使用它构建项目要分两步，通过源代码生成工程文件，通过工程文件构建目标产物（可能是动态库，静态库，也可能是可执行程序）。使用CMake的一个主要优势是在多平台或者多人协作的项目中，开发人员可以根据自己的喜好来使选择IDE，不用受其他人工程配置的影响，它有点像跨平台的IDE，通过它配置好相关设置之后，可以在多个平台无缝衔接，提高开发效率。
最简单的CMake工程 项目搭建 一个用CMake来管理的项目，其项目根目录通常会包含一个CMakeLists.txt的文件，当然子目录可能也有，这种情况我们稍后再说。我们先从最简单的项目开始。以下就是一个最简单的工程示例：
CMakeProject | CMakeLists.txt | main.cpp 这就是完整的可以跑起来的最小项目了。按照顺序，我们来看看文件里的内容
CMakeLists.txt
# 设置版本号 cmake_minimum_required(VERSION 3.10) # 设置项目名 project(CMakeProject) # 设置产物和源码的关联 add_executable(${CMAKE_PROJECT_NAME} main.cpp) 说明：
CMake中命令不区分大小写 以#开始的是备注 引用变量语法${变量名} 所以文档中真正的有效内容就三行，
cmake_minimum_required(VERSION 3.10)设置了CMake支持的最低版本，VERSION是参数名，后面是版本号，可以根据自己的需要修改。 注意参数名和参数是以空白符分隔的，不是逗号， 不然会报错。 project(CMakeProject)CMake中字符串可以带引号或者不带，效果是一致的，这一行就是配置了项目名，如生成的Visual Studio的工程名就是依据这个名字来的。 add_executable(${CMAKE_PROJECT_NAME} main.cpp) 才是真正管理源码和目标产物的地方，这里我们使用了引用变量的写法，而文件中没有定义这个变量，说明这个变量存在于CMake中，在CMake还有很多预定义的变量，我们可以直接通过这种方式引用，上面的写法是将项目名设置为产物的名字，当然也可以直接填字符串，取个另外的名字都是可以的。后面的main.cpp则是用来生成产物的源码路径，这就是CMake最灵活的地方。源码路径可以是多样的，查找出来的，直接写的，相对路径，绝对路径都可以。 多个源码的话就用空白符分隔，依次写就行了。 在上面的配置文件中，我们配置了它的源文件为main.cpp，我们想通过它来生成一个可执行的程序，内容也很简单: #include &amp;lt;iostream&amp;gt; int main() { std::cout&amp;lt;&amp;lt;&amp;#34;hello CMake&amp;#34;&amp;lt;&amp;lt;std::endl; return 0; } 项目编译与执行 准备工作已经做完，接下来我们就要使用CMake生成可执行文件了。
第一步当然是要安装CMake啦，这是下载地址 !Download ，根据自己的平台选择下载即可，安装完成之后需要把它添加到环境变量中，便于我们在任何地方都能方便使用。 安装了CMake以后，打开命令行工具，进入到刚才创建的项目根目录，也就是进入到存着CMakeLists.txt和main.cpp的目录，下一步准备生成项目。
通常为了不影响和污染当前的工作环境，我们会选择新建一个目录来存放生成的工程文件，以下我主要以Windows平台为主要平台讲解，其他平台基本一致。
mkdir build #创建文件夹，存储工程文件； cd build #切换cmake工作目录; cmake .. #生成项目文件； 这三步执行完后，我们就可以在build文件夹下看到里面已经生成了一个Visual Studio的工程，我们可以直接用Visual Studio打开这个工程，按照我们的习惯执行编译和调试。当然，假如想最快地生成可执行文件，我还是推荐使用CMake。
使用CMake执行编译，只需要在上一步的基础上（也就是已经成功执行了上面的三个步骤）再执行一个命令cmake --build .</description></item><item><title> Kotlin协程-从一到多</title><link>https://hongui.github.io/post/%20Kotlin%E5%8D%8F%E7%A8%8B-%E4%BB%8E%E4%B8%80%E5%88%B0%E5%A4%9A.html</link><pubDate>Tue, 30 Mar 2021 19:10:30 +0800</pubDate><guid>https://hongui.github.io/post/%20Kotlin%E5%8D%8F%E7%A8%8B-%E4%BB%8E%E4%B8%80%E5%88%B0%E5%A4%9A.html</guid><description>上一篇文章，我介绍了Kotlin协程的创建，使用，协作等内容。本篇将引入更多的使用场景，继续带你走进协程世界。
使用协程处理异步数据流 常用编程语言都会内置对同一类型不同对象的数据集表示，我们通常称之为容器类。不同的容器类适用于不同的使用场景。Kotlin的Flow就是在异步计算的需求下引入的，用于表示异步的数据流。
Flow “问渠哪得清如许，为有源头活水来”，异步数据流的基本就是以某种方式获得异步数据。Kotlin提供了多种种方式，比较常用的就是Kotlin协程包的asFlow扩展和flow构造器。前者是对普通数据集的Flow化封装，没有更多可言，我们着重来看后者。 flow构造器的主要目标就是产生一个异步数据流，它是一个泛型函数，参数是一个挂起函数，并且是FlowCollector是扩展函数。这个接口只有一个emit方法，就是为创建的Flow提供异步计算的数据的，因为它是挂起函数，所以我们能在里面使用其他挂起函数计算异步值，然后通过emit方法将值发送出去，如此反复就能为下游操作提供源源不断的数据流了。 事情还没完，上面的步骤我们只是规定了创建数据的方式，并没有真正执行，也就是建好了道路，但是还没有车上路。那么，怎样才能让车在路上跑呢，查看Flow的接口会发现，它提供了collect方法来处理数据。collect接收一个挂起函数作为处理逻辑，但是同时，collect方法本身也是挂起函数，所以，这个方法只能在挂起函数中运行。有了这些知识，我们就可以写出最简单的异步数据流了。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 1uspend fun compute():Int{ delay(123) return 1024 } viewModelScope.launch { val flow=flow&amp;lt;Int&amp;gt; { emit(9527) emit(compute()) delay(256) emit(256) } flow.collect { println(it) } } 在flow构造器里面随意做各种操作，只要在必要的时候传递结果就行了，但是需要注意的是，emit方法只能运行在同一个协程里。乍一看，这样分开写和写在一起并没有本质上的差别，但Flow还能做到更多。
该给Flow换个工作环境了 上一节，我们那个简单的示例，假如把构造器里面的数据获取方法换成网络请求，应用就歇菜了。因为它们都是运行在主线程里面的。那么这个时候，看过上一篇文章的小伙伴马上就会反应过来，用withContext方法在构造器里面切换线程就行了哇。思路是很对，因为Flow的默认配置就是构造器和collect方法工作在同一线程，既然现在主线程不让运行，那就把构造器的线程切换一下就行了呗。然后事实并不是这样，这样写出来的代码根本无法运行。因为官方提供了唯一的flowOn方法来切换构造器的执行线程。使用也很简单，就是对创建好的Flow对象配置一次flowOn方法就行了。
1 2 3 4 5 6 7 val flow=[&amp;#34;1.jpg&amp;#34;,&amp;#34;2.jpg&amp;#34;].asFlow() flow.map { decode(it) } .flowOn(Dispatchers.IO) viewModelScope.launch { flow.collect{ adapter.add(it) } 有些中间处理逻辑 熟悉RxJava的小伙伴可能有疑问了，这些操作RxJava也能完成，甚至还有更多的操作符来支持中间状态的处理，那么异步数据流能做到这些吗。毫无疑问，它可以。普通的数据集有map,filter等操作方法，对于异步数据流来说，这些方法同样适用。而且这些方法参数都是挂起函数，都可以执行异步操作。而且它还有个更灵活的transform方法，这个方法可以定制自己的操作符，实现更灵活的数据操作。</description></item><item><title>用纯HTML，JS，CSS实现横向滚动标签页</title><link>https://hongui.github.io/post/Kotlin%E5%8D%8F%E7%A8%8B-%E4%BB%8E%E7%90%86%E8%AE%BA%E5%88%B0%E5%AE%9E%E6%88%98.html</link><pubDate>Sat, 27 Mar 2021 19:02:30 +0800</pubDate><guid>https://hongui.github.io/post/Kotlin%E5%8D%8F%E7%A8%8B-%E4%BB%8E%E7%90%86%E8%AE%BA%E5%88%B0%E5%AE%9E%E6%88%98.html</guid><description>上一篇文章从理论上对Kotlin协程进行了部分说明，本文将在上一篇的基础上，从实战出发，继续协程之旅。
从源头说起 在Kotlin中，要想使用协程，首先需要使用协程创建器创建，但还有个前提——协程作用域(CoroutineScope)。在早期的Kotlin实现中，协程创建器是一等函数，也就是说我们随时随地可以通过协程创建器创建协程。但在协程正式发布以后，协程创建器需要在协程作用域对象上才能创建了，Kotlin添加了协程作用域来实现结构化并发。什么是结构化并发呢，通俗地说就是正确实施多个协程监控、管理的能力。在实际业务中，我们可能需要创建多个协程对象来完成不同的工作。为了对这些不相关的协程管理起来，Kotlin引入了协程作用域，通过某个协程作用域创建的协程都会被它管理着，在条件满足的时候，执行每个协程的取消工作或者结束自己。
为了方便我们直接上手，官方提供了MainScope和GlobalScope供我们使用。正如名字那样，他们分别有不同的应用场景，前者比较适合用在UI相关的类中，而后者适用于在整个应用生命周期中都需要存活的类中。当然，对于Android开发者，其实我们有更好的选择——使用ViewModel的Kotlin扩展，它不仅有着全部的协程作用域功能，开箱即用，而且还在onCleared方法中实现了自动取消。
创建协程 有了协程作用域，那我们来创建一个最简单的协程吧。
1 2 3 4 5 viewModelScope.launch{ //这里就是协程代码啦啦啦啦 delay(2000) System.out.println(&amp;#34;Hello World&amp;#34;) } launch创建并启动了一个协程，协程启动两秒后，在控制抬打印了Hello World，然后协程就结束了（协程是有完整生命周期的）。这个协程完成的工作有限，我们可以使用线程完成相同的功能:
1 2 3 4 thread { Thread.sleep(2000) System.out.println(&amp;#34;Hello World&amp;#34;) } 我们可以看到，除去构建函数，两段代码唯一的区别就是延迟函数——delay和Thread.sleep.从功能上看他们都是让后面的代码延迟执行，但是效果却是不一样的，前者不会阻塞线程。这段代码其实是放在主线程里面执行的，但是它不会影响到UI的绘制，而后者假如把它放在主线程执行的话，应用会出现两秒的无响应。Kotlin把这种不会阻塞当前线程执行的函数称之为挂起函数，挂起函数可以在挂起点断开与当前线程的联系，让线程空闲下来完成其他的操作，当条件满足后，挂起函数重新在挂起点恢复，接着往下执行后面的代码。
还有个小问题没有解决，在上一篇文章中，我曾经说过，挂起函数只能在挂起函数中执行，既然delay是挂起函数，那么反推，我们的代码块也应该是个挂起函数，而这个挂起函数就是所谓的协程体。
让协程跨线程工作 如果你看到上面的代码，然后转手在协程体里面写个网络请求的话，你会发现，你的应用崩溃了，这是怎么回事呢？因为协程虽然不会阻塞主线程，但是主线程是不允许进行网络请求的。如果这时你就急着下了协程没啥用的结论，那么你就肤浅了。让我们稍微改一改上面的代码，让它运行在子线程吧。
1 2 3 4 5 viewModelScope.launch (Dispatchers.IO){ //这里就是协程代码啦啦啦啦 delay(2000) System.out.println(&amp;#34;Hello World&amp;#34;) } 很好，现在协程体里面的网络请求可以顺利执行了，但是很快有读者就会发现新问题了——我怎么把网络请求的结果传回主线程呢，难不成还搞个Handler,那和直接使用线程有什么区别，辣鸡协程。嘿，别急，这个协程其实也为客官处理好了。让我们再次改造一下代码：
1 2 3 4 5 6 7 8 9 viewModelScope.launch (Dispatchers.IO){ //这里就是协程代码啦啦啦啦，这里是在子线程执行的代码哦 //假装这个是网络请求吧 delay(2000) withContext(Dispatchers.Main) { //哦豁豁，这里竟然运行在主线程哦 System.out.println(&amp;#34;Hello World&amp;#34;) } } 很好，我们可以愉快地使用协程处理网络请求了，那么这些魔法是怎么发生的呢，停下脚步，我们来重新审视一下上面的代码。
首先，相比于最开始的代码，我们的代码里多了两个对象，一个方法调用。首先我们来看那两个对象，从名字中我们不难猜到它就是调度线程的。 Kotlin提供了四个常用的实现</description></item><item><title>Kotlin协程-那些理不清乱不明的关系</title><link>https://hongui.github.io/post/Kotlin%E5%8D%8F%E7%A8%8B-%E9%82%A3%E4%BA%9B%E7%90%86%E4%B8%8D%E6%B8%85%E4%B9%B1%E4%B8%8D%E6%98%8E%E7%9A%84%E5%85%B3%E7%B3%BB.html</link><pubDate>Fri, 26 Mar 2021 18:50:29 +0800</pubDate><guid>https://hongui.github.io/post/Kotlin%E5%8D%8F%E7%A8%8B-%E9%82%A3%E4%BA%9B%E7%90%86%E4%B8%8D%E6%B8%85%E4%B9%B1%E4%B8%8D%E6%98%8E%E7%9A%84%E5%85%B3%E7%B3%BB.html</guid><description>Kotlin的协程自推出以来，受到了越来越多Android开发者的追捧。另一方面由于它庞大的API，也将相当一部分开发者拒之门外。本篇试图从协程的几个重要概念入手，在复杂API中还原出它本来的面目，以全新的角度带读者走进Kotlin协程世界。
什么是协程 在很多有关协程的文章中，描述协程通常会用这样的一句描述——协程比线程更加轻量，是可取消的。这句话没有错，这两个都是协程的优点，但是并不是特点，它并没有解释协程是什么。那么什么是协程的特点呢，我觉得可以先用线程做个类比，解释一个概念最好的办法就是类比。 我不打算使用科学严谨的描述，我想给线程一个我自己的定义——线程是一个可供CPU调度的执行单元，它有自己的执行块，可以独立地执行逻辑。我特意将线程的三个关键特征列举出来了：
线程由CPU调度 线程拥有自己的代码块 代码块需要才能调度执行 这是我对线程的直观感受，并且这些特点是能从代码上体现出来的。如Java中的Thread，它是线程的同时，也是一个实体对象，能通过API来认识它，使用它。而它的特别之处就是我上面列举的三点，这些都是线程特有的。我试着用相同的思路来给协程下一个自己的定义——协程是由线程调度执行的执行单元，它也有自己的执行块，可以独立或者协同执行逻辑。其实Kotlin中的协程也有自己对应实体和操作API，甚至和线程的还很像(如生命周期），但是由于Kotlin对协程的封装过于彻底，很多API没有暴露出来，以至于我对协程的认识一直处于盲人摸象的状态。另外，其实协程是有多种实现方式的，以下我的观点仅针对Kotlin的协程实现，可能与其他语言的实现不一致。
Kotlin中的协程对象本质上来讲就是个可执行的代码块， 执行的代码就是创建协程传递进去的。除此之外它还有个最大的特点——协程是不和线程绑定的。它可以在某个时刻断开当前的线程，然后在其他时候，附着到其他线程上。也就是说，它像一个乒乓球，线程就好比是球拍，它可以在球拍间反复横跳。所以，结合这两个特点，官方给协程的定义是 一个可挂起的计算实体。我觉得这个定义不算精确，它只体现了挂起这个概念，没有体现恢复的概念。我给它一个我自己的定义——一个可被调度的计算实体。
协程中几个关键概念 明白了协程是什么还不够，因为Kotlin的协程还涉及到很多方面，有几个关键概念需要理解。
挂起函数 提到Kotlin的协程就不得不提到挂起函数，这是Kotlin协程实现的最重要的概念之一。简单来说，挂起函数是一种异步实现方案，它是一个普通函数的前提下，还具备挂起和恢复的特性。 它是解决耗时计算和结果传递的一种方案。那么它和我们常见的基于回调的方案相比，有什么不同呢。在基于回调的方案中，计算过程和结果没有关系，结果需要通过另一个对象，在计算完成后由计算过程手动传递，而这一过程是可能被反复嵌套的，从而导致，一些本该是串行化的代码，被割裂成几个部分，分散到不同的代码块中。如以下读写文件的代码
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // asynchronously read into `buf`, and when done run the lambda inChannel.read(buf) { // this lambda is executed when the reading completes bytesRead -&amp;gt; ... ... process(buf, bytesRead) // asynchronously write from `buf`, and when done run the lambda outChannel.</description></item><item><title>沉思篇-剖析Jetpack的ViewModel</title><link>https://hongui.github.io/post/%E6%B2%89%E6%80%9D%E7%AF%87-%E5%89%96%E6%9E%90Jetpack%E7%9A%84LiveData.html</link><pubDate>Wed, 24 Mar 2021 18:18:30 +0800</pubDate><guid>https://hongui.github.io/post/%E6%B2%89%E6%80%9D%E7%AF%87-%E5%89%96%E6%9E%90Jetpack%E7%9A%84LiveData.html</guid><description> ViewModel做为架构组件的三元老之一，是实现MVVM的有力武器。
ViewModel的设计目标 ViewModel的基本功能就是管理UI的数据。其实，从职责上来说，这又是对Activity和Fragment的一次功能拆分。以前存储在它们内部的数据，需要它们自己处理创建，更新，存储，恢复的所有过程，同时它们还要处理UI的数据绑定，更新，动画等操作。职责的多元化就容易出现不好定位和调试的问题。另外，Activity和Fragment作为UI的承载者，很多时候需要共享数据和复用功能。而UI的差异让复用的粒度划分很难把控，容易写出扩展性差的代码。基于这些痛点，ViewModel被设计出来了。 同时ViewModel还将保存数据的功能强化了——它将设备配置变更后数据保存和恢复自动化了，在UI生命周期内都能保证数据的有效性，这大大减少了样板代码的编写，提高了开发效率。
ViewModel的架构设计 *** ViewModel用了两种粒度划分来完成数据管理功能。*** 第一层是对ViewModel自身存储数据的管理。目标就是完成ViewModel的创建，对应的抽象实体是ViewModelProvider.Factory。第二层则是对已存在的ViewModel组的管理，目标就是保证意外情况下ViewModel的有效性，对应的抽象实体是ViewModelStore。当然，这些都只是概念上的抽象，还需要一个粘合剂把它们的抽象层级体现出来，这就是ViewModelProvider。这三个主体类共同搭建了ViewModel的体系框架。剩下的类都是对这三个概念的补充和完善。接下来我将分别以这些抽象为主线，逐层分析它们的实现逻辑。
ViewModel的组管理 前面也提到过，ViewModelStore是完成组管理的，那么我们首先应该确定的是组的概念,也就是这些ViewModel都归属于谁的问题。这不难理解，要管理组，那就必须得找到组的主人啊，由此引申出了ViewModelStoreOwner，它代表着某个拥有组管理权限的对象，通过它提供的ViewModelStore对象就能对里面的ViewModel进行管理了，同时这些ViewModel也就共同形成了组。所以ViewModelStoreOwner其实就是组的抽象实体，它代表着某个组，也是管理分组的单位。 ViewModel有两个默认实现的组——ComponentActivity和Fragment。也就是说ComponentActivity和Fragment都实现了ViewModelStoreOwner这个接口。 先来看ComponentActivity的实现。根据接口，首先查看接口方法getViewModelStore的实现。里面主要涉及到两个对象，一个就是ViewModelStore的引用mViewModelStore，另一个就很有意思了，它是一个NonConfigurationInstances对象，这是一个简单类，就是保存ViewModelStore对象的。那么它特殊在什么地方呢？它是onRetainNonConfigurationInstance方法的返回对象。
插一个课外知识科普，onRetainNonConfigurationInstance是Activity的一个方法，这个方法是设备配置发生变化（如横竖屏切换的时候）时被系统自动调用的，用于用户保存数据。只要这个方法返回的对象，在设备配置放生改变时都不会被销毁。稍后在重建完成后，可以通过getLastNonConfigurationInstance方法获取到。
接着回到getViewModelStore的实现，刚才说到NonConfigurationInstances对象，它是通过调用getLastNonConfigurationInstance方法获得的。如果方法返回了有效的对象，说明Activity被重建了，就直接获取保存在NonConfigurationInstances对象中的值，然后更新mViewModelStore。否则就说明还没有有效的ViewModelStore对象，则直接创建。从这个逻辑不难看出，我们的ViewModel不会随着设备变化而重建，这正好满足了我们的设计目标。那么对于Fragment，它的实现又是怎样的呢。 Fragment的实现比较曲折，它直接委托给了FragmentManager,又委托给了FragmentManagerViewModel的getViewModelStore方法，方法实现也很简单，就是对HashMap查找，没有就创建新的。这显然不是我们想看到的，因为这里并没有和Activity类似的处理状态变更的逻辑。那么唯一的突破点就是那个HashMap对象了。搜索一圈发现，它会作为getSnapshot方法的返回值返回，有点Activity那味了。往上回溯，会发现它最终就是作为不销毁的对象，在Fragment销毁前保存下来了。 以上就是两种应用场景下ViewModelStore的创建逻辑，另外，还有清除逻辑没有讲到。这个逻辑本质上就是调用ViewModelStore的clear方法，唯一的问题就是确定调用时机。具体来说就是，Activity通过注册Lifecycle的状态监听，在Lifecycle.Event.ON_DESTROY的时候，调用了clear方法,而Fragment则是继续通过FragmentManager的desctory方法作为调用的入口点。在FragmentManagerViewModel里完成了方法调用。 总结一下，ViewModelStoreOwner是对ViewModel组的一种抽象。虽然对应着两个不同的实现，但是殊途同归，最终的目的就是保证在设备配置发生变化的时候对应ViewModelStore对象的有效性， 从而保证ViewModel对象的有效性。同时在真正需要销毁的时候做好清理工作。这就是这ViewModel的组管理功能。
ViewModel的创建管理 ViewModel用ViewModelProvider.Factory来管理创建过程。具体来说就是怎样根据一个ViewModel子类的类信息创建对应的对象。这有两个难点——必要的依赖注入、数据的恢复。对于依赖注入，ViewModel还是耍了老把戏，和创建ViewModelStore类似，提供了HasDefaultViewModelProviderFactory的一个抽象，把依赖注入转移到了ComponentActivity和Fragment中。之所以这么做，是因为在创建ViewModel的过程中，可能需要使用到Application和Bundle等信息，而这些信息是只能在在Activity和Fragment中才能获取到的。数据恢复则是关注怎样利用现有的数据将对象恢复到原来的状态。当然这些过程其实都可以没有，不需要传递Application或者Bundle对象，不需要恢复ViewModel状态，则库提供了默认的实现。就是简单的调用反射创建对象而已。 针对刚才说的各种情况，ViewModelProvider.Factory有多个实现，那么实际上它到底是使用哪个实现呢，我们得从ViewModelProvider中寻找答案。在它的构造方法里，会对ViewModelStoreOwner做类型判断，假如它是HasDefaultViewModelProviderFactory的实例，则使用实例返回的对象，否则默认的实现。结合上面的分析，让我们继续到ComponentActivity和Fragment中寻找答案。不看不知道，一看吓一跳，它们竟然都是使用了SavedStateViewModelFactory类，那么我们一起来看看它是怎么实现的吧。 在构建SavedStateViewModelFactory对象的时候，会传入三个对象——Application,SavedStateRegistryOwner,Bundle,这三个对象中最重要的就是第二个，它的主要功能就是提供在SavedStateRegistry对象，这个对象会在合适的时候保存数据，然后在合适的时候再恢复过来。它也是生命周期感知的组件。在它的create方法里，也是通过反射构建ViewModel对象的，唯一的不同就是反射多了个参数。接着往下看，最终会利用这些信息构造出SavedStateHandle对象，这个对象就是真正对我们当前创建的ViewModel对象有用的信息。SavedStateHandle提供了根据键值对保存数据的方法，也提供了查询方法，所以ViewModel可以根据这个对象，恢复自己的LiveData数据，最重要的，这个类还提供了LiveData的另一个子类SavingStateLiveData，能自动处理数据保存的问题。 一句话总结，ComponentActivity和Fragment会使用SavedStateViewModelFactory对象作为ViewModelProvider中的Factory来创建ViewModel。只要ViewModel提供了带有Application或者SavedStateHandle的构造方法，就能享受从Bundle中恢复数据的便利。
ViewModel的粘合剂ViewModelProvider 为什么说ViewModelProvider是粘合剂呢？因为这个类就做了一件事，把ViewModelStore和ViewModelProvider.Factory组合起来，实现了一个叫get的方法，这个方法的内部实现就是有两个步骤。
调用ViewModelStore的get方法查询是否有创建好的对象，如果有就返回，方法结束，否则进入步骤2。
调用ViewModelProvider.Factory的create方法创建对象，并将之保存到ViewModelStore中。
所以当我们要使用ViewModel的时候，通常是创建ViewModelProvider对象，然后调用get方法获取真正的ViewModel对象，这样，我们的对象就具备了正确处理设备配置变更的能力。
ViewModel的Fragment间通信功能 根据前面的梳理，我们知道，ViewModelStore是管理某个ViewModel组的，只要我们保证ViewModelStore存在，我们就可以保证ViewModel存活。再反推一步，要保证ViewModelStore存活，我们就要保证ViewModelStoreOwner在不同的地方都能返回同一个ViewModelStore对象，而ComponentActivity和Fragment是都实现了这个接口的。结合Activity的生命周期通常是大于Fragment这一事实，不难得出结论——在某个Fragment里面，用Activity对象创建ViewModelProvider对象，就能保证获取到和Activity一样的ViewModelStore对象，也就能保证获取到相同的ViewModel对象。只要Activity没有销毁，该Activity下的所有Fragment都能获取到相同的ViewModel对象，然后通过更改状态能方式完成通信。
到此，对ViewModel的分析告一段落了，对创建过程的两次抽象是我觉得最精彩的环节，另外对现有条件（Activity和Fragment的生命周期）的利用也是它独到之处，真的是受益匪浅。青山不改，绿水长流，咱们下期见！</description></item><item><title>沉思篇-剖析Jetpack的LiveData</title><link>https://hongui.github.io/post/%E6%B2%89%E6%80%9D%E7%AF%87-%E5%89%96%E6%9E%90Jetpack%E7%9A%84LiveData.html</link><pubDate>Tue, 23 Mar 2021 18:14:09 +0800</pubDate><guid>https://hongui.github.io/post/%E6%B2%89%E6%80%9D%E7%AF%87-%E5%89%96%E6%9E%90Jetpack%E7%9A%84LiveData.html</guid><description> 上一篇我们讲到了架构组件中的Lifecycle，由于缺少具体的运用，可能缺少直观的感受，今天我们就用Lifecycle实战一回，看看Lifecycle是怎样运用到LiveData中的。
LiveData的功能 根据LiveData的类注释，我们可以知道，LiveData是一个实现了观察者模式的数据容器，并且是可感知生命周期的。由这个功能描述，我们就能知道LiveData是由两部分功能合并而来的，一部分是数据容器，一部分是响应生命周期。在阅读源码的时候，我觉得功能拆解是个很有用的手段，合理的功能拆解，就是有目的的省略，有助于快速理清功能实现逻辑。 接下来，我将以这两个功能为突破点，逐一梳理LiveData的实现思路。
LiveData的数据容器功能 数据容器的概念相信大家不会陌生，几乎每种语言都会有他们的身影，开发者用它们来保存数据对象。由于应用场景的不同，出现了各种各样的数据容器，如List,Set这些是保存数据集的，ThreadLocal是保存线程私有数据的。那么LiveData是保存什么数据的呢，它是保存可观察数据的。 对于数据容器的拆解，其实是有固定的模式可寻的，就是以添加数据为突破口，然后以数据流向为主线，逐步击破。所以我们就从LiveData添加数据的方法setValue开始分析。
setValue方法的逻辑很少，主要就是两个，增加mVersion的版本，保存数据，然后就是调用dispatchingValue进行分发了。mVersion是个关键点，后面还会讲到，这里主要是混个脸熟。我们先进入到下一步。 dispatchingValue的功能很清楚，从名字上就能看出来，就是分发数据的。但是它的实现却是很巧妙的。为了阐述这个实现，我们需要一个合适的场景。假设当前LiveData保存的数据变动频繁，并且观察对象很多的情况，我们怎样快速，准确地把数据传递给观察者呢？或者换种说法，当我们正在分发数据的时候，又有新数据来了怎么办？通常来说有两种方案，掐头去尾。掐头就是在数据更新的时候不管新数据，先把分发操作执行完之后再处理新数据。去尾就是新数据来了，取消上一次数据分发，重新分发新数据。LiveData采用的是去尾的方式。明白了这点，再看dispatchingValue就很清晰了，它用mDispatchingValue标识分发状态，用mDispatchInvalidated来标识新数据状态，然后在使用for循环分发数据的时候检测mDispatchInvalidated的状态是不是更新了，由此确定是不是需要取消此次分发，进行新一轮的分发。其他的就没有更多奥秘可言了。 considerNotify是分发给具体的观察者之后的处理逻辑。这一步就是在步骤2中的for循环里完成的。所以这里就是数据的最后一站了。这个方法需要根据观察者的两个状态来确定是不是要通知。一个就是步骤1中提到的mVersion，因为观察者也有一份自己的mLastVersion,假如mVersion比mLastVersion小的话就没必要通知了，因为每次通知之后，它两的值是一样的。另一个就是和生命周期扯上关系的mActive了。这个状态标示着当前的观察者是否处于激活状态。假如不是，则直接返回了。搞了这两个判断之后就是简单的更新mLastVersion和执行onChanged回调了。 以上三步就是LiveData的数据更新过程，重点在于处理分发这个步骤上，在以后的项目中，我们可以借鉴这种思想，当然具体问题是需要具体分析的。 在上面的步骤3中我们知道了观察者的mActive是决定LiveData响应生命周期的关键，那么接下来我们来看看这个状态是怎么更新的吧。 LiveData的生命周期感知 联系上一篇文章沉思篇-剖析JetPack的Lifecycle,我们知道Lifecycle是专业干介个的（生命周期感知）。同时文章也提到了Lifecycle三个很重要的抽象，LifecycleOwner，Lifecycle，LifecycleObserver，这是引入生命周期感知三个很好的突破口。
LifecycleOwner作为生命周期的动力源，是直接可以获得Lifecycle的，继而可以方便地读取状态和注册状态监听，由于出色的接口封装，不需要和其他类产生耦合，是个很好的引入对象。 Lifecycle作为Lifecycle的核心类，它完成了很多功能，是抽象类，只能继承使用。 LifecycleObserver，作为状态更新通知的最后一环，可以很方便地完成状态监听，但是需要注册到合适的Lifecycle上。 所以很显然，LiveData使用Lifecycle需要搞一个LifecycleOwner，用于引入生命周期的状态，还需要搞一个LifecycleObserver，用于响应状态更新。另外，由于我们是数据容器的定位，我们的数据是很可能供给给很多类使用的，所以假如将LifecycleOwner和LiveData绑定的话，一旦某个操作致使LiveData失活，其他所有的观察者就一摸黑了，啥也收不到了，这是有悖设计的。基于这个原因，LifecycleOwner只能和Observer绑定。结果就显而易见了，他们同时出现在了observe方法里，这也就解释了observe方法为啥需要两个参数。 很明显observe就是分析生命周期感知的突破口，我们再接再励，看看他们是怎么合力工作的。
在observe内部，LifecycleOwner和Observer同时被LifecycleBoundObserver接收，用于构造对象了，逻辑继续转到LifecycleBoundObserver中.
注意到LifecycleBoundObserver是实现了LifecycleEventObserver,并且继承自ObserverWrapper。ObserverWrapper不熟悉我们先放一边，上一篇中我们知道了LifecycleEventObserver是继承自LifecycleObserver的，它只有一个状态变更的回调。很显然，我们下一步就是去看看它是怎样处理状态变更的。
来到onStateChanged方法，里面做了两件事，而且是互斥的，这就是说，其实它在某种条件下干一件事，其他条件干另一个事。先看简单的一件事，它在Lifecycle状态是DESTROYED``的时候移除了Observer，没有更多了。那么另一件事其实我们也能猜到了，就是状态不为DESTROYED的时候怎么搞。它委托给了父类ObserverWrapper`搞。
逻辑来到ObserverWrapper的activeStateChanged方法里，里面就是对LiveData的状态进行设置而已，也就是根据现在是不是激活状态更新mActiveCount的值，并且在适当的条件下通知LiveData进入激活状态或者失活状态。另外就是上面我们心心念念的mActive了，这就接上了。当然，还有个极为关键的点，在激活状态下，会以自身为参数，进行一次数据数据，在某种情况下，这可能会引入数据问题。
到这里，LiveData的生命周期感知就看完了.一句话就能总结，Lifecycle让LiveData有了在激活状态下分发数据，在失活后自动取消监听的能力。
补充说明 虽然前面讲了那么多，还有一些内容是没有讲到的，比如数据的异步更新，Observer的注册过程，等等，但是已经不妨碍我们理解主流程了。为了加深印象，我还整理一个UML图，可以对照着图再次理解，回顾。</description></item><item><title>沉思篇-剖析JetPack的Lifecycle</title><link>https://hongui.github.io/post/%E6%B2%89%E6%80%9D%E7%AF%87-%E5%89%96%E6%9E%90JetPack%E7%9A%84Lifecycle.html</link><pubDate>Sun, 21 Mar 2021 15:56:53 +0800</pubDate><guid>https://hongui.github.io/post/%E6%B2%89%E6%80%9D%E7%AF%87-%E5%89%96%E6%9E%90JetPack%E7%9A%84Lifecycle.html</guid><description>这几年，对于Android开发者来说，最时髦的技术当属Jetpack了。谷歌官方从19年开始，就在极力推动Jetpack的使用，经过这几年的发展，Jetpack也基本完成了当时的设计目标——简单，一致，专注。而使得这一切成为可能的基石，我觉得当属架构组件了。最初架构组件作为单独的库和support库并没有太多联系，随着Jetpack的成型，给架构组件也注入了新的活力。在Jetpack库中，建构组件的使用随处可见，扮演着越来越重要的角色。今天，我就以作为架构组件基石的Lifecycle开始，尝试对架构组件进行剖析，向大家展示谷歌开发者是怎样设计一个高内聚，低耦合的库的。
前言 要说阅读源码，我觉得和把大象装进冰箱的操作是一样的，就是再大的事，得分步骤。阅读源码的第一步就是站在库开发者的角度，提炼出库需要完成的功能。明确了功能，才能针对功能进行代码设计，这也是我们阅读源码的第二步，理清实现逻辑。我们可以通过画UML图的方式帮助理解。通常来说画完UML图，源码的理解也就七七八八了。这时我们就可以走到第三步，品读实现细节。有了前两步的基础，我们就可以针对性地选取一些感兴趣的内容研读实现了，而且可以做到收放自如，指哪打哪。 那我们开始吧！
Lifecycle的源码思路 明确Lifecycle的设计目标 一句话概括，Lifecycle就是完成了生命周期感知的任务。生命周期感知是什么意思呢，就是一个类可以不依赖Activity或者Fragment的回调，正确处理状态更新的问题。那么我们为什么需要这样的一个类呢，这和我们直接在回调方法里面写逻辑有什么差别吗？为了回答这个问题，我们来设想一下这样一个场景：一个Activity需要获取用户实时的位置信息，同时需要使用相机，以往我们的做法是在Activity的某些回调里面设置位置，相机的监听及解监听。如果这时，Activity再加入其他的一些逻辑，它的代码就可能膨胀到不能忍受的地步，并且随着业务的增长，后续Activity的膨胀是不可预期的，这样是不利于调试和测试的，而且，从设计上来说，这样的设计也是脆弱的，耦合太紧了。但是我们的这些组件确确实实是需要响应生命周期回调的啊，那么怎样才能做到既能感知生命周期，又能降低耦合呢。计算机科学告诉我们这样一条真理，当找不到其他方法时，可以考虑加一层抽象。由此，Lifecycle诞生了。这就是Lifecycle的目标，很纯粹，就是生命周期感知，就是把专业的事情交给专业的去做。
Lifecycle的工作流程 概括来说，Lifecycle就是完成了状态监听和状态分发的两个功能。为了完成这两个功能，Lifecycle抽象出了三个概念，也可以说是三个流程吧。
拥有生命周期的对象，称为LifecycleOwner，这其实只是一个接口，只要能提供Lifecycle的都可以称为LifecycleOwner，这个类主要的功能就是提供原始的生命周期事件，供后续的操作提供数据，这是第一步——状态感知； 拥有生命周期状态，称为Lifecycle，这个类主要的功能就是提供状态抽象和提供状态信息，这是第二步——状态更新； 对生命周期状态感兴趣的观察者，称为LifecycleObserver，这个类主要的功能就是对状态信息进行响应，这是第三步——状态响应。 流程很简单，看着也很清晰的，就是观察者模式。但是Lifecycle库为了完成更好的解耦和提供更多的扩展，在这三个环节上衍生出了更多的类，这也是我以Lifecycle为剖析对象的原因。我觉得一个好的库，不仅仅要能够完成库的设计目标，同时还应该保持尽可能的扩展性和可读性。在这点上，Lifecycle无疑是我们很好的榜样。接下来，我们就一起以这三个阶段为主线，逐一剖析Lifecycle是怎样完成抽象，设计，及实现的。
Lifecycle的状态感知 传统的状态感知就是重写Activity和Fragment的生命周期回调，在回调里面进行状态更新。这其实也是Lifecycle实现的基本思路，只是它将这些个回调抽象为了一个个的事件。那么怎么将生命周期转化为一个个事件呢？Lifecycle用了一个巧妙的方法，自定义了一个ReportFragment。ReportFragment作用很明确，就是监听生命周期，生成状态事件。 如图所示，本质上ReportFragment还是监听了Activity的生命周期，绑定关系就发生在injectIfNeededIn方法中。然后为了将监听到的状态传递出去给其他类使用，ReportFragment借助了dispatch方法。这里有个很巧妙的设计细节，dispatch并没有直接引用自己的组件，而是使用了Activity，但是为什么还是能将事件发送出去呢？因为这里面使用了动态类型判断及转换的操作，最终，转换成了分发器LifecycleRegistry来完成事件分发操作。从而顺利讲逻辑转到了第二阶段，状态更新。
Lifecycle的状态更新 状态更新主要的逻辑还是放在了LifecycleRegistry类里，这个类是继承了Lifecycle的。 如图所示，这个类作为Lifecycle的子类完成了被观察对象的两个功能，接收和管理观察对象。其次作为核心类它又完成了状态更新的功能。事件在这里被转化为状态，保存了下来，然后通知给自己的观察者。从类缩略图中，我们也可以看出这些方法就是为了完成这两大功能而设计的。知道了这些，状态更新的步骤也就了解了。那么顺理成章的，我们马上进入第三个步骤。
Lifecycle的状态响应 LifecycleObserver是个空接口，那么状态更新怎么做呢？这就还得从LifecycleRegistry开始看起。LifecycleRegistry在添加LifecycleObserver的时候做了包装，于是LifecycleObserver变成了多种LifecycleObserver的子类，在不同的子类里面其实都直接或者间接地继承自LifecycleEventObserver。所以最终状态是通过LifecycleEventObserver的onStateChanged方法通知给观察者的。但是我们很快发现不对劲，官方Demo是直接实现LifecycleObserver，并且只需要用注解对感兴趣的状态注册就可以了。这里完全没有体现哇。按照刚才的思路，我们还是从添加LifecycleObserver的方法开始，LifecycleObserver被包装成ObserverWithState对象，而在构造方法里面委托给了Lifecycling，所以最终的秘密藏在Lifecycling。Lifecycling里面对多种LifecycleObserver进行了处理，其中就包括了我们熟悉的注解的方式。所以，总结来看，我们通过注解定义LifecycleObserver观察者后，注册到LifecycleRegistry就会被包装成新的观察者对象。然后，在状态更新的时候，用过注解找到合适的方法来通知观察者。到这里其实整个Lifecycle的工作流程已经理清了，我根据这些整理出了一份UML图。 由UML图，我们可以直观地得出一句话的结论，LifecycleRegistry使用LifecycleOwner提供的Lifecycle，使用观察者的模式把状态传递给了LifecycleEventObserver，这就是我最开始说的三个抽象之间的联系。
品读实现细节 经过多次的品读，我发现了Lifecycle的多个小细节值得我们细细品味，其一就是Lifecycle强大的抽象。Lifecycle使用了LifecycleOwner抽象了生命周期这个概念，生命周期不一定是和Activity绑定的，用户可以自己定义自己的LifecycleOwner，定制满足自己业务需求的Lifecycle。其次LifecycleRegistry是一个很好的高内聚，低耦合的实现典范——LifecycleRegistry依赖的都是LifecycleOwner和LifecycleObserver这样的顶层接口，遵循了依赖倒置原则、LifecycleRegistry内部对LifecycleObserver的包装又委托给了Lifecycling，遵循了单一职责原则，就连LifecycleRegistry的方法都是严格遵守单一职责原则的，不得不叹服开发者对代码强大的掌控力。 当然，还有其他也很不错的实现细节，我没有一一展开，因为代码是读不完的，我们抓住我们感兴趣的就行了，有些细节就是用来忽略的，我们不得不承认这个事实。
青山不改，绿水长流，咱们下期见！</description></item></channel></rss>