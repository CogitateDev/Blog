<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width"><meta name=theme-color content="#584394" media="(prefers-color-scheme: light)"><meta name=generator content="Hugo 0.104.3"><link rel="shortcut icon" type=image/x-icon href=/images/icons/favicon.ico><link rel=icon type=image/x-icon href=/images/icons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=/images/icons/favicon_16x16.png><link rel=icon type=image/png sizes=32x32 href=/images/icons/favicon_32_32.png><link rel=apple-touch-icon sizes=180x180 href=/imgs/icons/apple_touch_icon.png><meta itemprop=name content="CMake个人理解和使用"><meta itemprop=description content="CMake个人理解和使用"><meta itemprop=datePublished zgotmplz><meta itemprop=dateModified zgotmplz><meta itemprop=image content="https://hongui.github.io/images/logo.png"><meta itemprop=keywords content="Android,JNI,C/C++,CMake"><meta property="og:type" content="article"><meta property="og:title" content="CMake个人理解和使用"><meta property="og:description" content="CMake个人理解和使用"><meta property="og:image" content="/images/logo.png"><meta property="og:image:width" content="312"><meta property="og:image:height" content="312"><meta property="og:image:type" content="image/jpeg/png/svg/jpg"><meta property="og:url" content="https://hongui.github.io/post/CMake%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3%E5%92%8C%E4%BD%BF%E7%94%A8.html"><meta property="og:site_name" content="低头沉思"><meta property="og:locale" content="zh-CN"><meta property="article:author" content="hongui"><meta property="article:published_time" content="2021-08-09 19:21:49 +0800 +0800"><meta property="article:modified_time" content="2021-08-09 19:21:49 +0800 +0800"><link type=text/css rel=stylesheet href=https://unpkg.com/@fortawesome/fontawesome-free@6.1.2/css/all.min.css><link type=text/css rel=stylesheet href=https://unpkg.com/animate.css@3.1.1/animate.min.css><link rel=stylesheet href=/css/main.min.ea2133055f0dd66b681b45ae139d39761f21e9653bc626affcc679a566412d4c.css><style type=text/css>.post-footer,.flinks-list-footer hr:after{content:"~ 我可是有底线的哟 ~"}</style><script class=next-config data-name=page type=application/json>{"comments":false,"isHome":false,"isPage":true,"path":"CMake%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3%E5%92%8C%E4%BD%BF%E7%94%A8.html","permalink":"https://hongui.github.io/post/CMake%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3%E5%92%8C%E4%BD%BF%E7%94%A8.html","title":"CMake个人理解和使用"}</script><script type=text/javascript>document.addEventListener("DOMContentLoaded",()=>{var e=document.createElement("script");e.charset="UTF-8",e.id="LA_COLLECT",e.src="https://sdk.51.la/js-sdk-pro.min.js",e.async="true",e.onload=function(){LA.init({id:"JrJFibzvtRuObfi1",ck:"JrJFibzvtRuObfi1",autoTrack:!0})},document.head.appendChild(e)})</script><title>CMake个人理解和使用 - 低头沉思</title><noscript><link rel=stylesheet href=/css/noscript.css></noscript></head><body itemscope itemtype=http://schema.org/WebPage><div class=headband></div><main class=main><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-brand-container><div class=site-nav-toggle><div class=toggle aria-label=切换导航栏 role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div></div><div class=site-meta><a href=/ class=brand rel=start><i class=logo-line></i><h1 class=site-title>低头沉思</h1><i class=logo-line></i></a><p class=site-subtitle itemprop=description>保持思考</p></div><div class=site-nav-right><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class=site-nav><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href=/ class=hvr-icon-pulse rel=section><i class="fa fa-home hvr-icon"></i>首页</a></li><li class="menu-item menu-item-archives"><a href=/ class=hvr-icon-pulse rel=section><i class="fa fa-archives hvr-icon"></i>归档
<span class=badge>14</span></a></li><li class="menu-item menu-item-tags"><a href=/tags/ class=hvr-icon-pulse rel=section><i class="fa fa-tags hvr-icon"></i>标签</a></li><li class="menu-item menu-item-about"><a href=/about.html class=hvr-icon-pulse rel=section><i class="fa fa-user hvr-icon"></i>关于</a></li><li class="menu-item menu-item-search"><a role=button class="popup-trigger hvr-icon-pulse"><i class="fa fa-search fa-fw hvr-icon"></i>搜索</a></li></ul></nav><div class=search-pop-overlay><div class="popup search-popup"><div class=search-header><span class=search-icon><i class="fa fa-search"></i></span><div class=search-input-container><input autocomplete=off autocapitalize=off maxlength=80 placeholder=搜索... spellcheck=false type=search class=search-input></div><span class=popup-btn-close role=button><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class=search-result-icon><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></div><div class="toggle sidebar-toggle" role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div><aside class=sidebar><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class=sidebar-nav><li class=sidebar-nav-toc>文章目录</li><li class=sidebar-nav-overview>站点概览</li></ul><div class=sidebar-panel-container><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><nav id=TableOfContents><ul><li><a href=#项目搭建>项目搭建</a></li><li><a href=#项目编译与执行>项目编译与执行</a></li><li><a href=#项目扩展>项目扩展</a></li></ul><ul><li><a href=#个人感悟>个人感悟</a></li><li><a href=#cmake管理子目录>CMake管理子目录</a></li><li><a href=#cmake管理子模块>CMake管理子模块</a></li></ul><ul><li><a href=#前期准备>前期准备</a></li><li><a href=#编写编译脚本>编写编译脚本</a></li></ul><ul><li><a href=#目录结构>目录结构</a></li><li><a href=#构建静态库>构建静态库</a></li><li><a href=#使用静态库>使用静态库</a><ul><li><a href=#配置gradle>配置Gradle</a></li><li><a href=#配置cmake>配置CMake</a><ul><li><a href=#找到头文件>找到头文件</a></li><li><a href=#找到静态库>找到静态库</a></li><li><a href=#链接静态库>链接静态库</a></li></ul></li><li><a href=#在源码中使用>在源码中使用</a></li></ul></li><li><a href=#扩展>扩展</a></li></ul></nav></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop=author itemscope itemtype=http://schema.org/Person><img class=site-author-image itemprop=image alt=hongui src=/images/logo.png><p class=site-author-name itemprop=name>hongui</p><div class=site-description itemprop=description>记录生活所思所见。</div></div><div class="site-state-wrap site-overview-item animated"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/><span class=site-state-item-count>14</span>
<span class=site-state-item-name>日志</span></a></div><div class="site-state-item site-state-categories"><a href=/categories/><span class=site-state-item-count>7</span>
<span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/><span class=site-state-item-count>17</span>
<span class=site-state-item-name>标签</span></a></div></nav></div><div class="links-of-social site-overview-item animated"><span class=links-of-social-item><a href=https://github.com/hongui title="Github → https://github.com/hongui" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-github fa-fw hvr-icon"></i></a></span></div><div class="cc-license animated" itemprop=license><a href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh class=cc-opacity rel=noopener target=_blank title=共享知识><img src=/imgs/cc/big/by_nc_sa.svg alt=共享知识></a></div><div class="links-of-blogroll site-overview-item animated"><div class=links-of-blogroll-title><i class="fa fa-globe fa-fw"></i>友情链接</div><ul class=links-of-blogroll-list><li class=links-of-blogroll-item><a href=https://gitee.com/hugo-next/hugo-theme-next title=https://gitee.com/hugo-next/hugo-theme-next target=_blank>Hugo-NexT</a></li></ul></div></div></div></div><div class=sidebar-card-widget><div class=item-headline><i class="fas fa-chart-line"></i>
<span>网站资讯</span></div><div class=siteinfo><div class=siteinfo-item><div class=item-name><i class="fa-solid fa-calendar-check"></i>已运行：</div><div class=item-count id=runTimes data-publishdate=2021/03/21T15:56:53+08:00></div></div><div id=la-siteinfo-widget style=display:none><script id=LA-DATA-WIDGET crossorigin=anonymous src="https://v6-widget.51.la/v6/JrJFibzvtRuObfi1/quote.js?theme=0&col=true&f=12&display=0,0,0,1,0,1,1,1"></script></div><div class=siteinfo-item><div class=item-name><i class="fa fa-user-plus"></i>今日访问：</div><div class=item-count id=today_site_pv></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-user-clock"></i>昨日访问：</div><div class=item-count id=yesterday_site_pv></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-arrows-down-to-people"></i>本月访问：</div><div class=item-count id=month_site_pv></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-users"></i>总访问量：</div><div class=item-count id=total_site_pv></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-font"></i>总字数：</div><div class=item-count id=wordsCount data-count=2824></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-mug-hot"></i>阅读约：</div><div class=item-count id=readTimes data-times=21></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-clock-rotate-left"></i>最后更新于：</div><div class=item-count id=last-push-date data-lastpushdate=2022/07/20T22:15:05+08:00></div></div></div></div></aside><div class=sidebar-dimmer></div></header><div class=tool-buttons><a id=goto-comments class="button goto-comments" href=#comments title=直达评论><i class="fas fa-comments"></i></a><div id=switch-theme class=button title=深浅模式切换><i class="fas fa-adjust"></i></div><div class=back-to-top role=button title=返回顶部><i class="fa fa-arrow-up"></i>
<span>0%</span></div></div><div class=reading-progress-bar></div><a role=button class="book-mark-link book-mark-link-fixed"></a>
<a href=https://github.com/hongui rel="noopener external nofollow noreferrer" target=_blank title="Follow me on GitHub" class="exturl github-corner"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115h15l12 27L250 250V0z"/><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentcolor" style="transform-origin:130px 106px" class="octo-arm"/><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4l13.9-13.8C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8z" fill="currentcolor" class="octo-body"/></svg></a><noscript><div class=noscript-warning>Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner post posts-expand"><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://hongui.github.io/post/CMake%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3%E5%92%8C%E4%BD%BF%E7%94%A8.html><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/images/logo.png"><meta itemprop=name content="hongui"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="hongui"><meta itemprop=description content="记录生活所思所见。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="CMake个人理解和使用"><meta itemprop=description content="CMake个人理解和使用"></span><header class=post-header><h1 class=post-title itemprop="name headline">CMake个人理解和使用</h1><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar"></i></span>
<span class=post-meta-item-text>发表于：</span>
<time title="发表于：2021-08-09 19:21:49 +0800 +0800" itemprop="dateCreated datePublished" datetime="2021-08-09 19:21:49 +0800 +0800">2021/08/09</time></span>
<span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-folder-open"></i></span>
<span class=post-meta-item-text>分类于：</span>
<span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/c/c++ itemprop=url rel=index><span itemprop=name>C/C++</span></a></span></span></div><div class=post-meta-items><span class=post-meta-item title=字数><span class=post-meta-item-icon><i class="far fa-file-word"></i></span>
<span class=post-meta-item-text>字数：</span><span>442</span></span>
<span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="far fa-eye"></i></span>
<span class=post-meta-item-text>浏览：</span>
<span id=waline-pageview-count data-path=/post/CMake%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3%E5%92%8C%E4%BD%BF%E7%94%A8.html><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class="post-body autonumber" itemprop=articleBody><h1 id=前言>前言</h1><p>CMake是一个构建工具，通过它可以很容易创建跨平台的项目。通常使用它构建项目要分两步，通过源代码生成工程文件，通过工程文件构建目标产物（可能是动态库，静态库，也可能是可执行程序）。使用CMake的一个主要优势是在多平台或者多人协作的项目中，开发人员可以根据自己的喜好来使选择IDE，不用受其他人工程配置的影响，它有点像跨平台的IDE，通过它配置好相关设置之后，可以在多个平台无缝衔接，提高开发效率。</p><h1 id=最简单的cmake工程>最简单的CMake工程</h1><h2 id=项目搭建>项目搭建</h2><p>一个用CMake来管理的项目，其项目根目录通常会包含一个<code>CMakeLists.txt</code>的文件，当然子目录可能也有，这种情况我们稍后再说。我们先从最简单的项目开始。以下就是一个最简单的工程示例：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>CMakeProject
</span></span><span style=display:flex><span>|    CMakeLists.txt
</span></span><span style=display:flex><span>|    main.cpp
</span></span></code></pre></div><p>这就是完整的可以跑起来的最小项目了。按照顺序，我们来看看文件里的内容</p><p><code>CMakeLists.txt</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span># 设置版本号
</span></span><span style=display:flex><span>cmake_minimum_required(VERSION 3.10)
</span></span><span style=display:flex><span># 设置项目名
</span></span><span style=display:flex><span>project(CMakeProject)
</span></span><span style=display:flex><span># 设置产物和源码的关联
</span></span><span style=display:flex><span>add_executable(${CMAKE_PROJECT_NAME} main.cpp)
</span></span></code></pre></div><p>说明：</p><ul><li>CMake中命令不区分大小写</li><li>以<code>#</code>开始的是备注</li><li>引用变量语法<code>${变量名}</code></li></ul><p>所以文档中真正的有效内容就三行，</p><ol><li><code>cmake_minimum_required(VERSION 3.10)</code>设置了CMake支持的最低版本，<code>VERSION</code>是参数名，后面是版本号，可以根据自己的需要修改。 <strong>注意参数名和参数是以空白符分隔的，不是逗号，</strong> 不然会报错。</li><li><code>project(CMakeProject)</code>CMake中字符串可以带引号或者不带，效果是一致的，这一行就是配置了项目名，如生成的Visual Studio的工程名就是依据这个名字来的。</li><li><code>add_executable(${CMAKE_PROJECT_NAME} main.cpp)</code>
才是真正管理源码和目标产物的地方，这里我们使用了引用变量的写法，而文件中没有定义这个变量，说明这个变量存在于CMake中，在CMake还有很多预定义的变量，我们可以直接通过这种方式引用，上面的写法是将项目名设置为产物的名字，当然也可以直接填字符串，取个另外的名字都是可以的。后面的<code>main.cpp</code>则是用来生成产物的源码路径，这就是CMake最灵活的地方。<strong>源码路径可以是多样的，查找出来的，直接写的，相对路径，绝对路径都可以。</strong> 多个源码的话就用空白符分隔，依次写就行了。
在上面的配置文件中，我们配置了它的源文件为<code>main.cpp</code>，我们想通过它来生成一个可执行的程序，内容也很简单:</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>#include &lt;iostream&gt;
</span></span><span style=display:flex><span>int main()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	std::cout&lt;&lt;&#34;hello CMake&#34;&lt;&lt;std::endl;
</span></span><span style=display:flex><span>	return 0;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=项目编译与执行>项目编译与执行</h2><p>准备工作已经做完，接下来我们就要使用CMake生成可执行文件了。</p><p>第一步当然是要安装CMake啦，这是下载地址
<a href=https://cmake.org/download/ title=!Download rel="noopener external nofollow noreferrer" target=_blank class=exturl>!Download
<i class="fa fa-external-link-alt"></i>
</a>，根据自己的平台选择下载即可，安装完成之后需要把它添加到环境变量中，便于我们在任何地方都能方便使用。
安装了CMake以后，打开命令行工具，进入到刚才创建的项目根目录，也就是进入到存着<code>CMakeLists.txt</code>和<code>main.cpp</code>的目录，下一步准备生成项目。</p><p>通常为了不影响和污染当前的工作环境，我们会选择新建一个目录来存放生成的工程文件，以下我主要以Windows平台为主要平台讲解，其他平台基本一致。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>mkdir build                 #创建文件夹，存储工程文件；
</span></span><span style=display:flex><span>cd build                    #切换cmake工作目录;
</span></span><span style=display:flex><span>cmake ..                    #生成项目文件；
</span></span></code></pre></div><p>这三步执行完后，我们就可以在build文件夹下看到里面已经生成了一个Visual Studio的工程，我们可以直接用Visual Studio打开这个工程，按照我们的习惯执行编译和调试。当然，假如想最快地生成可执行文件，我还是推荐使用CMake。</p><p>使用CMake执行编译，只需要在上一步的基础上（也就是已经成功执行了上面的三个步骤）再执行一个命令<code>cmake --build .</code>就可以了。这里切记不能少第三个英文句号，它代表在当前的工作目录中执行CMake的编译。
假如上面的四步都一切顺利的话，那么，我们就可以在<code>build/debug</code>目录下看到以<code>add_executable</code>的第一个参数命名的可执行文件（这里就是<code>CMakeProject.exe</code>），双击或者把它拖到命令行就可以执行它了。</p><h2 id=项目扩展>项目扩展</h2><p>在前面的例子中，生成工程文件，我们使用了两个命令，其实，这里可以直接用一个命令就可以完成——<code>cmake build -S . -B build</code>。这个命令的意思是以当前路径为工作路径，以<code>build</code>目录为生成目录，生成工程文件，也就是不需要我们手动创建<code>build</code>文件夹了。其中 <code>-S</code>参数配置的是源路径，<code>-B</code>配置的是生成路径。</p><p>另外，由于CMake没有清理方法，所以每次修改CMake的配置（也就是新增或者删除<code>CMakeLists.txt</code>中的代码），需要重新生成工程文件的时候，需要我们手动清理生成目录，保证它是空目录，假如不这样做，那么项目可能生成失败或者新配置不起作用。假如只是修改了源代码的内容的话，则不需要重新生成，直接进行第四步即可。
虽然上面的操作已经足够简单，但是考虑到长期的修改和验证需要，还是太繁琐枯燥了，尤其是要反复切换工作目录，还是比较烦人的。所以我推荐使用批处理来完成这些操作。结合清理生成目录和切换工作目录这几个步骤，最终的批处理文件可能是这样的</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>
</span></span><span style=display:flex><span>@echo off 
</span></span><span style=display:flex><span>rd /s /q build
</span></span><span style=display:flex><span>mkdir build
</span></span><span style=display:flex><span>cd build
</span></span><span style=display:flex><span>cmake ..
</span></span><span style=display:flex><span>cmake --build .
</span></span><span style=display:flex><span>cd debug
</span></span><span style=display:flex><span>CMakeProject
</span></span><span style=display:flex><span>cd ../..
</span></span></code></pre></div><p>按顺序依次解释一下:</p><p>第一行是关闭了命令行的回显功能，因为我们不希望它的回显干扰到CMake的信息输出，以造成不必要的混乱，而且通常我们也只关心它最后有没有完成工作而不是看它在干什么。</p><p>第二行则是用了Windows上的删除文件夹命令（Linux，MacOS上对应的是rmdir),/s是配置它清除文件夹中所有的内容，包括子文件夹，不配置命令就会执行失败，/q则是让命令直接执行删除，不需要我们手动确认，这个参数很重要，不然我们需要一个一个地确认删除，完全失去了自动化的作用。然后后面的四句就是我们上面讲的内容了，不再赘述。</p><p>一直来到倒数第二句，这里我直接写了可执行文件的名字（需要替换为你自己的名字），为的就是直接在编译完成之后运行可执行文件，这对有些会生成文件的应用来说很有用。</p><p>执行结束后，再将目录切回到项目根目录，这就是最后一行的作用，由于我们再编译的时候已经切换了目录到生成目录了，而编译的可执行文件又是在生成目录的子目录中，所以回到根目录，我们需要回退两次，这是保证下次我们能胜利执行批处理的关键。</p><p>把上面的内容保存为bat结尾的文件，然后下次就可以直接在命令行输入bat文件名来一次性完成生成和构建了，简直爽歪歪。
以上就是CMake项目我们所需要知道的了。当然实际项目远比这个复杂得多，接下来我将以我踩过的坑为基础，逐一增加项目的复杂度，慢慢形成对CMake的工作流程的理解。</p><h1 id=多源码项目>多源码项目</h1><h2 id=个人感悟>个人感悟</h2><p>在开始之前，我先讲一讲我对CMake项目或者说<code>CMakeLists.txt</code>文件的理解。<strong>我们不能单独的以某一个配置为理解对象，我们需要对这些命令进行分类甚至提炼出它的核心工作模式。我是以c++文件的编译链接为线索梳理的。</strong> 我们都知道一个c++源文件要想生成可执行代码，需要分三步</p><ul><li>预处理器处理，拷贝头文件的内容到源文件，宏替换等；</li><li>编译器将源文件编译为.o的对象文件；</li><li>链接器以.o文件和其他库为输入，链接生成可执行文件。</li></ul><p>我们按照这个思路来理解CMake就简单多了。假如CMake报错，我们就可以根据报错信息定位到是哪个阶段出了问题，进而快速找到解决办法。另外我们也可以依据这些信息对CMake的配置分类，我自己理解的粗略分类如下:</p><ul><li>配置CMake基本信息的：<code>cmake_minimum_required</code>；</li><li>源码管理的：<code>file</code>,<code>aux_source_directory</code>；</li><li>库管理的：<code>find_libraray</code>；</li><li>头文件管理的：<code>include_directories</code>；</li><li>链接库管理的：<code>link_directories</code>；</li><li>子项目管理的：<code>add_subdirectory</code>；</li><li>生成物管理的：<code>add_executable</code>,<code>add_library</code>；</li></ul><p>当然，这些只是很少的一部分，但是对我们理解和搜索问题的解决思路提供了较好的方向。</p><h2 id=cmake管理子目录>CMake管理子目录</h2><p>很多时候，我们会引入第三方包来减少重复编码的工作，通常这种代码我们需要放在其他目录中，于是我新建了一个子目录，用于模拟存放的第三方代码。对于这种情况，我们有两种包含形式——子模块和子目录。</p><p>先说简单一些的子目录吧。子目录的意思就是将第三方代码看作我们代码的一部分，一起合并编译，这种方式可以使我们的项目看起来更紧凑。如以下的项目结构</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>CMakeProject
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>|   auto.bat
</span></span><span style=display:flex><span>|   CMakeLists.txt              //修改
</span></span><span style=display:flex><span>|   main.cpp                    //修改
</span></span><span style=display:flex><span>|   
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>\---3rd                         //新增
</span></span><span style=display:flex><span>        lib.h       
</span></span></code></pre></div><p>我新建了一个子文件夹，用来模拟第三方代码，现在我们把它引入到<code>main.cpp</code>中，编译，就会发现报错了，信息为<code>fatal error C1083: 无法打开包括文件: “lib.h”: No such file or directory，</code>这很正常。结合上面我举的例子。这个报错信息是和头文件相关的，查看CMake文档，我发现了CMake有个<code>include_directories</code>的指令，它的意思就是添加文件头的目录，以便让CMake找到头文件。于是，我在<code>CMakeLists.txt</code>文件中添加了<code>include_directories(3rd)</code>，然后再次执行编译，项目又正确跑起来了。来看看这时的<code>main.cpp</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>#include &lt;iostream&gt;
</span></span><span style=display:flex><span>#include &lt;lib.h&gt;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>int main()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    int a=1,b=1;
</span></span><span style=display:flex><span>	std::cout&lt;&lt;&#34;hello CMake&#34;&lt;&lt;std::endl;
</span></span><span style=display:flex><span>    std::cout&lt;&lt;&#34;a + b = &#34;&lt;&lt;sum(a,b)&lt;&lt;std::endl;
</span></span><span style=display:flex><span>	return 0;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>注意：这里的<code>include_directories</code>和cpp中的<code>include</code>是一一对应的，就是说，假如<code>include_directories</code>里面配置的目录是.（当前目录，CMake没有把当前目录添加到<code>include</code>路径），则对应cpp的<code>include</code>要写成<code>3rd/lib.h</code>这种形式，简单来说，就是<code>include_directories</code>被设置为了<code>include</code>的根目录。
另一种情况就是子模块。</p><h2 id=cmake管理子模块>CMake管理子模块</h2><p>子模块的意思是，模块可以单独编译，单独提供给其他库使用，而不是和主项目共生的，适用于和主模块耦合不大的情况。为了满足这个条件，我们修改刚才的目录结构为下面这种</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>CMakeProject
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>|   auto.bat
</span></span><span style=display:flex><span>|   CMakeLists.txt                   //修改
</span></span><span style=display:flex><span>|   main.cpp                    
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>|   
</span></span><span style=display:flex><span>\---3rd
</span></span><span style=display:flex><span>        CMakeLists.txt               //新增
</span></span><span style=display:flex><span>        lib.cpp                      //新增
</span></span><span style=display:flex><span>        lib.h                        //修改
</span></span></code></pre></div><p>我把<code>lib.h</code>中的函数改为声明，实现放在了<code>lib.cpp</code>文件中。最大的变化是新建了<code>3rd</code>目录下的<code>CMakeLists.txt</code>文件，用它统一管理<code>3rd</code>目录下的所有源文件（假如文件很多的话，这里是模拟）,使用了<code>add_library</code>把<code>3rd</code>目录下打包成了子模块。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>project(sum)
</span></span><span style=display:flex><span>add_library(${PROJECT_NAME} lib.cpp)
</span></span></code></pre></div><p><code>add_library</code>在名字和源代码中间还可以指定构建类型，默认是<code>STATIC</code>，也就是静态库，假如想构建动态库需要手动指定为<code>SHARED</code>（<code>add_library(${PROJECT_NAME} SHARED lib.cpp)</code>）。</p><p>重要的改变来自主目录下的<code>CMakeLists.txt</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span># 设置版本号
</span></span><span style=display:flex><span>cmake_minimum_required(VERSION 3.10)
</span></span><span style=display:flex><span># 设置项目名
</span></span><span style=display:flex><span>project(CMakeProject)
</span></span><span style=display:flex><span># 指定3rd为include的查找目录
</span></span><span style=display:flex><span>include_directories(3rd)
</span></span><span style=display:flex><span># 子模块
</span></span><span style=display:flex><span>add_subdirectory(3rd)
</span></span><span style=display:flex><span># 设置产物和源码的关联
</span></span><span style=display:flex><span>add_executable(${PROJECT_NAME} main.cpp)
</span></span><span style=display:flex><span>target_link_libraries(${PROJECT_NAME} sum)
</span></span></code></pre></div><p>新增了<code>add_subdirectory</code>，它的作用是将指定目录下的源码作为一个模块编译，前提是这个目录下要有<code>CMakeLists.txt</code>文件。另一个改变就是<code>target_link_libraries</code>的添加，它的作用是将子模块链接进主模块，假如没有这一句，在链接的时候会报错<code>error LNK2019: 无法解析的外部符号</code>。模块的名字需要和子模块中<code>add_library</code>中第一个参数保持一致。</p><h1 id=交叉编译>交叉编译</h1><p>在前面的示例中，项目的复杂度表现在多目录，多源码，而在使用CMake进行交叉编译的过程中，项目的主要复杂度表现在环境配置。尽管CMake可以几乎不修改<code>CMakeLists.txt</code>的情况下，实现交叉编译，但是对于新手，面对陌生的配置，往往会无从下手，企图找到一键就完成配置的简便方法。对于CMake,确实没有这种快捷方法，但是，只要我们理解了<strong>交叉编译就是正确配置属性值的过程。</strong> 这一实质之后，问题就会变得明朗起来。所以，上面的问题就会转化为我们熟悉的问题了——需要配置哪些属性，这些属性有哪些合适的值，这些值怎样传递给CMake等等，这就是交叉编译的全部了。正如之前提到的一样，CMake有很多预设的变量，我们需要从这些预设变量中找到一些，设置一些值，然后让CMake按照这些配置完成工作，这就是我们接下来需要做的事。下面我将以Windows交叉编译Android为例说明这个过程。</p><h2 id=前期准备>前期准备</h2><p>在Windows平台上，默认会使用Visual Studio作为C，C++的编译器，这对于编译Android的库来说可能会报错。所以在执行<code>cmake</code>命令的时候，需要使用<code> -G "Unix Makefiles"</code>来改变这一行为。但这还不够，因为CMake编译是需要指定编译器的。而Android上的C,C++编译器通常以NDK的方式提供，所以，我们需要下载好NDK。在NDK中，会同时为我们提供两种工具，一种就是编译器，另一种就是<code>android.toolchain.cmake</code>,这也是CMake命令构成的文件，里面为我们交叉编译指定了很多预设值，能大大减轻我们的工作。</p><h2 id=编写编译脚本>编写编译脚本</h2><p>前面说了，交叉编译就是改变CMake预设值，而改变这预设值的方式有两种，我们要结合起来使用。一种是通过NDK提供的<code>android.toolchain.cmake</code>文件。 <code>android.toolchain.cmake</code>中以设置了绝大部分的值，但是这些配置也是很灵活的，还有很大的配置空间。因此，根据用户的需求不同，我们还需要在执行CMake命令时动态传递一些值，以使CMake能正确完成工作。这就是另一种方式——选项。传递选项会以<code>-D</code>开头，后面跟着某个CMake的预定义变量由于选项很多，而且大多比较复杂，所以，最好还是通过脚本文件来记录并且修改。以下就是Windows平台上编译Android代码需要指定的几个选项，我将逐个介绍这些必要的配置。</p><ul><li><code>-DCMAKE_SYSTEM_NAME=Android</code>这个配置是告诉CMake需要生成Android平台的库，也就是执行交叉编译。</li><li><code>-DANDROID_ABI=x86</code>这个配置是告诉CMake生成库适用的架构平台。熟悉Android开发的读者应该不会陌生，支持的值会根据NDK的变化而有所变化，如早期的<code>armeabi</code>已经在 NDK r17中移除了，现在主流的还有四种<code>armeabi-v7a</code>，<code>arm64-v8a</code>，<code>x86</code>，<code>x86_64</code>.根据需要把值替换就行。</li><li><code>-DANDROID_PLATFORM=android-28</code>,这个值其实不是特别必要，因为有预设值，但是为了可控，还是需要指定一个。它是用来确定库支持的最低系统版本的。</li><li><code>-DCMAKE_TOOLCHAIN_FILE=C:/Users/Leroene/AppData/Local/Android/Sdk/ndk/21.0.6113669/build/cmake/android.toolchain.cmake</code>，这是上面提到的预设文件。需要注意的是，NDK中有多个以这个名字命名的文件，假如指定错误，可能会导致CMake出错，所以我的经验就是，更改版本号（<code>C:/Users/Leroene/AppData/Local/Android/Sdk/ndk/21.0.6113669</code>）及前面的路径，后面的保持不变。</li><li><code>-DCMAKE_MAKE_PROGRAM=C:/Users/Leroene/AppData/Local/Android/Sdk/ndk/21.0.6113669/prebuilt/windows-x86_64/bin/make</code>最后一个参数是指定<code>make</code>程序的路径，由于我们指定生成了make项目的代码，而Windows通常没有make可执行文件，所以我们需要让CMake找到make文件以完成编译。这里我的经验也是保持后面的不变，修改前面的，并保持版本一致以避免BUG。</li><li><code>-DCMAKE_BUILD_TYPE=Release</code>，指定构建类型，这应该很常见了。</li></ul><p>至此Windows交叉编译Android库的所有配置都讲解完了。让我们来看看它完整的例子</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>@echo off
</span></span><span style=display:flex><span>rd /s /q build
</span></span><span style=display:flex><span>mkdir build
</span></span><span style=display:flex><span>cd build
</span></span><span style=display:flex><span>cmake -G &#34;Unix Makefiles&#34; ^
</span></span><span style=display:flex><span>-DCMAKE_TOOLCHAIN_FILE=C:/Users/Leroene/AppData/Local/Android/Sdk/ndk/21.0.6113669/build/cmake/android.toolchain.cmake ^
</span></span><span style=display:flex><span>-DCMAKE_MAKE_PROGRAM=C:/Users/Leroene/AppData/Local/Android/Sdk/ndk/21.0.6113669/prebuilt/windows-x86_64/bin/make ^
</span></span><span style=display:flex><span>-DANDROID_PLATFORM=android-28 ^
</span></span><span style=display:flex><span>-DCMAKE_SYSTEM_NAME=Android ^
</span></span><span style=display:flex><span>-DANDROID_ABI=x86 ^
</span></span><span style=display:flex><span>-DCMAKE_BUILD_TYPE=Release ^
</span></span><span style=display:flex><span>../3rd
</span></span><span style=display:flex><span>cmake --build .
</span></span></code></pre></div><p>从上面可以看到，这些选项后面都跟着一个<code>^</code>符号，这不是cmake的一部分，只是为了我们阅读方便，特意书写成这样的，这是在Windows平台上批处理使用的命令换行符，它的作用就是告诉命令解析器，这个命令还没有结束，接着往下面解析，该功能在Linux,MacOS上对应于<code>\</code>。现在有了这些配置之后，该怎么使用呢？其实也很简单，只需要将这些命令存储在<code>android.bat</code>文件中，在CMD中切换到当前目录，执行这个文件就能在<code>build</code>目录中找到以<code>libsum.a</code>命名的静态库文件了。下一步，我们试着用这个库文件运行在模拟器中。</p><h1 id=在android项目中使用cmake>在Android项目中使用CMake</h1><p>在Android平台中，也使用CMake来管理jni的项目，配合Gradle一起完成构建工作。这和普通的CMake项目最大的不同是，我们通常需要引用多个Android相关的库，如<code>log</code>,<code>android</code>等.这些库通常是由NDK提供的，我们仿照默认生成的<code>CMakeLists.txt</code>文件编写就可。</p><h2 id=目录结构>目录结构</h2><p>接下来，为了描述方便，我们先来看一下现在的目录结构（为了避免混乱，这里只列出比较有代表性的文件）</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>CMakeProject
</span></span><span style=display:flex><span>│  android.bat
</span></span><span style=display:flex><span>│  CMakeLists.txt
</span></span><span style=display:flex><span>│  main.cpp
</span></span><span style=display:flex><span>│  
</span></span><span style=display:flex><span>├─3rd
</span></span><span style=display:flex><span>│      CMakeLists.txt
</span></span><span style=display:flex><span>│      lib.cpp
</span></span><span style=display:flex><span>│      lib.h
</span></span><span style=display:flex><span>│      
</span></span><span style=display:flex><span>└─Android
</span></span><span style=display:flex><span>    │  build.gradle
</span></span><span style=display:flex><span>    │       
</span></span><span style=display:flex><span>    ├─app
</span></span><span style=display:flex><span>    │  │  build.gradle
</span></span><span style=display:flex><span>    │  │                   
</span></span><span style=display:flex><span>    │  ├─libs
</span></span><span style=display:flex><span>    │  └─src                     
</span></span><span style=display:flex><span>    │      ├─main
</span></span><span style=display:flex><span>    │      │  │  AndroidManifest.xml
</span></span><span style=display:flex><span>    │      │  │  
</span></span><span style=display:flex><span>    │      │  ├─cpp
</span></span><span style=display:flex><span>    │      │  │      CMakeLists.txt
</span></span><span style=display:flex><span>    │      │  │      native-lib.cpp
</span></span><span style=display:flex><span>    │      │  │      
</span></span><span style=display:flex><span>    │      │  ├─java
</span></span><span style=display:flex><span>    │      │  │  └─me
</span></span><span style=display:flex><span>    │      │  │      └─hongui
</span></span><span style=display:flex><span>    │      │  │          └─cmakesum
</span></span><span style=display:flex><span>    │      │  │                  MainActivity.kt
</span></span><span style=display:flex><span>    │      │  │                  
</span></span><span style=display:flex><span>    │      │  ├─jniLibs
</span></span><span style=display:flex><span>    │      │  │  └─x86
</span></span><span style=display:flex><span>    │      │  │          libsum.a
</span></span></code></pre></div><p>在原来的目录根目录下新建了<code>Android</code>子目录，该目录是一个Android C++工程，所以相比其他普通Android工程，它多了个<code>cpp</code>目录，后面我们主要的修改都是发生在该目录下。</p><p>原来的根目录，为了不增加复杂度，我们只作为生成静态库的功能存在，所以和上面的示例相比，没有任何修改。</p><h2 id=构建静态库>构建静态库</h2><p>首先，我们回到根目录。使用根目录下的<code>android.bat</code>批处理生成Android上可用的静态库，也可以修改<code>android.bat</code>文件中的<code>-DANDROID_ABI</code>选项的值，生成其他架构的静态库，但这需要和<code>jniLibs</code>目录下的目录要一一对应，否则可能链接失败。如我生成的<code>libsum.a</code>文件是<code>x86</code>的架构。那么就需要在<code>jniLibs</code>目录下新建<code>x86</code>的目录下，然后再把<code>libsum.a</code>放到该目录下。至此，静态库的构建工作就算结束了。</p><h2 id=使用静态库>使用静态库</h2><p>把静态库放到合适的位置后，我们需要配置<code>app</code>目录下的<code>build.gradle</code>和<code>cpp</code>目录下的<code>CMakeLists.txt</code>文件，完成静态库的引入。</p><h3 id=配置gradle>配置Gradle</h3><p>首先说<code>build.gradle</code>，该文件主要涉及到修改ABI的问题，因为不指定的话，Gradle默认生成的ABI可能找不到对应的静态库文件来链接，从而导致链接失败。该文件主要的修改如下</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>android {
</span></span><span style=display:flex><span>    defaultConfig {
</span></span><span style=display:flex><span>        externalNativeBuild {
</span></span><span style=display:flex><span>                cmake {
</span></span><span style=display:flex><span>                    cppFlags &#34;&#34;
</span></span><span style=display:flex><span>                    abiFilters &#34;x86&#34;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>也就是把<code>abiFilters</code>的值指定为刚才构建的静态库相同的值。</p><h3 id=配置cmake>配置CMake</h3><p>而<code>CMakeLists.txt</code>文件就复杂一些了，它需要完成两个工作，找到静态库和静态库的头文件，链接静态库。</p><h4 id=找到头文件>找到头文件</h4><p>在文章的第二部分我们已经知道了让CMake找到头文件的<code>include_directories</code>命令，把参数设置为<code>3rd</code>目录就行了。值得注意的是，CMake是以当前的<code>CMakeLists.txt</code>文件为工作目录的，所以，要指定到<code>3rd</code>文件，我们需要一直回退目录到根项目，最终就有了<code>include_directories(../../../../../3rd)</code>这样的配置。尽量使用相对路径，可以在多人协同的情况下，不用修改配置。</p><h4 id=找到静态库>找到静态库</h4><p>下一步要让CMake找到我们的静态库。说到库，都是和<code>add_library</code>相关的，不同的只是参数。使用源码添加库的时候，我们需要指定库的名称和源码位置，而引用第三方库，则是需要指定库的名称和类型，外加一个<code>IMPORTED</code>的指示参数，告诉CMake这个库是导入的。所以就有了<code>add_library(addSum STATIC IMPORTED)</code>这样的配置。</p><p>但是，这里我们只告诉了CMake库的名字，库存储在哪里，还不知道，所以我们还需要另一个命令告诉CMake库的存储位置。涉及到配置参数的，通常就是<code>set_target_properties</code>命令了，可以多次调用这个命令设置多种配置。<code>set_target_properties(addSum PROPERTIES IMPORTED_LOCATION ${CMAKE_CURRENT_SOURCE_DIR}/../jniLibs/${ANDROID_ABI}/libsum.a)</code>,第一个参数和上一条的第一个参数是一一对应的，可以随便取。其实<code>add_library</code>相当于生成了一种目标产物，用第一个参数来指代这种产物，所以才让我们的<code>set_target_properties</code>找得到合适的目标设置属性。第二个参数则是配置属性的标准写法，第三个代表属性变量，第四个是属性值，配置库路径的变量就是<code>IMPORTED_LOCATION</code>，而值这里就有个坑了，Android下的CMake限定值必须是绝对路径，不能是相对路径。而这与使用CMake的初衷背道而驰，幸好，我们有几个预设值可以用，<code>CMAKE_CURRENT_SOURCE_DIR</code>就是其中之一，它代表着当前这个<code>CMakeLIsts.txt</code>文件的绝对路径，有了这个，再加上目录的回退功能，我们就能找到任何合适的目录了。至此，又出现了第二个问题，当有多个架构的静态库需要配置时，我们引入的目录是不一样的，而且会出现很多重复的配置。还好有<code>ANDROID_ABI</code>的帮助，它指代了当前编译的某个架构，随着编译的进行，这个值会被设置为合适的值，并且是和正在编译的架构是一一对应的。所以，尽管它们有点奇怪，但是这给我带来了灵活和简单。</p><h4 id=链接静态库>链接静态库</h4><p>现在头文件有了，库也有了，但是C++的编译是分成两步的，目前为止，我们的工作只做完了编译的事情，还没涉及到链接的事情，当然，相比前面的配置，这就简单多了，无疑就是在<code>target_link_libraries</code>命令里添加一个参数就可，如</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>target_link_libraries( 
</span></span><span style=display:flex><span>                       native-lib
</span></span><span style=display:flex><span>                       ${log-lib}
</span></span><span style=display:flex><span>                       addSum
</span></span><span style=display:flex><span>        )
</span></span></code></pre></div><p>只需哟注意名字和<code>add_library</code>时配置的名字一一对应就可。</p><h3 id=在源码中使用>在源码中使用</h3><p>经过漫长的等待，现在我们终于能在<code>native-lib.cpp</code>文件中引入<code>addsum</code>的头文件，并且使用里面的函数完成工作了。我打算让函数返回一个包含加法运算结果的字符串。最终实现如下</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>#include &lt;jni.h&gt;
</span></span><span style=display:flex><span>#include &lt;string&gt;
</span></span><span style=display:flex><span>#include &lt;lib.h&gt;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>extern &#34;C&#34; JNIEXPORT jstring JNICALL
</span></span><span style=display:flex><span>Java_me_hongui_cmakesum_MainActivity_stringFromJNI(
</span></span><span style=display:flex><span>        JNIEnv* env,
</span></span><span style=display:flex><span>        jobject /* this */) {
</span></span><span style=display:flex><span>    std::string hello = std::to_string(sum(1,1));
</span></span><span style=display:flex><span>    return env-&gt;NewStringUTF(hello.c_str());
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>至此，点击工具栏上的<code>run</code>按钮，我们终于可以在Android的模拟器上看到我们的静态库工作的成果啦。</p><h2 id=扩展>扩展</h2><p>其实除了引用静态库的方式之外，我们还可以直接通过配置<code>CMakeLists.txt</code>文件来引用源码，这样可以随时随地对源码进行定制，但是也降低了编译速度，而且可能会增加<code>CMakeLists.txt</code>的复杂度。所以我还是推荐直接使用静态库的方式。</p><h1 id=总结>总结</h1><p>CMake其实还有很多很多命令，我们这里涉及到的只是很少的一部分。但是，我觉得理解CMake有这些内容差不多就可以了，后续有需要再针对性学习就行了。学习一门技术，切忌不能贪多，贪细。先要抓住主干，理清脉络，后面的细节就是水到渠成的事。对于CMake，我觉得就是以C++代码编译为二进制的过程为主干就够了。源码从哪里来，头文件在那里，库文件在哪里，怎么组织编译，参与链接的库有哪些，生成什么产物，还有一些完成这些工作的通用操作，复制文件啊，目录信息啊等，这些操作的集合就构成了CMake的主体。另外，CMake其实只是一种构建工具，它本身不是编译器和链接器，有些问题可能不仅仅会涉及到cmake，还可能会涉及到编译器和连接器。当然，这些都是后面深入了解之后才可能碰到的问题了。</p></div><footer class=post-footer><div class=post-tags><a href=/tags/android>Android</a>
<a href=/tags/jni>JNI</a>
<a href=/tags/c/c++>C/C++</a>
<a href=/tags/cmake>CMake</a></div><div class=addthis_inline_share_toolbox style=text-align:center></div><hr><div class=post-copyright><img src=/imgs/cc/cc.svg width=75 height=75 align=right><ul><li class=post-copyright-title><strong>文章标题：</strong>
CMake个人理解和使用</li><li class=post-copyright-author><strong>原文作者：</strong>
hongui</li><li class=post-copyright-link><strong>本文链接：</strong>
<a id=post-cr-link href=https://hongui.github.io/post/CMake%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3%E5%92%8C%E4%BD%BF%E7%94%A8.html title=CMake个人理解和使用>https://hongui.github.io/post/CMake%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3%E5%92%8C%E4%BD%BF%E7%94%A8.html</a></li><li class=post-copyright-license><strong>版权声明：</strong>
本博客所有文章除特别声明外，均采用 <i class="fab fa-fw fa-creative-commons"></i><a target=_blank href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh>BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><div class=post-nav><div class="post-nav-next post-nav-item"><a href=/post/Android-JNI%E5%BC%80%E5%8F%91%E6%A6%82%E8%AE%BA.html rel=next title=Android-JNI开发概论><i class="fa fa-chevron-left"></i> Android-JNI开发概论</a></div><div class="post-nav-prev post-nav-item"><a href=/post/%20Kotlin%E5%8D%8F%E7%A8%8B-%E4%BB%8E%E4%B8%80%E5%88%B0%E5%A4%9A.html rel=prev title=" Kotlin协程-从一到多">Kotlin协程-从一到多
<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div id=comments class=post-comments><div class=comment-head><div class=comment-headline><i class="fas fa-comments fa-fw"></i>
<span>评论交流</span></div><div class=comment-switch><span class=first-comment>Giscus</span>
<span class=switch-btn></span>
<span class=second-comment>Waline</span></div></div><div class=comment-wrap><div><div class=comment-loading><i class="fa fa-sync fa-spin"></i></div><div class=giscus-container></div></div><div><div class=comment-loading><i class="fa fa-sync fa-spin"></i></div><div class=waline-container></div></div></div></div></div></main><footer class=footer><div class=footer-inner><div class=copyright>&copy;
<span itemprop=copyrightYear>2020 - 2022</span>
<span class=with-love><i class="fa fa-heart"></i></span>
<span class=author itemprop=copyrightHolder>hongui</span></div><div class=powered-by>由 <a href=https://gohugo.io title=0.104.3 target=_blank>Hugo</a> & <a href=https://github.com/hugo-next/hugo-theme-next title=4.3.1 target=_blank>Hugo NexT.Mist</a> 强力驱动</div></div></footer><script type=text/javascript src=https://unpkg.com/animejs@3.2.1/lib/anime.min.js defer></script>
<script class=next-config data-name=main type=application/json>{"bookmark":{"color":"#584394","enable":true,"save":"manual"},"copybtn":true,"darkmode":false,"giscus":{"cfg":{"category":"Comments","categoryid":null,"emit":false,"inputposition":"top","mapping":"title","reactions":false,"repo":"username/repo-name","repoid":null,"theme":"preferred_color_scheme"},"js":"https://giscus.app/client.js"},"hostname":"https://hongui.github.io/","i18n":{"ds_day":" 天前","ds_days":" 天 ","ds_hour":" 小时前","ds_hours":" 小时 ","ds_just":"刚刚","ds_min":" 分钟前","ds_mins":" 分钟","ds_month":" 个月前","ds_years":" 年 ","empty":"没有找到任何搜索结果：${query}","hits":"","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","placeholder":"搜索..."},"lang":"zh-CN","lazyload":false,"localSearch":{"enable":true,"path":"/searchindexes.xml","preload":false,"topnperarticle":-1,"trigger":"auto","unescape":false},"motion":{"async":true,"enable":false,"transition":{"collheader":"fadeInLeft","postblock":"fadeIn","postbody":"fadeInDown","postheader":"fadeInDown","sidebar":"fadeInUp"}},"root":"/","scheme":"Mist","sidebar":{"display":"post","offset":12,"padding":18,"position":"left","width":256},"vendor":{"plugins":"unpkg","router":"https://unpkg.com"},"version":"4.3.1","waline":{"cfg":{"emoji":false,"imguploader":false,"pageview":"#waline-pageview-count","placeholder":"请文明发言哟 ヾ(≧▽≦*)o","reaction":true,"reactiontext":["点赞","踩一下","得意","不屑","尴尬","睡觉"],"reactiontitle":"你认为这篇文章怎么样？","requiredmeta":["nick","mail"],"serverurl":null,"sofa":"快来发表你的意见吧 (≧∀≦)ゞ","wordlimit":200},"css":{"alias":"waline","file":"dist/waline.css","name":"@waline/client","version":"2.11.3"},"js":{"alias":"waline","file":"dist/waline.js","name":"@waline/client","version":"2.11.3"}}}</script><script type=text/javascript src=/js/main.min.b28dfe5c5269e780969d70d2aab1f0a1501079780df3a0178998c5edfd89e071.js defer></script></body></html>