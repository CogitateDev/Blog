<!doctype html><html lang=zh-CN dir=ltr class=scroll-smooth data-default-appearance=light data-auto-appearance=true><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=theme-color content="rgb(255,255,255)"><title>CMake个人理解和使用 &#183; 低头沉思</title>
<meta name=title content="CMake个人理解和使用 &#183; 低头沉思"><script type=text/javascript src=/js/appearance.min.022d0ebc3b46a335eb1c7ef79b7f2de143d7cd5156d433638592ef1ce5f8554e.js integrity="sha256-Ai0OvDtGozXrHH73m38t4UPXzVFW1DNjhZLvHOX4VU4="></script><link type=text/css rel=stylesheet href=/css/main.bundle.min.2dd44849efa9d0ef68e8cdede2901f86dec79026811f5cf6b25aa2b8cd8ee63e.css integrity="sha256-LdRISe+p0O9o6M3t4pAfht7HkCaBH1z2slqiuM2O5j4="><meta name=description content="
      CMake个人理解和使用
    "><link rel=canonical href=https://bravebuffalo.cc/post/CMake%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3%E5%92%8C%E4%BD%BF%E7%94%A8.html><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><meta property="og:title" content="CMake个人理解和使用"><meta property="og:description" content="CMake个人理解和使用"><meta property="og:type" content="article"><meta property="og:url" content="https://bravebuffalo.cc/post/CMake%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3%E5%92%8C%E4%BD%BF%E7%94%A8.html"><meta property="article:section" content="post"><meta property="article:published_time" content="2021-08-09T19:21:49+08:00"><meta property="article:modified_time" content="2021-08-09T19:21:49+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="CMake个人理解和使用"><meta name=twitter:description content="CMake个人理解和使用"><script type=application/ld+json>{"@context":"https://schema.org","@type":"Article","articleSection":"Posts","name":"CMake个人理解和使用","headline":"CMake个人理解和使用","description":"CMake个人理解和使用","abstract":"\u003ch1 id=\u0022前言\u0022 class=\u0022relative group\u0022\u003e前言 \u003cspan class=\u0022absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100\u0022\u003e\u003ca class=\u0022group-hover:text-primary-300 dark:group-hover:text-neutral-700\u0022 style=\u0022text-decoration-line: none !important;\u0022 href=\u0022#%e5%89%8d%e8%a8%80\u0022 aria-label=\u0022锚点\u0022\u003e#\u003c\/a\u003e\u003c\/span\u003e\u003c\/h1\u003e\u003cp\u003eCMake是一个构建工具，通过它可以很容易创建跨平台的项目。通常使用它构建项目要分两步，通过源代码生成工程文件，通过工程文件构建目标产物（可能是动态库，静态库，也可能是可执行程序）。使用CMake的一个主要优势是在多平台或者多人协作的项目中，开发人员可以根据自己的喜好来使选择IDE，不用受其他人工程配置的影响，它有点像跨平台的IDE，通过它配置好相关设置之后，可以在多个平台无缝衔接，提高开发效率。\u003c\/p\u003e","inLanguage":"zh-CN","url":"https:\/\/bravebuffalo.cc\/post\/CMake%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3%E5%92%8C%E4%BD%BF%E7%94%A8.html","author":{"@type":"Person","name":"低头沉思"},"copyrightYear":"2021","dateCreated":"2021-08-09T19:21:49\u002b08:00","datePublished":"2021-08-09T19:21:49\u002b08:00","dateModified":"2021-08-09T19:21:49\u002b08:00","keywords":["Android","JNI","C/C++","CMake"],"mainEntityOfPage":"true","wordCount":"440"}</script><meta name=author content="低头沉思"><link href=mailto:honguilee@163.com rel=me><link href=https://github.com/hongui rel=me></head><body class="flex flex-col h-screen px-6 m-auto text-lg leading-7 max-w-7xl bg-neutral text-neutral-900 dark:bg-neutral-800 dark:text-neutral sm:px-14 md:px-24 lg:px-32"><div id=the-top class="absolute flex self-center"><a class="px-3 py-1 text-sm -translate-y-8 rounded-b-lg bg-primary-200 focus:translate-y-0 dark:bg-neutral-600" href=#main-content><span class="font-bold pe-2 text-primary-600 dark:text-primary-400">&darr;</span>跳到主要内容</a></div><header class="py-6 font-semibold text-neutral-900 dark:text-neutral print:hidden sm:py-10"><nav class="flex items-start justify-between sm:items-center"><div class="flex flex-row items-center"><a class="decoration-primary-500 hover:underline hover:decoration-2 hover:underline-offset-2" rel=me href=/>低头沉思</a></div><ul class="flex flex-col list-none text-end sm:flex-row"><li class="group mb-1 sm:mb-0 sm:me-7 sm:last:me-0.5"><a href title><span class="decoration-primary-500 group-hover:underline group-hover:decoration-2 group-hover:underline-offset-2">文章</span></a></li><li class="group mb-1 sm:mb-0 sm:me-7 sm:last:me-0.5"><a href=/categories/ title=Categories><span class="decoration-primary-500 group-hover:underline group-hover:decoration-2 group-hover:underline-offset-2">分类</span></a></li><li class="group mb-1 sm:mb-0 sm:me-7 sm:last:me-0.5"><a href=/tags/ title=Tags><span class="decoration-primary-500 group-hover:underline group-hover:decoration-2 group-hover:underline-offset-2">标签</span></a></li><li class="group mb-1 sm:mb-0 sm:me-7 sm:last:me-0.5"></li></ul></nav></header><div class="relative flex flex-col grow"><main id=main-content class=grow><article><header class=max-w-prose><h1 class="mt-0 text-4xl font-extrabold text-neutral-900 dark:text-neutral">CMake个人理解和使用</h1><div class="mt-8 mb-12 text-base text-neutral-500 dark:text-neutral-400 print:hidden"><div class="flex flex-row flex-wrap items-center"><time datetime="2021-08-09 19:21:49 +0800 +0800">9 August 2021</time><span class="px-2 text-primary-500">&#183;</span><span title=预计阅读>3 分钟</span></div></div></header><section class="flex flex-col max-w-full mt-0 prose dark:prose-invert lg:flex-row"><div class="min-w-0 min-h-0 max-w-prose grow"><h1 id=前言 class="relative group">前言 <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%e5%89%8d%e8%a8%80 aria-label=锚点>#</a></span></h1><p>CMake是一个构建工具，通过它可以很容易创建跨平台的项目。通常使用它构建项目要分两步，通过源代码生成工程文件，通过工程文件构建目标产物（可能是动态库，静态库，也可能是可执行程序）。使用CMake的一个主要优势是在多平台或者多人协作的项目中，开发人员可以根据自己的喜好来使选择IDE，不用受其他人工程配置的影响，它有点像跨平台的IDE，通过它配置好相关设置之后，可以在多个平台无缝衔接，提高开发效率。</p><h1 id=最简单的cmake工程 class="relative group">最简单的CMake工程 <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%e6%9c%80%e7%ae%80%e5%8d%95%e7%9a%84cmake%e5%b7%a5%e7%a8%8b aria-label=锚点>#</a></span></h1><h2 id=项目搭建 class="relative group">项目搭建 <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%e9%a1%b9%e7%9b%ae%e6%90%ad%e5%bb%ba aria-label=锚点>#</a></span></h2><p>一个用CMake来管理的项目，其项目根目录通常会包含一个<code>CMakeLists.txt</code>的文件，当然子目录可能也有，这种情况我们稍后再说。我们先从最简单的项目开始。以下就是一个最简单的工程示例：</p><pre tabindex=0><code>CMakeProject
|    CMakeLists.txt
|    main.cpp
</code></pre><p>这就是完整的可以跑起来的最小项目了。按照顺序，我们来看看文件里的内容</p><p><code>CMakeLists.txt</code></p><pre tabindex=0><code># 设置版本号
cmake_minimum_required(VERSION 3.10)
# 设置项目名
project(CMakeProject)
# 设置产物和源码的关联
add_executable(${CMAKE_PROJECT_NAME} main.cpp)
</code></pre><p>说明：</p><ul><li>CMake中命令不区分大小写</li><li>以<code>#</code>开始的是备注</li><li>引用变量语法<code>${变量名}</code></li></ul><p>所以文档中真正的有效内容就三行，</p><ol><li><code>cmake_minimum_required(VERSION 3.10)</code>设置了CMake支持的最低版本，<code>VERSION</code>是参数名，后面是版本号，可以根据自己的需要修改。 <strong>注意参数名和参数是以空白符分隔的，不是逗号，</strong> 不然会报错。</li><li><code>project(CMakeProject)</code>CMake中字符串可以带引号或者不带，效果是一致的，这一行就是配置了项目名，如生成的Visual Studio的工程名就是依据这个名字来的。</li><li><code>add_executable(${CMAKE_PROJECT_NAME} main.cpp)</code>
才是真正管理源码和目标产物的地方，这里我们使用了引用变量的写法，而文件中没有定义这个变量，说明这个变量存在于CMake中，在CMake还有很多预定义的变量，我们可以直接通过这种方式引用，上面的写法是将项目名设置为产物的名字，当然也可以直接填字符串，取个另外的名字都是可以的。后面的<code>main.cpp</code>则是用来生成产物的源码路径，这就是CMake最灵活的地方。<strong>源码路径可以是多样的，查找出来的，直接写的，相对路径，绝对路径都可以。</strong> 多个源码的话就用空白符分隔，依次写就行了。
在上面的配置文件中，我们配置了它的源文件为<code>main.cpp</code>，我们想通过它来生成一个可执行的程序，内容也很简单:</li></ol><pre tabindex=0><code>#include &lt;iostream&gt;
int main()
{
	std::cout&lt;&lt;&#34;hello CMake&#34;&lt;&lt;std::endl;
	return 0;
}
</code></pre><h2 id=项目编译与执行 class="relative group">项目编译与执行 <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%e9%a1%b9%e7%9b%ae%e7%bc%96%e8%af%91%e4%b8%8e%e6%89%a7%e8%a1%8c aria-label=锚点>#</a></span></h2><p>准备工作已经做完，接下来我们就要使用CMake生成可执行文件了。</p><p>第一步当然是要安装CMake啦，这是下载地址<a href=https://cmake.org/download/ target=_blank rel=noreferrer>!Download</a>，根据自己的平台选择下载即可，安装完成之后需要把它添加到环境变量中，便于我们在任何地方都能方便使用。
安装了CMake以后，打开命令行工具，进入到刚才创建的项目根目录，也就是进入到存着<code>CMakeLists.txt</code>和<code>main.cpp</code>的目录，下一步准备生成项目。</p><p>通常为了不影响和污染当前的工作环境，我们会选择新建一个目录来存放生成的工程文件，以下我主要以Windows平台为主要平台讲解，其他平台基本一致。</p><pre tabindex=0><code>mkdir build                 #创建文件夹，存储工程文件；
cd build                    #切换cmake工作目录;
cmake ..                    #生成项目文件；
</code></pre><p>这三步执行完后，我们就可以在build文件夹下看到里面已经生成了一个Visual Studio的工程，我们可以直接用Visual Studio打开这个工程，按照我们的习惯执行编译和调试。当然，假如想最快地生成可执行文件，我还是推荐使用CMake。</p><p>使用CMake执行编译，只需要在上一步的基础上（也就是已经成功执行了上面的三个步骤）再执行一个命令<code>cmake --build .</code>就可以了。这里切记不能少第三个英文句号，它代表在当前的工作目录中执行CMake的编译。
假如上面的四步都一切顺利的话，那么，我们就可以在<code>build/debug</code>目录下看到以<code>add_executable</code>的第一个参数命名的可执行文件（这里就是<code>CMakeProject.exe</code>），双击或者把它拖到命令行就可以执行它了。</p><h2 id=项目扩展 class="relative group">项目扩展 <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%e9%a1%b9%e7%9b%ae%e6%89%a9%e5%b1%95 aria-label=锚点>#</a></span></h2><p>在前面的例子中，生成工程文件，我们使用了两个命令，其实，这里可以直接用一个命令就可以完成——<code>cmake build -S . -B build</code>。这个命令的意思是以当前路径为工作路径，以<code>build</code>目录为生成目录，生成工程文件，也就是不需要我们手动创建<code>build</code>文件夹了。其中 <code>-S</code>参数配置的是源路径，<code>-B</code>配置的是生成路径。</p><p>另外，由于CMake没有清理方法，所以每次修改CMake的配置（也就是新增或者删除<code>CMakeLists.txt</code>中的代码），需要重新生成工程文件的时候，需要我们手动清理生成目录，保证它是空目录，假如不这样做，那么项目可能生成失败或者新配置不起作用。假如只是修改了源代码的内容的话，则不需要重新生成，直接进行第四步即可。
虽然上面的操作已经足够简单，但是考虑到长期的修改和验证需要，还是太繁琐枯燥了，尤其是要反复切换工作目录，还是比较烦人的。所以我推荐使用批处理来完成这些操作。结合清理生成目录和切换工作目录这几个步骤，最终的批处理文件可能是这样的</p><pre tabindex=0><code>
@echo off 
rd /s /q build
mkdir build
cd build
cmake ..
cmake --build .
cd debug
CMakeProject
cd ../..
</code></pre><p>按顺序依次解释一下:</p><p>第一行是关闭了命令行的回显功能，因为我们不希望它的回显干扰到CMake的信息输出，以造成不必要的混乱，而且通常我们也只关心它最后有没有完成工作而不是看它在干什么。</p><p>第二行则是用了Windows上的删除文件夹命令（Linux，MacOS上对应的是rmdir),/s是配置它清除文件夹中所有的内容，包括子文件夹，不配置命令就会执行失败，/q则是让命令直接执行删除，不需要我们手动确认，这个参数很重要，不然我们需要一个一个地确认删除，完全失去了自动化的作用。然后后面的四句就是我们上面讲的内容了，不再赘述。</p><p>一直来到倒数第二句，这里我直接写了可执行文件的名字（需要替换为你自己的名字），为的就是直接在编译完成之后运行可执行文件，这对有些会生成文件的应用来说很有用。</p><p>执行结束后，再将目录切回到项目根目录，这就是最后一行的作用，由于我们再编译的时候已经切换了目录到生成目录了，而编译的可执行文件又是在生成目录的子目录中，所以回到根目录，我们需要回退两次，这是保证下次我们能胜利执行批处理的关键。</p><p>把上面的内容保存为bat结尾的文件，然后下次就可以直接在命令行输入bat文件名来一次性完成生成和构建了，简直爽歪歪。
以上就是CMake项目我们所需要知道的了。当然实际项目远比这个复杂得多，接下来我将以我踩过的坑为基础，逐一增加项目的复杂度，慢慢形成对CMake的工作流程的理解。</p><h1 id=多源码项目 class="relative group">多源码项目 <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%e5%a4%9a%e6%ba%90%e7%a0%81%e9%a1%b9%e7%9b%ae aria-label=锚点>#</a></span></h1><h2 id=个人感悟 class="relative group">个人感悟 <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%e4%b8%aa%e4%ba%ba%e6%84%9f%e6%82%9f aria-label=锚点>#</a></span></h2><p>在开始之前，我先讲一讲我对CMake项目或者说<code>CMakeLists.txt</code>文件的理解。<strong>我们不能单独的以某一个配置为理解对象，我们需要对这些命令进行分类甚至提炼出它的核心工作模式。我是以c++文件的编译链接为线索梳理的。</strong> 我们都知道一个c++源文件要想生成可执行代码，需要分三步</p><ul><li>预处理器处理，拷贝头文件的内容到源文件，宏替换等；</li><li>编译器将源文件编译为.o的对象文件；</li><li>链接器以.o文件和其他库为输入，链接生成可执行文件。</li></ul><p>我们按照这个思路来理解CMake就简单多了。假如CMake报错，我们就可以根据报错信息定位到是哪个阶段出了问题，进而快速找到解决办法。另外我们也可以依据这些信息对CMake的配置分类，我自己理解的粗略分类如下:</p><ul><li>配置CMake基本信息的：<code>cmake_minimum_required</code>；</li><li>源码管理的：<code>file</code>,<code>aux_source_directory</code>；</li><li>库管理的：<code>find_libraray</code>；</li><li>头文件管理的：<code>include_directories</code>；</li><li>链接库管理的：<code>link_directories</code>；</li><li>子项目管理的：<code>add_subdirectory</code>；</li><li>生成物管理的：<code>add_executable</code>,<code>add_library</code>；</li></ul><p>当然，这些只是很少的一部分，但是对我们理解和搜索问题的解决思路提供了较好的方向。</p><h2 id=cmake管理子目录 class="relative group">CMake管理子目录 <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#cmake%e7%ae%a1%e7%90%86%e5%ad%90%e7%9b%ae%e5%bd%95 aria-label=锚点>#</a></span></h2><p>很多时候，我们会引入第三方包来减少重复编码的工作，通常这种代码我们需要放在其他目录中，于是我新建了一个子目录，用于模拟存放的第三方代码。对于这种情况，我们有两种包含形式——子模块和子目录。</p><p>先说简单一些的子目录吧。子目录的意思就是将第三方代码看作我们代码的一部分，一起合并编译，这种方式可以使我们的项目看起来更紧凑。如以下的项目结构</p><pre tabindex=0><code>CMakeProject

|   auto.bat
|   CMakeLists.txt              //修改
|   main.cpp                    //修改
|   

\---3rd                         //新增
        lib.h       
</code></pre><p>我新建了一个子文件夹，用来模拟第三方代码，现在我们把它引入到<code>main.cpp</code>中，编译，就会发现报错了，信息为<code>fatal error C1083: 无法打开包括文件: “lib.h”: No such file or directory，</code>这很正常。结合上面我举的例子。这个报错信息是和头文件相关的，查看CMake文档，我发现了CMake有个<code>include_directories</code>的指令，它的意思就是添加文件头的目录，以便让CMake找到头文件。于是，我在<code>CMakeLists.txt</code>文件中添加了<code>include_directories(3rd)</code>，然后再次执行编译，项目又正确跑起来了。来看看这时的<code>main.cpp</code></p><pre tabindex=0><code>#include &lt;iostream&gt;
#include &lt;lib.h&gt;

int main()
{
    int a=1,b=1;
	std::cout&lt;&lt;&#34;hello CMake&#34;&lt;&lt;std::endl;
    std::cout&lt;&lt;&#34;a + b = &#34;&lt;&lt;sum(a,b)&lt;&lt;std::endl;
	return 0;
}
</code></pre><p>注意：这里的<code>include_directories</code>和cpp中的<code>include</code>是一一对应的，就是说，假如<code>include_directories</code>里面配置的目录是.（当前目录，CMake没有把当前目录添加到<code>include</code>路径），则对应cpp的<code>include</code>要写成<code>3rd/lib.h</code>这种形式，简单来说，就是<code>include_directories</code>被设置为了<code>include</code>的根目录。
另一种情况就是子模块。</p><h2 id=cmake管理子模块 class="relative group">CMake管理子模块 <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#cmake%e7%ae%a1%e7%90%86%e5%ad%90%e6%a8%a1%e5%9d%97 aria-label=锚点>#</a></span></h2><p>子模块的意思是，模块可以单独编译，单独提供给其他库使用，而不是和主项目共生的，适用于和主模块耦合不大的情况。为了满足这个条件，我们修改刚才的目录结构为下面这种</p><pre tabindex=0><code>CMakeProject

|   auto.bat
|   CMakeLists.txt                   //修改
|   main.cpp                    

|   
\---3rd
        CMakeLists.txt               //新增
        lib.cpp                      //新增
        lib.h                        //修改
</code></pre><p>我把<code>lib.h</code>中的函数改为声明，实现放在了<code>lib.cpp</code>文件中。最大的变化是新建了<code>3rd</code>目录下的<code>CMakeLists.txt</code>文件，用它统一管理<code>3rd</code>目录下的所有源文件（假如文件很多的话，这里是模拟）,使用了<code>add_library</code>把<code>3rd</code>目录下打包成了子模块。</p><pre tabindex=0><code>project(sum)
add_library(${PROJECT_NAME} lib.cpp)
</code></pre><p><code>add_library</code>在名字和源代码中间还可以指定构建类型，默认是<code>STATIC</code>，也就是静态库，假如想构建动态库需要手动指定为<code>SHARED</code>（<code>add_library(${PROJECT_NAME} SHARED lib.cpp)</code>）。</p><p>重要的改变来自主目录下的<code>CMakeLists.txt</code></p><pre tabindex=0><code># 设置版本号
cmake_minimum_required(VERSION 3.10)
# 设置项目名
project(CMakeProject)
# 指定3rd为include的查找目录
include_directories(3rd)
# 子模块
add_subdirectory(3rd)
# 设置产物和源码的关联
add_executable(${PROJECT_NAME} main.cpp)
target_link_libraries(${PROJECT_NAME} sum)
</code></pre><p>新增了<code>add_subdirectory</code>，它的作用是将指定目录下的源码作为一个模块编译，前提是这个目录下要有<code>CMakeLists.txt</code>文件。另一个改变就是<code>target_link_libraries</code>的添加，它的作用是将子模块链接进主模块，假如没有这一句，在链接的时候会报错<code>error LNK2019: 无法解析的外部符号</code>。模块的名字需要和子模块中<code>add_library</code>中第一个参数保持一致。</p><h1 id=交叉编译 class="relative group">交叉编译 <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%e4%ba%a4%e5%8f%89%e7%bc%96%e8%af%91 aria-label=锚点>#</a></span></h1><p>在前面的示例中，项目的复杂度表现在多目录，多源码，而在使用CMake进行交叉编译的过程中，项目的主要复杂度表现在环境配置。尽管CMake可以几乎不修改<code>CMakeLists.txt</code>的情况下，实现交叉编译，但是对于新手，面对陌生的配置，往往会无从下手，企图找到一键就完成配置的简便方法。对于CMake,确实没有这种快捷方法，但是，只要我们理解了<strong>交叉编译就是正确配置属性值的过程。</strong> 这一实质之后，问题就会变得明朗起来。所以，上面的问题就会转化为我们熟悉的问题了——需要配置哪些属性，这些属性有哪些合适的值，这些值怎样传递给CMake等等，这就是交叉编译的全部了。正如之前提到的一样，CMake有很多预设的变量，我们需要从这些预设变量中找到一些，设置一些值，然后让CMake按照这些配置完成工作，这就是我们接下来需要做的事。下面我将以Windows交叉编译Android为例说明这个过程。</p><h2 id=前期准备 class="relative group">前期准备 <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%e5%89%8d%e6%9c%9f%e5%87%86%e5%a4%87 aria-label=锚点>#</a></span></h2><p>在Windows平台上，默认会使用Visual Studio作为C，C++的编译器，这对于编译Android的库来说可能会报错。所以在执行<code>cmake</code>命令的时候，需要使用<code> -G "Unix Makefiles"</code>来改变这一行为。但这还不够，因为CMake编译是需要指定编译器的。而Android上的C,C++编译器通常以NDK的方式提供，所以，我们需要下载好NDK。在NDK中，会同时为我们提供两种工具，一种就是编译器，另一种就是<code>android.toolchain.cmake</code>,这也是CMake命令构成的文件，里面为我们交叉编译指定了很多预设值，能大大减轻我们的工作。</p><h2 id=编写编译脚本 class="relative group">编写编译脚本 <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%e7%bc%96%e5%86%99%e7%bc%96%e8%af%91%e8%84%9a%e6%9c%ac aria-label=锚点>#</a></span></h2><p>前面说了，交叉编译就是改变CMake预设值，而改变这预设值的方式有两种，我们要结合起来使用。一种是通过NDK提供的<code>android.toolchain.cmake</code>文件。 <code>android.toolchain.cmake</code>中以设置了绝大部分的值，但是这些配置也是很灵活的，还有很大的配置空间。因此，根据用户的需求不同，我们还需要在执行CMake命令时动态传递一些值，以使CMake能正确完成工作。这就是另一种方式——选项。传递选项会以<code>-D</code>开头，后面跟着某个CMake的预定义变量由于选项很多，而且大多比较复杂，所以，最好还是通过脚本文件来记录并且修改。以下就是Windows平台上编译Android代码需要指定的几个选项，我将逐个介绍这些必要的配置。</p><ul><li><code>-DCMAKE_SYSTEM_NAME=Android</code>这个配置是告诉CMake需要生成Android平台的库，也就是执行交叉编译。</li><li><code>-DANDROID_ABI=x86</code>这个配置是告诉CMake生成库适用的架构平台。熟悉Android开发的读者应该不会陌生，支持的值会根据NDK的变化而有所变化，如早期的<code>armeabi</code>已经在 NDK r17中移除了，现在主流的还有四种<code>armeabi-v7a</code>，<code>arm64-v8a</code>，<code>x86</code>，<code>x86_64</code>.根据需要把值替换就行。</li><li><code>-DANDROID_PLATFORM=android-28</code>,这个值其实不是特别必要，因为有预设值，但是为了可控，还是需要指定一个。它是用来确定库支持的最低系统版本的。</li><li><code>-DCMAKE_TOOLCHAIN_FILE=C:/Users/Leroene/AppData/Local/Android/Sdk/ndk/21.0.6113669/build/cmake/android.toolchain.cmake</code>，这是上面提到的预设文件。需要注意的是，NDK中有多个以这个名字命名的文件，假如指定错误，可能会导致CMake出错，所以我的经验就是，更改版本号（<code>C:/Users/Leroene/AppData/Local/Android/Sdk/ndk/21.0.6113669</code>）及前面的路径，后面的保持不变。</li><li><code>-DCMAKE_MAKE_PROGRAM=C:/Users/Leroene/AppData/Local/Android/Sdk/ndk/21.0.6113669/prebuilt/windows-x86_64/bin/make</code>最后一个参数是指定<code>make</code>程序的路径，由于我们指定生成了make项目的代码，而Windows通常没有make可执行文件，所以我们需要让CMake找到make文件以完成编译。这里我的经验也是保持后面的不变，修改前面的，并保持版本一致以避免BUG。</li><li><code>-DCMAKE_BUILD_TYPE=Release</code>，指定构建类型，这应该很常见了。</li></ul><p>至此Windows交叉编译Android库的所有配置都讲解完了。让我们来看看它完整的例子</p><pre tabindex=0><code>@echo off
rd /s /q build
mkdir build
cd build
cmake -G &#34;Unix Makefiles&#34; ^
-DCMAKE_TOOLCHAIN_FILE=C:/Users/Leroene/AppData/Local/Android/Sdk/ndk/21.0.6113669/build/cmake/android.toolchain.cmake ^
-DCMAKE_MAKE_PROGRAM=C:/Users/Leroene/AppData/Local/Android/Sdk/ndk/21.0.6113669/prebuilt/windows-x86_64/bin/make ^
-DANDROID_PLATFORM=android-28 ^
-DCMAKE_SYSTEM_NAME=Android ^
-DANDROID_ABI=x86 ^
-DCMAKE_BUILD_TYPE=Release ^
../3rd
cmake --build .
</code></pre><p>从上面可以看到，这些选项后面都跟着一个<code>^</code>符号，这不是cmake的一部分，只是为了我们阅读方便，特意书写成这样的，这是在Windows平台上批处理使用的命令换行符，它的作用就是告诉命令解析器，这个命令还没有结束，接着往下面解析，该功能在Linux,MacOS上对应于<code>\</code>。现在有了这些配置之后，该怎么使用呢？其实也很简单，只需要将这些命令存储在<code>android.bat</code>文件中，在CMD中切换到当前目录，执行这个文件就能在<code>build</code>目录中找到以<code>libsum.a</code>命名的静态库文件了。下一步，我们试着用这个库文件运行在模拟器中。</p><h1 id=在android项目中使用cmake class="relative group">在Android项目中使用CMake <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%e5%9c%a8android%e9%a1%b9%e7%9b%ae%e4%b8%ad%e4%bd%bf%e7%94%a8cmake aria-label=锚点>#</a></span></h1><p>在Android平台中，也使用CMake来管理jni的项目，配合Gradle一起完成构建工作。这和普通的CMake项目最大的不同是，我们通常需要引用多个Android相关的库，如<code>log</code>,<code>android</code>等.这些库通常是由NDK提供的，我们仿照默认生成的<code>CMakeLists.txt</code>文件编写就可。</p><h2 id=目录结构 class="relative group">目录结构 <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%e7%9b%ae%e5%bd%95%e7%bb%93%e6%9e%84 aria-label=锚点>#</a></span></h2><p>接下来，为了描述方便，我们先来看一下现在的目录结构（为了避免混乱，这里只列出比较有代表性的文件）</p><pre tabindex=0><code>CMakeProject
│  android.bat
│  CMakeLists.txt
│  main.cpp
│  
├─3rd
│      CMakeLists.txt
│      lib.cpp
│      lib.h
│      
└─Android
    │  build.gradle
    │       
    ├─app
    │  │  build.gradle
    │  │                   
    │  ├─libs
    │  └─src                     
    │      ├─main
    │      │  │  AndroidManifest.xml
    │      │  │  
    │      │  ├─cpp
    │      │  │      CMakeLists.txt
    │      │  │      native-lib.cpp
    │      │  │      
    │      │  ├─java
    │      │  │  └─me
    │      │  │      └─hongui
    │      │  │          └─cmakesum
    │      │  │                  MainActivity.kt
    │      │  │                  
    │      │  ├─jniLibs
    │      │  │  └─x86
    │      │  │          libsum.a
</code></pre><p>在原来的目录根目录下新建了<code>Android</code>子目录，该目录是一个Android C++工程，所以相比其他普通Android工程，它多了个<code>cpp</code>目录，后面我们主要的修改都是发生在该目录下。</p><p>原来的根目录，为了不增加复杂度，我们只作为生成静态库的功能存在，所以和上面的示例相比，没有任何修改。</p><h2 id=构建静态库 class="relative group">构建静态库 <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%e6%9e%84%e5%bb%ba%e9%9d%99%e6%80%81%e5%ba%93 aria-label=锚点>#</a></span></h2><p>首先，我们回到根目录。使用根目录下的<code>android.bat</code>批处理生成Android上可用的静态库，也可以修改<code>android.bat</code>文件中的<code>-DANDROID_ABI</code>选项的值，生成其他架构的静态库，但这需要和<code>jniLibs</code>目录下的目录要一一对应，否则可能链接失败。如我生成的<code>libsum.a</code>文件是<code>x86</code>的架构。那么就需要在<code>jniLibs</code>目录下新建<code>x86</code>的目录下，然后再把<code>libsum.a</code>放到该目录下。至此，静态库的构建工作就算结束了。</p><h2 id=使用静态库 class="relative group">使用静态库 <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%e4%bd%bf%e7%94%a8%e9%9d%99%e6%80%81%e5%ba%93 aria-label=锚点>#</a></span></h2><p>把静态库放到合适的位置后，我们需要配置<code>app</code>目录下的<code>build.gradle</code>和<code>cpp</code>目录下的<code>CMakeLists.txt</code>文件，完成静态库的引入。</p><h3 id=配置gradle class="relative group">配置Gradle <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%e9%85%8d%e7%bd%aegradle aria-label=锚点>#</a></span></h3><p>首先说<code>build.gradle</code>，该文件主要涉及到修改ABI的问题，因为不指定的话，Gradle默认生成的ABI可能找不到对应的静态库文件来链接，从而导致链接失败。该文件主要的修改如下</p><pre tabindex=0><code>android {
    defaultConfig {
        externalNativeBuild {
                cmake {
                    cppFlags &#34;&#34;
                    abiFilters &#34;x86&#34;
                }
            }
    }
}
</code></pre><p>也就是把<code>abiFilters</code>的值指定为刚才构建的静态库相同的值。</p><h3 id=配置cmake class="relative group">配置CMake <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%e9%85%8d%e7%bd%aecmake aria-label=锚点>#</a></span></h3><p>而<code>CMakeLists.txt</code>文件就复杂一些了，它需要完成两个工作，找到静态库和静态库的头文件，链接静态库。</p><h4 id=找到头文件 class="relative group">找到头文件 <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%e6%89%be%e5%88%b0%e5%a4%b4%e6%96%87%e4%bb%b6 aria-label=锚点>#</a></span></h4><p>在文章的第二部分我们已经知道了让CMake找到头文件的<code>include_directories</code>命令，把参数设置为<code>3rd</code>目录就行了。值得注意的是，CMake是以当前的<code>CMakeLists.txt</code>文件为工作目录的，所以，要指定到<code>3rd</code>文件，我们需要一直回退目录到根项目，最终就有了<code>include_directories(../../../../../3rd)</code>这样的配置。尽量使用相对路径，可以在多人协同的情况下，不用修改配置。</p><h4 id=找到静态库 class="relative group">找到静态库 <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%e6%89%be%e5%88%b0%e9%9d%99%e6%80%81%e5%ba%93 aria-label=锚点>#</a></span></h4><p>下一步要让CMake找到我们的静态库。说到库，都是和<code>add_library</code>相关的，不同的只是参数。使用源码添加库的时候，我们需要指定库的名称和源码位置，而引用第三方库，则是需要指定库的名称和类型，外加一个<code>IMPORTED</code>的指示参数，告诉CMake这个库是导入的。所以就有了<code>add_library(addSum STATIC IMPORTED)</code>这样的配置。</p><p>但是，这里我们只告诉了CMake库的名字，库存储在哪里，还不知道，所以我们还需要另一个命令告诉CMake库的存储位置。涉及到配置参数的，通常就是<code>set_target_properties</code>命令了，可以多次调用这个命令设置多种配置。<code>set_target_properties(addSum PROPERTIES IMPORTED_LOCATION ${CMAKE_CURRENT_SOURCE_DIR}/../jniLibs/${ANDROID_ABI}/libsum.a)</code>,第一个参数和上一条的第一个参数是一一对应的，可以随便取。其实<code>add_library</code>相当于生成了一种目标产物，用第一个参数来指代这种产物，所以才让我们的<code>set_target_properties</code>找得到合适的目标设置属性。第二个参数则是配置属性的标准写法，第三个代表属性变量，第四个是属性值，配置库路径的变量就是<code>IMPORTED_LOCATION</code>，而值这里就有个坑了，Android下的CMake限定值必须是绝对路径，不能是相对路径。而这与使用CMake的初衷背道而驰，幸好，我们有几个预设值可以用，<code>CMAKE_CURRENT_SOURCE_DIR</code>就是其中之一，它代表着当前这个<code>CMakeLIsts.txt</code>文件的绝对路径，有了这个，再加上目录的回退功能，我们就能找到任何合适的目录了。至此，又出现了第二个问题，当有多个架构的静态库需要配置时，我们引入的目录是不一样的，而且会出现很多重复的配置。还好有<code>ANDROID_ABI</code>的帮助，它指代了当前编译的某个架构，随着编译的进行，这个值会被设置为合适的值，并且是和正在编译的架构是一一对应的。所以，尽管它们有点奇怪，但是这给我带来了灵活和简单。</p><h4 id=链接静态库 class="relative group">链接静态库 <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%e9%93%be%e6%8e%a5%e9%9d%99%e6%80%81%e5%ba%93 aria-label=锚点>#</a></span></h4><p>现在头文件有了，库也有了，但是C++的编译是分成两步的，目前为止，我们的工作只做完了编译的事情，还没涉及到链接的事情，当然，相比前面的配置，这就简单多了，无疑就是在<code>target_link_libraries</code>命令里添加一个参数就可，如</p><pre tabindex=0><code>target_link_libraries( 
                       native-lib
                       ${log-lib}
                       addSum
        )
</code></pre><p>只需哟注意名字和<code>add_library</code>时配置的名字一一对应就可。</p><h3 id=在源码中使用 class="relative group">在源码中使用 <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%e5%9c%a8%e6%ba%90%e7%a0%81%e4%b8%ad%e4%bd%bf%e7%94%a8 aria-label=锚点>#</a></span></h3><p>经过漫长的等待，现在我们终于能在<code>native-lib.cpp</code>文件中引入<code>addsum</code>的头文件，并且使用里面的函数完成工作了。我打算让函数返回一个包含加法运算结果的字符串。最终实现如下</p><pre tabindex=0><code>#include &lt;jni.h&gt;
#include &lt;string&gt;
#include &lt;lib.h&gt;

extern &#34;C&#34; JNIEXPORT jstring JNICALL
Java_me_hongui_cmakesum_MainActivity_stringFromJNI(
        JNIEnv* env,
        jobject /* this */) {
    std::string hello = std::to_string(sum(1,1));
    return env-&gt;NewStringUTF(hello.c_str());
}
</code></pre><p>至此，点击工具栏上的<code>run</code>按钮，我们终于可以在Android的模拟器上看到我们的静态库工作的成果啦。</p><h2 id=扩展 class="relative group">扩展 <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%e6%89%a9%e5%b1%95 aria-label=锚点>#</a></span></h2><p>其实除了引用静态库的方式之外，我们还可以直接通过配置<code>CMakeLists.txt</code>文件来引用源码，这样可以随时随地对源码进行定制，但是也降低了编译速度，而且可能会增加<code>CMakeLists.txt</code>的复杂度。所以我还是推荐直接使用静态库的方式。</p><h1 id=总结 class="relative group">总结 <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%e6%80%bb%e7%bb%93 aria-label=锚点>#</a></span></h1><p>CMake其实还有很多很多命令，我们这里涉及到的只是很少的一部分。但是，我觉得理解CMake有这些内容差不多就可以了，后续有需要再针对性学习就行了。学习一门技术，切忌不能贪多，贪细。先要抓住主干，理清脉络，后面的细节就是水到渠成的事。对于CMake，我觉得就是以C++代码编译为二进制的过程为主干就够了。源码从哪里来，头文件在那里，库文件在哪里，怎么组织编译，参与链接的库有哪些，生成什么产物，还有一些完成这些工作的通用操作，复制文件啊，目录信息啊等，这些操作的集合就构成了CMake的主体。另外，CMake其实只是一种构建工具，它本身不是编译器和链接器，有些问题可能不仅仅会涉及到cmake，还可能会涉及到编译器和连接器。当然，这些都是后面深入了解之后才可能碰到的问题了。</p></div></section><footer class="pt-8 max-w-prose print:hidden"><div class=flex><div class=place-self-center><div class="text-[0.6rem] uppercase leading-3 text-neutral-500 dark:text-neutral-400">作者</div><div class="font-semibold leading-6 text-neutral-800 dark:text-neutral-300">低头沉思</div><div class="text-2xl sm:text-lg"><div class="flex flex-wrap text-neutral-400 dark:text-neutral-500"><a class="px-1 transition-transform hover:scale-125 hover:text-primary-700 dark:hover:text-primary-400" style=will-change:transform href=mailto:honguilee@163.com target=_blank aria-label=Email rel="me noopener noreferrer"><span class="relative inline-block align-text-bottom px-1 icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentcolor" d="M207.8 20.73c-93.45 18.32-168.7 93.66-187 187.1-27.64 140.9 68.65 266.2 199.1 285.1 19.01 2.888 36.17-12.26 36.17-31.49l1e-4-.6631c0-15.74-11.44-28.88-26.84-31.24-84.35-12.98-149.2-86.13-149.2-174.2.0-102.9 88.61-185.5 193.4-175.4 91.54 8.869 158.6 91.25 158.6 183.2v16.16c0 22.09-17.94 40.05-40 40.05s-40.01-17.96-40.01-40.05v-120.1c0-8.847-7.161-16.02-16.01-16.02l-31.98.0036c-7.299.0-13.2 4.992-15.12 11.68-24.85-12.15-54.24-16.38-86.06-5.106-38.75 13.73-68.12 48.91-73.72 89.64-9.483 69.01 43.81 128 110.9 128 26.44.0 50.43-9.544 69.59-24.88 24 31.3 65.23 48.69 109.4 37.49C465.2 369.3 496 324.1 495.1 277.2V256.3c0-149.2-133.9-265.632-287.3-235.57zM239.1 304.3c-26.47.0-48-21.56-48-48.05s21.53-48.05 48-48.05 48 21.56 48 48.05-20.6 48.05-48 48.05z"/></svg></span></a><a class="px-1 transition-transform hover:scale-125 hover:text-primary-700 dark:hover:text-primary-400" style=will-change:transform href=https://github.com/hongui target=_blank aria-label=Github rel="me noopener noreferrer"><span class="relative inline-block align-text-bottom px-1 icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><path fill="currentcolor" d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6.0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6.0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3.0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1.0-6.2-.3-40.4-.3-61.4.0.0-70 15-84.7-29.8.0.0-11.4-29.1-27.8-36.6.0.0-22.9-15.7 1.6-15.4.0.0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5.0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9.0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4.0 33.7-.3 75.4-.3 83.6.0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6.0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9.0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg></span></a></div></div></div></div><div class=pt-8><hr class="border-dotted border-neutral-300 dark:border-neutral-600"><div class="flex justify-between pt-3"><span><a class="group flex" href=/post/%20Kotlin%E5%8D%8F%E7%A8%8B-%E4%BB%8E%E4%B8%80%E5%88%B0%E5%A4%9A.html><span class="me-2 text-neutral-700 transition-transform group-hover:-translate-x-[2px] group-hover:text-primary-600 dark:text-neutral dark:group-hover:text-primary-400"><span class="ltr:inline rtl:hidden">&larr;</span><span class="ltr:hidden rtl:inline">&rarr;</span></span>
<span class="flex flex-col"><span class="mt-[0.1rem] leading-6 group-hover:underline group-hover:decoration-primary-500">Kotlin协程-从一到多</span>
<span class="mt-[0.1rem] text-xs text-neutral-500 dark:text-neutral-400"><time datetime="2021-03-30 19:10:30 +0800 +0800">30 March 2021</time>
</span></span></a></span><span><a class="group flex text-right" href=/post/Android-JNI%E5%BC%80%E5%8F%91%E6%A6%82%E8%AE%BA.html><span class="flex flex-col"><span class="mt-[0.1rem] leading-6 group-hover:underline group-hover:decoration-primary-500">Android-JNI开发概论</span>
<span class="mt-[0.1rem] text-xs text-neutral-500 dark:text-neutral-400"><time datetime="2021-09-12 21:34:45 +0800 +0800">12 September 2021</time>
</span></span><span class="ms-2 text-neutral-700 transition-transform group-hover:-translate-x-[2px] group-hover:text-primary-600 dark:text-neutral dark:group-hover:text-primary-400"><span class="ltr:inline rtl:hidden">&rarr;</span><span class="ltr:hidden rtl:inline">&larr;</span></span></a></span></div></div></footer></article><div class="pointer-events-none absolute bottom-0 end-0 top-[100vh] w-12"><a href=#the-top class="pointer-events-auto sticky top-[calc(100vh-5.5rem)] flex h-12 w-12 items-center justify-center rounded-full bg-neutral/50 text-xl text-neutral-700 backdrop-blur hover:text-primary-600 dark:bg-neutral-800/50 dark:text-neutral dark:hover:text-primary-400" aria-label=回到顶部 title=回到顶部>&uarr;</a></div></main><footer class="py-10 print:hidden"><div class="flex items-center justify-between"><div><p class="text-sm text-neutral-500 dark:text-neutral-400">&copy;
2023
低头沉思</p><p class="text-xs text-neutral-500 dark:text-neutral-400">由 <a class="hover:underline hover:decoration-primary-400 hover:text-primary-500" href=https://gohugo.io/ target=_blank rel="noopener noreferrer">Hugo</a> & <a class="hover:underline hover:decoration-primary-400 hover:text-primary-500" href=https://github.com/jpanther/congo target=_blank rel="noopener noreferrer">Congo</a> 强力驱动</p></div><div class="flex flex-row items-center"></div></div></footer></div></body></html>