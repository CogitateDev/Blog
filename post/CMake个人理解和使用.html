<!doctype html><html lang=zh-cn dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="CMake个人理解和使用"><title>CMake个人理解和使用</title><link rel=canonical href=https://hongui.github.io/post/CMake%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3%E5%92%8C%E4%BD%BF%E7%94%A8.html><link rel=stylesheet href=/scss/style.min.18145888f21de6cb02d8cb0891be8240096206785da14eda35f6c23c239b966a.css><meta property="og:title" content="CMake个人理解和使用"><meta property="og:description" content="CMake个人理解和使用"><meta property="og:url" content="https://hongui.github.io/post/CMake%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3%E5%92%8C%E4%BD%BF%E7%94%A8.html"><meta property="og:site_name" content="低头沉思"><meta property="og:type" content="article"><meta property="article:section" content="Posts"><meta property="article:tag" content="Android"><meta property="article:tag" content="JNI"><meta property="article:tag" content="C/C++"><meta property="article:tag" content="CMake"><meta property="article:published_time" content="2021-08-09T19:21:49+08:00"><meta property="article:modified_time" content="2021-08-09T19:21:49+08:00"><meta name=twitter:title content="CMake个人理解和使用"><meta name=twitter:description content="CMake个人理解和使用"><link rel="shortcut icon" href=#ZgotmplZ></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column compact"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label=切换菜单>
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/><img src=/img/avatar_huda2458f72ce188392d75c5d51cd8e24e_373_300x0_resize_box_3.png width=300 height=300 class=site-logo loading=lazy alt=Avatar></a></figure><div class=site-meta><h1 class=site-name><a href=/>低头沉思</a></h1><h2 class=site-description></h2></div></header><ol class=menu id=main-menu><li><a href=/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg><span>首页</span></a></li><li><a href=/about.html><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="7" r="4"/><path d="M6 21v-2a4 4 0 014-4h4a4 4 0 014 4v2"/></svg><span>关于</span></a></li><li class=current><a href=/posts/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg><span>归档</span></a></li><li><a href=/404.html><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-infinity" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M9.828 9.172a4 4 0 100 5.656A10 10 0 0012 12a10 10 0 012.172-2.828 4 4 0 110 5.656A10 10 0 0112 12 10 10 0 009.828 9.172"/></svg><span>公益 404</span></a></li><div class=menu-bottom-section><li id=dark-mode-toggle><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg><span>暗色模式</span></li></div></ol></aside><main class="main full-width"><article class=main-article><header class=article-header><div class=article-details><header class=article-category><a href=/categories/c/c++/>C/C++</a></header><div class=article-title-wrapper><h2 class=article-title><a href=/post/CMake%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3%E5%92%8C%E4%BD%BF%E7%94%A8.html>CMake个人理解和使用</a></h2><h3 class=article-subtitle>CMake个人理解和使用</h3></div><footer class=article-time><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg><time class=article-time--published>2021/08/09 07:21</time></div><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg><time class=article-time--reading>阅读时长: 3 分钟</time></div></footer></div></header><section class=article-content><h1 id=前言>前言</h1><p>CMake是一个构建工具，通过它可以很容易创建跨平台的项目。通常使用它构建项目要分两步，通过源代码生成工程文件，通过工程文件构建目标产物（可能是动态库，静态库，也可能是可执行程序）。使用CMake的一个主要优势是在多平台或者多人协作的项目中，开发人员可以根据自己的喜好来使选择IDE，不用受其他人工程配置的影响，它有点像跨平台的IDE，通过它配置好相关设置之后，可以在多个平台无缝衔接，提高开发效率。</p><h1 id=最简单的cmake工程>最简单的CMake工程</h1><h2 id=项目搭建>项目搭建</h2><p>一个用CMake来管理的项目，其项目根目录通常会包含一个<code>CMakeLists.txt</code>的文件，当然子目录可能也有，这种情况我们稍后再说。我们先从最简单的项目开始。以下就是一个最简单的工程示例：</p><pre tabindex=0><code>CMakeProject
|    CMakeLists.txt
|    main.cpp
</code></pre><p>这就是完整的可以跑起来的最小项目了。按照顺序，我们来看看文件里的内容</p><p><code>CMakeLists.txt</code></p><pre tabindex=0><code># 设置版本号
cmake_minimum_required(VERSION 3.10)
# 设置项目名
project(CMakeProject)
# 设置产物和源码的关联
add_executable(${CMAKE_PROJECT_NAME} main.cpp)
</code></pre><p>说明：</p><ul><li>CMake中命令不区分大小写</li><li>以<code>#</code>开始的是备注</li><li>引用变量语法<code>${变量名}</code></li></ul><p>所以文档中真正的有效内容就三行，</p><ol><li><code>cmake_minimum_required(VERSION 3.10)</code>设置了CMake支持的最低版本，<code>VERSION</code>是参数名，后面是版本号，可以根据自己的需要修改。 <strong>注意参数名和参数是以空白符分隔的，不是逗号，</strong> 不然会报错。</li><li><code>project(CMakeProject)</code>CMake中字符串可以带引号或者不带，效果是一致的，这一行就是配置了项目名，如生成的Visual Studio的工程名就是依据这个名字来的。</li><li><code>add_executable(${CMAKE_PROJECT_NAME} main.cpp)</code>
才是真正管理源码和目标产物的地方，这里我们使用了引用变量的写法，而文件中没有定义这个变量，说明这个变量存在于CMake中，在CMake还有很多预定义的变量，我们可以直接通过这种方式引用，上面的写法是将项目名设置为产物的名字，当然也可以直接填字符串，取个另外的名字都是可以的。后面的<code>main.cpp</code>则是用来生成产物的源码路径，这就是CMake最灵活的地方。<strong>源码路径可以是多样的，查找出来的，直接写的，相对路径，绝对路径都可以。</strong> 多个源码的话就用空白符分隔，依次写就行了。
在上面的配置文件中，我们配置了它的源文件为<code>main.cpp</code>，我们想通过它来生成一个可执行的程序，内容也很简单:</li></ol><pre tabindex=0><code>#include &lt;iostream&gt;
int main()
{
	std::cout&lt;&lt;&#34;hello CMake&#34;&lt;&lt;std::endl;
	return 0;
}
</code></pre><h2 id=项目编译与执行>项目编译与执行</h2><p>准备工作已经做完，接下来我们就要使用CMake生成可执行文件了。</p><p>第一步当然是要安装CMake啦，这是下载地址<a class=link href=https://cmake.org/download/ target=_blank rel=noopener>!Download</a>，根据自己的平台选择下载即可，安装完成之后需要把它添加到环境变量中，便于我们在任何地方都能方便使用。
安装了CMake以后，打开命令行工具，进入到刚才创建的项目根目录，也就是进入到存着<code>CMakeLists.txt</code>和<code>main.cpp</code>的目录，下一步准备生成项目。</p><p>通常为了不影响和污染当前的工作环境，我们会选择新建一个目录来存放生成的工程文件，以下我主要以Windows平台为主要平台讲解，其他平台基本一致。</p><pre tabindex=0><code>mkdir build                 #创建文件夹，存储工程文件；
cd build                    #切换cmake工作目录;
cmake ..                    #生成项目文件；
</code></pre><p>这三步执行完后，我们就可以在build文件夹下看到里面已经生成了一个Visual Studio的工程，我们可以直接用Visual Studio打开这个工程，按照我们的习惯执行编译和调试。当然，假如想最快地生成可执行文件，我还是推荐使用CMake。</p><p>使用CMake执行编译，只需要在上一步的基础上（也就是已经成功执行了上面的三个步骤）再执行一个命令<code>cmake --build .</code>就可以了。这里切记不能少第三个英文句号，它代表在当前的工作目录中执行CMake的编译。
假如上面的四步都一切顺利的话，那么，我们就可以在<code>build/debug</code>目录下看到以<code>add_executable</code>的第一个参数命名的可执行文件（这里就是<code>CMakeProject.exe</code>），双击或者把它拖到命令行就可以执行它了。</p><h2 id=项目扩展>项目扩展</h2><p>在前面的例子中，生成工程文件，我们使用了两个命令，其实，这里可以直接用一个命令就可以完成——<code>cmake build -S . -B build</code>。这个命令的意思是以当前路径为工作路径，以<code>build</code>目录为生成目录，生成工程文件，也就是不需要我们手动创建<code>build</code>文件夹了。其中 <code>-S</code>参数配置的是源路径，<code>-B</code>配置的是生成路径。</p><p>另外，由于CMake没有清理方法，所以每次修改CMake的配置（也就是新增或者删除<code>CMakeLists.txt</code>中的代码），需要重新生成工程文件的时候，需要我们手动清理生成目录，保证它是空目录，假如不这样做，那么项目可能生成失败或者新配置不起作用。假如只是修改了源代码的内容的话，则不需要重新生成，直接进行第四步即可。
虽然上面的操作已经足够简单，但是考虑到长期的修改和验证需要，还是太繁琐枯燥了，尤其是要反复切换工作目录，还是比较烦人的。所以我推荐使用批处理来完成这些操作。结合清理生成目录和切换工作目录这几个步骤，最终的批处理文件可能是这样的</p><pre tabindex=0><code>
@echo off 
rd /s /q build
mkdir build
cd build
cmake ..
cmake --build .
cd debug
CMakeProject
cd ../..
</code></pre><p>按顺序依次解释一下:</p><p>第一行是关闭了命令行的回显功能，因为我们不希望它的回显干扰到CMake的信息输出，以造成不必要的混乱，而且通常我们也只关心它最后有没有完成工作而不是看它在干什么。</p><p>第二行则是用了Windows上的删除文件夹命令（Linux，MacOS上对应的是rmdir),/s是配置它清除文件夹中所有的内容，包括子文件夹，不配置命令就会执行失败，/q则是让命令直接执行删除，不需要我们手动确认，这个参数很重要，不然我们需要一个一个地确认删除，完全失去了自动化的作用。然后后面的四句就是我们上面讲的内容了，不再赘述。</p><p>一直来到倒数第二句，这里我直接写了可执行文件的名字（需要替换为你自己的名字），为的就是直接在编译完成之后运行可执行文件，这对有些会生成文件的应用来说很有用。</p><p>执行结束后，再将目录切回到项目根目录，这就是最后一行的作用，由于我们再编译的时候已经切换了目录到生成目录了，而编译的可执行文件又是在生成目录的子目录中，所以回到根目录，我们需要回退两次，这是保证下次我们能胜利执行批处理的关键。</p><p>把上面的内容保存为bat结尾的文件，然后下次就可以直接在命令行输入bat文件名来一次性完成生成和构建了，简直爽歪歪。
以上就是CMake项目我们所需要知道的了。当然实际项目远比这个复杂得多，接下来我将以我踩过的坑为基础，逐一增加项目的复杂度，慢慢形成对CMake的工作流程的理解。</p><h1 id=多源码项目>多源码项目</h1><h2 id=个人感悟>个人感悟</h2><p>在开始之前，我先讲一讲我对CMake项目或者说<code>CMakeLists.txt</code>文件的理解。<strong>我们不能单独的以某一个配置为理解对象，我们需要对这些命令进行分类甚至提炼出它的核心工作模式。我是以c++文件的编译链接为线索梳理的。</strong> 我们都知道一个c++源文件要想生成可执行代码，需要分三步</p><ul><li>预处理器处理，拷贝头文件的内容到源文件，宏替换等；</li><li>编译器将源文件编译为.o的对象文件；</li><li>链接器以.o文件和其他库为输入，链接生成可执行文件。</li></ul><p>我们按照这个思路来理解CMake就简单多了。假如CMake报错，我们就可以根据报错信息定位到是哪个阶段出了问题，进而快速找到解决办法。另外我们也可以依据这些信息对CMake的配置分类，我自己理解的粗略分类如下:</p><ul><li>配置CMake基本信息的：<code>cmake_minimum_required</code>；</li><li>源码管理的：<code>file</code>,<code>aux_source_directory</code>；</li><li>库管理的：<code>find_libraray</code>；</li><li>头文件管理的：<code>include_directories</code>；</li><li>链接库管理的：<code>link_directories</code>；</li><li>子项目管理的：<code>add_subdirectory</code>；</li><li>生成物管理的：<code>add_executable</code>,<code>add_library</code>；</li></ul><p>当然，这些只是很少的一部分，但是对我们理解和搜索问题的解决思路提供了较好的方向。</p><h2 id=cmake管理子目录>CMake管理子目录</h2><p>很多时候，我们会引入第三方包来减少重复编码的工作，通常这种代码我们需要放在其他目录中，于是我新建了一个子目录，用于模拟存放的第三方代码。对于这种情况，我们有两种包含形式——子模块和子目录。</p><p>先说简单一些的子目录吧。子目录的意思就是将第三方代码看作我们代码的一部分，一起合并编译，这种方式可以使我们的项目看起来更紧凑。如以下的项目结构</p><pre tabindex=0><code>CMakeProject

|   auto.bat
|   CMakeLists.txt              //修改
|   main.cpp                    //修改
|   

\---3rd                         //新增
        lib.h       
</code></pre><p>我新建了一个子文件夹，用来模拟第三方代码，现在我们把它引入到<code>main.cpp</code>中，编译，就会发现报错了，信息为<code>fatal error C1083: 无法打开包括文件: “lib.h”: No such file or directory，</code>这很正常。结合上面我举的例子。这个报错信息是和头文件相关的，查看CMake文档，我发现了CMake有个<code>include_directories</code>的指令，它的意思就是添加文件头的目录，以便让CMake找到头文件。于是，我在<code>CMakeLists.txt</code>文件中添加了<code>include_directories(3rd)</code>，然后再次执行编译，项目又正确跑起来了。来看看这时的<code>main.cpp</code></p><pre tabindex=0><code>#include &lt;iostream&gt;
#include &lt;lib.h&gt;

int main()
{
    int a=1,b=1;
	std::cout&lt;&lt;&#34;hello CMake&#34;&lt;&lt;std::endl;
    std::cout&lt;&lt;&#34;a + b = &#34;&lt;&lt;sum(a,b)&lt;&lt;std::endl;
	return 0;
}
</code></pre><p>注意：这里的<code>include_directories</code>和cpp中的<code>include</code>是一一对应的，就是说，假如<code>include_directories</code>里面配置的目录是.（当前目录，CMake没有把当前目录添加到<code>include</code>路径），则对应cpp的<code>include</code>要写成<code>3rd/lib.h</code>这种形式，简单来说，就是<code>include_directories</code>被设置为了<code>include</code>的根目录。
另一种情况就是子模块。</p><h2 id=cmake管理子模块>CMake管理子模块</h2><p>子模块的意思是，模块可以单独编译，单独提供给其他库使用，而不是和主项目共生的，适用于和主模块耦合不大的情况。为了满足这个条件，我们修改刚才的目录结构为下面这种</p><pre tabindex=0><code>CMakeProject

|   auto.bat
|   CMakeLists.txt                   //修改
|   main.cpp                    

|   
\---3rd
        CMakeLists.txt               //新增
        lib.cpp                      //新增
        lib.h                        //修改
</code></pre><p>我把<code>lib.h</code>中的函数改为声明，实现放在了<code>lib.cpp</code>文件中。最大的变化是新建了<code>3rd</code>目录下的<code>CMakeLists.txt</code>文件，用它统一管理<code>3rd</code>目录下的所有源文件（假如文件很多的话，这里是模拟）,使用了<code>add_library</code>把<code>3rd</code>目录下打包成了子模块。</p><pre tabindex=0><code>project(sum)
add_library(${PROJECT_NAME} lib.cpp)
</code></pre><p><code>add_library</code>在名字和源代码中间还可以指定构建类型，默认是<code>STATIC</code>，也就是静态库，假如想构建动态库需要手动指定为<code>SHARED</code>（<code>add_library(${PROJECT_NAME} SHARED lib.cpp)</code>）。</p><p>重要的改变来自主目录下的<code>CMakeLists.txt</code></p><pre tabindex=0><code># 设置版本号
cmake_minimum_required(VERSION 3.10)
# 设置项目名
project(CMakeProject)
# 指定3rd为include的查找目录
include_directories(3rd)
# 子模块
add_subdirectory(3rd)
# 设置产物和源码的关联
add_executable(${PROJECT_NAME} main.cpp)
target_link_libraries(${PROJECT_NAME} sum)
</code></pre><p>新增了<code>add_subdirectory</code>，它的作用是将指定目录下的源码作为一个模块编译，前提是这个目录下要有<code>CMakeLists.txt</code>文件。另一个改变就是<code>target_link_libraries</code>的添加，它的作用是将子模块链接进主模块，假如没有这一句，在链接的时候会报错<code>error LNK2019: 无法解析的外部符号</code>。模块的名字需要和子模块中<code>add_library</code>中第一个参数保持一致。</p><h1 id=交叉编译>交叉编译</h1><p>在前面的示例中，项目的复杂度表现在多目录，多源码，而在使用CMake进行交叉编译的过程中，项目的主要复杂度表现在环境配置。尽管CMake可以几乎不修改<code>CMakeLists.txt</code>的情况下，实现交叉编译，但是对于新手，面对陌生的配置，往往会无从下手，企图找到一键就完成配置的简便方法。对于CMake,确实没有这种快捷方法，但是，只要我们理解了<strong>交叉编译就是正确配置属性值的过程。</strong> 这一实质之后，问题就会变得明朗起来。所以，上面的问题就会转化为我们熟悉的问题了——需要配置哪些属性，这些属性有哪些合适的值，这些值怎样传递给CMake等等，这就是交叉编译的全部了。正如之前提到的一样，CMake有很多预设的变量，我们需要从这些预设变量中找到一些，设置一些值，然后让CMake按照这些配置完成工作，这就是我们接下来需要做的事。下面我将以Windows交叉编译Android为例说明这个过程。</p><h2 id=前期准备>前期准备</h2><p>在Windows平台上，默认会使用Visual Studio作为C，C++的编译器，这对于编译Android的库来说可能会报错。所以在执行<code>cmake</code>命令的时候，需要使用<code> -G "Unix Makefiles"</code>来改变这一行为。但这还不够，因为CMake编译是需要指定编译器的。而Android上的C,C++编译器通常以NDK的方式提供，所以，我们需要下载好NDK。在NDK中，会同时为我们提供两种工具，一种就是编译器，另一种就是<code>android.toolchain.cmake</code>,这也是CMake命令构成的文件，里面为我们交叉编译指定了很多预设值，能大大减轻我们的工作。</p><h2 id=编写编译脚本>编写编译脚本</h2><p>前面说了，交叉编译就是改变CMake预设值，而改变这预设值的方式有两种，我们要结合起来使用。一种是通过NDK提供的<code>android.toolchain.cmake</code>文件。 <code>android.toolchain.cmake</code>中以设置了绝大部分的值，但是这些配置也是很灵活的，还有很大的配置空间。因此，根据用户的需求不同，我们还需要在执行CMake命令时动态传递一些值，以使CMake能正确完成工作。这就是另一种方式——选项。传递选项会以<code>-D</code>开头，后面跟着某个CMake的预定义变量由于选项很多，而且大多比较复杂，所以，最好还是通过脚本文件来记录并且修改。以下就是Windows平台上编译Android代码需要指定的几个选项，我将逐个介绍这些必要的配置。</p><ul><li><code>-DCMAKE_SYSTEM_NAME=Android</code>这个配置是告诉CMake需要生成Android平台的库，也就是执行交叉编译。</li><li><code>-DANDROID_ABI=x86</code>这个配置是告诉CMake生成库适用的架构平台。熟悉Android开发的读者应该不会陌生，支持的值会根据NDK的变化而有所变化，如早期的<code>armeabi</code>已经在 NDK r17中移除了，现在主流的还有四种<code>armeabi-v7a</code>，<code>arm64-v8a</code>，<code>x86</code>，<code>x86_64</code>.根据需要把值替换就行。</li><li><code>-DANDROID_PLATFORM=android-28</code>,这个值其实不是特别必要，因为有预设值，但是为了可控，还是需要指定一个。它是用来确定库支持的最低系统版本的。</li><li><code>-DCMAKE_TOOLCHAIN_FILE=C:/Users/Leroene/AppData/Local/Android/Sdk/ndk/21.0.6113669/build/cmake/android.toolchain.cmake</code>，这是上面提到的预设文件。需要注意的是，NDK中有多个以这个名字命名的文件，假如指定错误，可能会导致CMake出错，所以我的经验就是，更改版本号（<code>C:/Users/Leroene/AppData/Local/Android/Sdk/ndk/21.0.6113669</code>）及前面的路径，后面的保持不变。</li><li><code>-DCMAKE_MAKE_PROGRAM=C:/Users/Leroene/AppData/Local/Android/Sdk/ndk/21.0.6113669/prebuilt/windows-x86_64/bin/make</code>最后一个参数是指定<code>make</code>程序的路径，由于我们指定生成了make项目的代码，而Windows通常没有make可执行文件，所以我们需要让CMake找到make文件以完成编译。这里我的经验也是保持后面的不变，修改前面的，并保持版本一致以避免BUG。</li><li><code>-DCMAKE_BUILD_TYPE=Release</code>，指定构建类型，这应该很常见了。</li></ul><p>至此Windows交叉编译Android库的所有配置都讲解完了。让我们来看看它完整的例子</p><pre tabindex=0><code>@echo off
rd /s /q build
mkdir build
cd build
cmake -G &#34;Unix Makefiles&#34; ^
-DCMAKE_TOOLCHAIN_FILE=C:/Users/Leroene/AppData/Local/Android/Sdk/ndk/21.0.6113669/build/cmake/android.toolchain.cmake ^
-DCMAKE_MAKE_PROGRAM=C:/Users/Leroene/AppData/Local/Android/Sdk/ndk/21.0.6113669/prebuilt/windows-x86_64/bin/make ^
-DANDROID_PLATFORM=android-28 ^
-DCMAKE_SYSTEM_NAME=Android ^
-DANDROID_ABI=x86 ^
-DCMAKE_BUILD_TYPE=Release ^
../3rd
cmake --build .
</code></pre><p>从上面可以看到，这些选项后面都跟着一个<code>^</code>符号，这不是cmake的一部分，只是为了我们阅读方便，特意书写成这样的，这是在Windows平台上批处理使用的命令换行符，它的作用就是告诉命令解析器，这个命令还没有结束，接着往下面解析，该功能在Linux,MacOS上对应于<code>\</code>。现在有了这些配置之后，该怎么使用呢？其实也很简单，只需要将这些命令存储在<code>android.bat</code>文件中，在CMD中切换到当前目录，执行这个文件就能在<code>build</code>目录中找到以<code>libsum.a</code>命名的静态库文件了。下一步，我们试着用这个库文件运行在模拟器中。</p><h1 id=在android项目中使用cmake>在Android项目中使用CMake</h1><p>在Android平台中，也使用CMake来管理jni的项目，配合Gradle一起完成构建工作。这和普通的CMake项目最大的不同是，我们通常需要引用多个Android相关的库，如<code>log</code>,<code>android</code>等.这些库通常是由NDK提供的，我们仿照默认生成的<code>CMakeLists.txt</code>文件编写就可。</p><h2 id=目录结构>目录结构</h2><p>接下来，为了描述方便，我们先来看一下现在的目录结构（为了避免混乱，这里只列出比较有代表性的文件）</p><pre tabindex=0><code>CMakeProject
│  android.bat
│  CMakeLists.txt
│  main.cpp
│  
├─3rd
│      CMakeLists.txt
│      lib.cpp
│      lib.h
│      
└─Android
    │  build.gradle
    │       
    ├─app
    │  │  build.gradle
    │  │                   
    │  ├─libs
    │  └─src                     
    │      ├─main
    │      │  │  AndroidManifest.xml
    │      │  │  
    │      │  ├─cpp
    │      │  │      CMakeLists.txt
    │      │  │      native-lib.cpp
    │      │  │      
    │      │  ├─java
    │      │  │  └─me
    │      │  │      └─hongui
    │      │  │          └─cmakesum
    │      │  │                  MainActivity.kt
    │      │  │                  
    │      │  ├─jniLibs
    │      │  │  └─x86
    │      │  │          libsum.a
</code></pre><p>在原来的目录根目录下新建了<code>Android</code>子目录，该目录是一个Android C++工程，所以相比其他普通Android工程，它多了个<code>cpp</code>目录，后面我们主要的修改都是发生在该目录下。</p><p>原来的根目录，为了不增加复杂度，我们只作为生成静态库的功能存在，所以和上面的示例相比，没有任何修改。</p><h2 id=构建静态库>构建静态库</h2><p>首先，我们回到根目录。使用根目录下的<code>android.bat</code>批处理生成Android上可用的静态库，也可以修改<code>android.bat</code>文件中的<code>-DANDROID_ABI</code>选项的值，生成其他架构的静态库，但这需要和<code>jniLibs</code>目录下的目录要一一对应，否则可能链接失败。如我生成的<code>libsum.a</code>文件是<code>x86</code>的架构。那么就需要在<code>jniLibs</code>目录下新建<code>x86</code>的目录下，然后再把<code>libsum.a</code>放到该目录下。至此，静态库的构建工作就算结束了。</p><h2 id=使用静态库>使用静态库</h2><p>把静态库放到合适的位置后，我们需要配置<code>app</code>目录下的<code>build.gradle</code>和<code>cpp</code>目录下的<code>CMakeLists.txt</code>文件，完成静态库的引入。</p><h3 id=配置gradle>配置Gradle</h3><p>首先说<code>build.gradle</code>，该文件主要涉及到修改ABI的问题，因为不指定的话，Gradle默认生成的ABI可能找不到对应的静态库文件来链接，从而导致链接失败。该文件主要的修改如下</p><pre tabindex=0><code>android {
    defaultConfig {
        externalNativeBuild {
                cmake {
                    cppFlags &#34;&#34;
                    abiFilters &#34;x86&#34;
                }
            }
    }
}
</code></pre><p>也就是把<code>abiFilters</code>的值指定为刚才构建的静态库相同的值。</p><h3 id=配置cmake>配置CMake</h3><p>而<code>CMakeLists.txt</code>文件就复杂一些了，它需要完成两个工作，找到静态库和静态库的头文件，链接静态库。</p><h4 id=找到头文件>找到头文件</h4><p>在文章的第二部分我们已经知道了让CMake找到头文件的<code>include_directories</code>命令，把参数设置为<code>3rd</code>目录就行了。值得注意的是，CMake是以当前的<code>CMakeLists.txt</code>文件为工作目录的，所以，要指定到<code>3rd</code>文件，我们需要一直回退目录到根项目，最终就有了<code>include_directories(../../../../../3rd)</code>这样的配置。尽量使用相对路径，可以在多人协同的情况下，不用修改配置。</p><h4 id=找到静态库>找到静态库</h4><p>下一步要让CMake找到我们的静态库。说到库，都是和<code>add_library</code>相关的，不同的只是参数。使用源码添加库的时候，我们需要指定库的名称和源码位置，而引用第三方库，则是需要指定库的名称和类型，外加一个<code>IMPORTED</code>的指示参数，告诉CMake这个库是导入的。所以就有了<code>add_library(addSum STATIC IMPORTED)</code>这样的配置。</p><p>但是，这里我们只告诉了CMake库的名字，库存储在哪里，还不知道，所以我们还需要另一个命令告诉CMake库的存储位置。涉及到配置参数的，通常就是<code>set_target_properties</code>命令了，可以多次调用这个命令设置多种配置。<code>set_target_properties(addSum PROPERTIES IMPORTED_LOCATION ${CMAKE_CURRENT_SOURCE_DIR}/../jniLibs/${ANDROID_ABI}/libsum.a)</code>,第一个参数和上一条的第一个参数是一一对应的，可以随便取。其实<code>add_library</code>相当于生成了一种目标产物，用第一个参数来指代这种产物，所以才让我们的<code>set_target_properties</code>找得到合适的目标设置属性。第二个参数则是配置属性的标准写法，第三个代表属性变量，第四个是属性值，配置库路径的变量就是<code>IMPORTED_LOCATION</code>，而值这里就有个坑了，Android下的CMake限定值必须是绝对路径，不能是相对路径。而这与使用CMake的初衷背道而驰，幸好，我们有几个预设值可以用，<code>CMAKE_CURRENT_SOURCE_DIR</code>就是其中之一，它代表着当前这个<code>CMakeLIsts.txt</code>文件的绝对路径，有了这个，再加上目录的回退功能，我们就能找到任何合适的目录了。至此，又出现了第二个问题，当有多个架构的静态库需要配置时，我们引入的目录是不一样的，而且会出现很多重复的配置。还好有<code>ANDROID_ABI</code>的帮助，它指代了当前编译的某个架构，随着编译的进行，这个值会被设置为合适的值，并且是和正在编译的架构是一一对应的。所以，尽管它们有点奇怪，但是这给我带来了灵活和简单。</p><h4 id=链接静态库>链接静态库</h4><p>现在头文件有了，库也有了，但是C++的编译是分成两步的，目前为止，我们的工作只做完了编译的事情，还没涉及到链接的事情，当然，相比前面的配置，这就简单多了，无疑就是在<code>target_link_libraries</code>命令里添加一个参数就可，如</p><pre tabindex=0><code>target_link_libraries( 
                       native-lib
                       ${log-lib}
                       addSum
        )
</code></pre><p>只需哟注意名字和<code>add_library</code>时配置的名字一一对应就可。</p><h3 id=在源码中使用>在源码中使用</h3><p>经过漫长的等待，现在我们终于能在<code>native-lib.cpp</code>文件中引入<code>addsum</code>的头文件，并且使用里面的函数完成工作了。我打算让函数返回一个包含加法运算结果的字符串。最终实现如下</p><pre tabindex=0><code>#include &lt;jni.h&gt;
#include &lt;string&gt;
#include &lt;lib.h&gt;

extern &#34;C&#34; JNIEXPORT jstring JNICALL
Java_me_hongui_cmakesum_MainActivity_stringFromJNI(
        JNIEnv* env,
        jobject /* this */) {
    std::string hello = std::to_string(sum(1,1));
    return env-&gt;NewStringUTF(hello.c_str());
}
</code></pre><p>至此，点击工具栏上的<code>run</code>按钮，我们终于可以在Android的模拟器上看到我们的静态库工作的成果啦。</p><h2 id=扩展>扩展</h2><p>其实除了引用静态库的方式之外，我们还可以直接通过配置<code>CMakeLists.txt</code>文件来引用源码，这样可以随时随地对源码进行定制，但是也降低了编译速度，而且可能会增加<code>CMakeLists.txt</code>的复杂度。所以我还是推荐直接使用静态库的方式。</p><h1 id=总结>总结</h1><p>CMake其实还有很多很多命令，我们这里涉及到的只是很少的一部分。但是，我觉得理解CMake有这些内容差不多就可以了，后续有需要再针对性学习就行了。学习一门技术，切忌不能贪多，贪细。先要抓住主干，理清脉络，后面的细节就是水到渠成的事。对于CMake，我觉得就是以C++代码编译为二进制的过程为主干就够了。源码从哪里来，头文件在那里，库文件在哪里，怎么组织编译，参与链接的库有哪些，生成什么产物，还有一些完成这些工作的通用操作，复制文件啊，目录信息啊等，这些操作的集合就构成了CMake的主体。另外，CMake其实只是一种构建工具，它本身不是编译器和链接器，有些问题可能不仅仅会涉及到cmake，还可能会涉及到编译器和连接器。当然，这些都是后面深入了解之后才可能碰到的问题了。</p></section><footer class=article-footer><section class=article-tags><a href=/tags/android/>Android</a>
<a href=/tags/jni/>JNI</a>
<a href=/tags/c/c++/>C/C++</a>
<a href=/tags/cmake/>CMake</a></section></footer></article><aside class=related-content--wrapper><h2 class=section-title>相关文章</h2><div class=related-content><div class="flex article-list--tile"><article><a href=/post/%20Kotlin%E5%8D%8F%E7%A8%8B-%E4%BB%8E%E4%B8%80%E5%88%B0%E5%A4%9A.html><div class=article-details><h2 class=article-title>Kotlin协程-从一到多</h2></div></a></article><article><a href=/post/Kotlin%E5%8D%8F%E7%A8%8B-%E4%BB%8E%E7%90%86%E8%AE%BA%E5%88%B0%E5%AE%9E%E6%88%98.html><div class=article-details><h2 class=article-title>用纯HTML，JS，CSS实现横向滚动标签页</h2></div></a></article><article><a href=/post/Kotlin%E5%8D%8F%E7%A8%8B-%E9%82%A3%E4%BA%9B%E7%90%86%E4%B8%8D%E6%B8%85%E4%B9%B1%E4%B8%8D%E6%98%8E%E7%9A%84%E5%85%B3%E7%B3%BB.html><div class=article-details><h2 class=article-title>Kotlin协程-那些理不清乱不明的关系</h2></div></a></article><article><a href=/post/%E6%B2%89%E6%80%9D%E7%AF%87-%E5%89%96%E6%9E%90Jetpack%E7%9A%84LiveData.html><div class=article-details><h2 class=article-title>沉思篇-剖析Jetpack的ViewModel</h2></div></a></article><article><a href=/post/%E6%B2%89%E6%80%9D%E7%AF%87-%E5%89%96%E6%9E%90Jetpack%E7%9A%84LiveData.html><div class=article-details><h2 class=article-title>沉思篇-剖析Jetpack的LiveData</h2></div></a></article></div></div></aside><footer class=site-footer><section class=copyright>&copy;
2020 -
2022 低头沉思</section><section class=powerby>Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a><br>主题 <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.14.0>Stack</a></b> 由 <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a> 设计</section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"></button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z+KMkF24hUW8WePSA9HM=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.js defer></script>
<script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>