<!doctype html><html lang=zh-cn data-theme=light><head><meta charset=utf-8><meta name=viewport content="width=device-width"><meta name=theme-color content="#584394" media="(prefers-color-scheme: light)"><meta name=generator content="Hugo 0.105.0"><link rel="shortcut icon" type=image/x-icon href=/images/icons/favicon.ico><link rel=icon type=image/x-icon href=/images/icons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=/images/icons/favicon_16x16.png><link rel=icon type=image/png sizes=32x32 href=/images/icons/favicon_32_32.png><link rel=apple-touch-icon sizes=180x180 href=/imgs/icons/apple_touch_icon.png><meta itemprop=name content="现代C++学习指南-标准库"><meta itemprop=description content="现代C++学习指南-标准库"><meta itemprop=datePublished zgotmplz><meta itemprop=dateModified zgotmplz><meta itemprop=image content="https://hongui.github.io/images/logo.png"><meta itemprop=keywords content="学习指南,C++"><meta property="og:type" content="article"><meta property="og:title" content="现代C++学习指南-标准库"><meta property="og:description" content="现代C++学习指南-标准库"><meta property="og:image" content="/images/logo.png"><meta property="og:image:width" content="312"><meta property="og:image:height" content="312"><meta property="og:image:type" content="image/jpeg/png/svg/jpg"><meta property="og:url" content="https://hongui.github.io/post/%E7%8E%B0%E4%BB%A3C++%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97-%E6%A0%87%E5%87%86%E5%BA%93.html"><meta property="og:site_name" content="低头沉思"><meta property="og:locale" content="zh-CN"><meta property="article:author" content="hongui"><meta property="article:published_time" content="2022-07-20 22:15:05 +0800 +0800"><meta property="article:modified_time" content="2022-07-20 22:15:05 +0800 +0800"><link type=text/css rel=stylesheet href=https://unpkg.com/@fortawesome/fontawesome-free@6.1.2/css/all.min.css><link type=text/css rel=stylesheet href=https://unpkg.com/animate.css@3.1.1/animate.min.css><link type=text/css rel=stylesheet href=https://unpkg.com/viewerjs@1.11.0/dist/viewer.min.css><link rel=stylesheet href=/css/main.min.724568d040da1d63a359306ef65ac74d8bf58e4e72c1f88c9ae65e1497de5b62.css><style type=text/css>.post-footer,.flinks-list-footer hr:after{content:"~ 我可是有底线的哟 ~"}</style><script type=text/javascript>(function(){localDB={set:function(e,t,n){if(n===0)return;const s=new Date,o=n*864e5,i={value:t,expiry:s.getTime()+o};localStorage.setItem(e,JSON.stringify(i))},get:function(e){const t=localStorage.getItem(e);if(!t)return void 0;const n=JSON.parse(t),s=new Date;return s.getTime()>n.expiry?(localStorage.removeItem(e),void 0):n.value}},theme={active:function(){const e=localDB.get("theme");if(e==null)return;theme.toggle(e),window.matchMedia("(prefers-color-scheme: dark)").addListener(function(e){theme.toggle(e.matches?"dark":"light")})},toggle:function(e){document.documentElement.setAttribute("data-theme",e),localDB.set("theme",e,2);const t=document.querySelector("iframe.giscus-frame");if(t){const n={setConfig:{theme:e}};t.contentWindow.postMessage({giscus:n},"https://giscus.app")}}},theme.active()})(window)</script><script class=next-config data-name=page type=application/json>{"comments":false,"isHome":false,"isPage":true,"path":"%E7%8E%B0%E4%BB%A3C++%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97-%E6%A0%87%E5%87%86%E5%BA%93.html","permalink":"https://hongui.github.io/post/%E7%8E%B0%E4%BB%A3C++%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97-%E6%A0%87%E5%87%86%E5%BA%93.html","title":"现代C++学习指南-标准库","waline":{"js":[{"alias":"waline","alias_name":"@waline/client","file":"dist/pageview.js","name":"pageview","version":"2.13.0"},{"alias":"waline","alias_name":"@waline/client","file":"dist/comment.js","name":"comment","version":"2.13.0"}]}}</script><script type=text/javascript>document.addEventListener("DOMContentLoaded",()=>{var e=document.createElement("script");e.charset="UTF-8",e.id="LA_COLLECT",e.src="https://sdk.51.la/js-sdk-pro.min.js",e.async="true",e.onload=function(){LA.init({id:"JrJFibzvtRuObfi1",ck:"JrJFibzvtRuObfi1",autoTrack:!0})},document.head.appendChild(e)})</script><title>现代C++学习指南-标准库 - 低头沉思</title><noscript><link rel=stylesheet href=/css/noscript.css></noscript></head><body itemscope itemtype=http://schema.org/WebPage class=use-motion><div class=headband></div><main class=main><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-brand-container><div class=site-nav-toggle><div class=toggle aria-label=切换导航栏 role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div></div><div class=site-meta><a href=/ class=brand rel=start><i class=logo-line></i><h1 class=site-title>低头沉思</h1><i class=logo-line></i></a><p class=site-subtitle itemprop=description>保持思考</p><img class=custom-logo-image src=/images/logo.png alt=低头沉思></div><div class=site-nav-right><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class=site-nav><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href=/ class=hvr-icon-pulse rel=section><i class="fa fa-home hvr-icon"></i>首页</a></li><li class="menu-item menu-item-archives"><a href=/ class=hvr-icon-pulse rel=section><i class="fa fa-archive hvr-icon"></i>归档
<span class=badge>15</span></a></li><li class="menu-item menu-item-tags"><a href=/tags/ class=hvr-icon-pulse rel=section><i class="fa fa-tags hvr-icon"></i>标签</a></li><li class="menu-item menu-item-about"><a href=/about.html class=hvr-icon-pulse rel=section><i class="fa fa-user hvr-icon"></i>关于</a></li><li class="menu-item menu-item-search"><a role=button class="popup-trigger hvr-icon-pulse"><i class="fa fa-search fa-fw hvr-icon"></i>搜索</a></li></ul></nav><div class=search-pop-overlay><div class="popup search-popup"><div class=search-header><span class=search-icon><i class="fa fa-search"></i></span><div class=search-input-container><input autocomplete=off autocapitalize=off maxlength=80 placeholder=搜索... spellcheck=false type=search class=search-input></div><span class=popup-btn-close role=button><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class=search-result-icon><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></div><div class="toggle sidebar-toggle" role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div><aside class=sidebar><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class=sidebar-nav><li class=sidebar-nav-toc>文章目录</li><li class=sidebar-nav-overview>站点概览</li></ul><div class=sidebar-panel-container><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><nav id=TableOfContents><ul><li><ul><li><a href=#什么是标准库>什么是标准库</a></li><li><a href=#容器类>容器类</a></li><li><a href=#算法>算法</a></li><li><a href=#智能指针>智能指针</a></li><li><a href=#线程库>线程库</a></li><li><a href=#其他>其他</a></li><li><a href=#总结>总结</a></li></ul></li></ul></nav></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop=author itemscope itemtype=http://schema.org/Person><img class=site-author-image itemprop=image alt=hongui src=/imgs/img-lazy-loading.gif data-src=/images/logo.png><p class=site-author-name itemprop=name>hongui</p><div class=site-description itemprop=description>记录生活所思所见。</div></div><div class="site-state-wrap site-overview-item animated"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/><span class=site-state-item-count>15</span>
<span class=site-state-item-name>日志</span></a></div><div class="site-state-item site-state-categories"><a href=/categories/><span class=site-state-item-count>7</span>
<span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/><span class=site-state-item-count>17</span>
<span class=site-state-item-name>标签</span></a></div></nav></div><div class="links-of-social site-overview-item animated"><span class=links-of-social-item><a href=https://github.com/hongui title="Github → https://github.com/hongui" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-github fa-fw hvr-icon"></i>Github</a></span></div><div class="cc-license animated" itemprop=license><a href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh class=cc-opacity rel=noopener target=_blank title=共享知识><img src=/imgs/img-lazy-loading.gif data-src=/imgs/cc/small/by_nc_sa.svg alt=共享知识></a></div><div class="links-of-blogroll site-overview-item animated"><div class=links-of-blogroll-title><i class="fa fa-globe fa-fw"></i>友情链接</div><ul class=links-of-blogroll-list><li class=links-of-blogroll-item><a href=https://gitee.com/hugo-next/hugo-theme-next title=https://gitee.com/hugo-next/hugo-theme-next target=_blank>Hugo-NexT</a></li></ul></div></div></div></div><div id=siteinfo-card-widget class=sidebar-card-widget><div class=item-headline><i class="fas fa-chart-line"></i>
<span>网站资讯</span></div><div class=siteinfo><div class=siteinfo-item><div class=item-name><i class="fa-solid fa-calendar-check"></i>已运行：</div><div class=item-count id=runTimes data-publishdate=2021/03/21T15:56:53+08:00></div></div><div id=la-siteinfo-widget style=display:none></div><div class=siteinfo-item><div class=item-name><i class="fa fa-user-plus"></i>今日访问：</div><div class=item-count id=today_site_pv><i class="fa fa-sync fa-spin"></i></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-user-clock"></i>昨日访问：</div><div class=item-count id=yesterday_site_pv><i class="fa fa-sync fa-spin"></i></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-arrows-down-to-people"></i>本月访问：</div><div class=item-count id=month_site_pv><i class="fa fa-sync fa-spin"></i></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-users"></i>总访问量：</div><div class=item-count id=total_site_pv><i class="fa fa-sync fa-spin"></i></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-font"></i>总字数：</div><div class=item-count id=wordsCount data-count=9762></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-mug-hot"></i>阅读约：</div><div class=item-count id=readTimes data-times=37></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-clock-rotate-left"></i>最后更新于：</div><div class=item-count id=last-push-date data-lastpushdate=2022/10/31T21:33:38+08:00></div></div></div></div></aside><div class=sidebar-dimmer></div></header><div class=tool-buttons><div id=toggle-theme class=button title=深浅模式切换><i class="fas fa-adjust"></i></div><div class=back-to-top role=button title=返回顶部><i class="fa fa-arrow-up"></i>
<span>0%</span></div></div><div class=reading-progress-bar></div><a role=button class="book-mark-link book-mark-link-fixed"></a>
<a href=https://github.com/hongui rel="noopener external nofollow noreferrer" target=_blank title="Follow me on GitHub" class="exturl github-corner"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115h15l12 27L250 250V0z"/><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentcolor" style="transform-origin:130px 106px" class="octo-arm"/><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4l13.9-13.8C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8z" fill="currentcolor" class="octo-body"/></svg></a><noscript><div class=noscript-warning>Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner post posts-expand"><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://hongui.github.io/post/%E7%8E%B0%E4%BB%A3C++%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97-%E6%A0%87%E5%87%86%E5%BA%93.html><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/images/logo.png"><meta itemprop=name content="hongui"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="hongui"><meta itemprop=description content="记录生活所思所见。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="现代C++学习指南-标准库"><meta itemprop=description content="现代C++学习指南-标准库"></span><header class=post-header><h1 class=post-title itemprop="name headline">现代C++学习指南-标准库</h1><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar"></i></span>
<span class=post-meta-item-text>发表于：</span>
<time title="发表于：2022-07-20 22:15:05 +0800 +0800" itemprop="dateCreated datePublished" datetime="2022-07-20 22:15:05 +0800 +0800">2022/07/20</time></span>
<span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-folder-open"></i></span>
<span class=post-meta-item-text>分类于：</span>
<span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/c++ itemprop=url rel=index><span itemprop=name>C++</span></a></span></span></div><div class=post-meta-items><span class=post-meta-item title=字数><span class=post-meta-item-icon><i class="far fa-file-word"></i></span>
<span class=post-meta-item-text>字数：</span><span>331</span></span>
<span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="far fa-eye"></i></span>
<span class=post-meta-item-text>浏览：</span>
<span class=waline-pageview-count data-path=/post/%E7%8E%B0%E4%BB%A3C++%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97-%E6%A0%87%E5%87%86%E5%BA%93.html><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class="post-body autonumber" itemprop=articleBody><blockquote><p>在[上一章](
<a href=https://www.yuque.com/docs/share/adb5b1e4-f3c6-46fd-ba4b-4dabce9b4f2a?# title=https://www.yuque.com/docs/share/adb5b1e4-f3c6-46fd-ba4b-4dabce9b4f2a?# rel="noopener external nofollow noreferrer" target=_blank class=exturl>https://www.yuque.com/docs/share/adb5b1e4-f3c6-46fd-ba4b-4dabce9b4f2a?#
<i class="fa fa-external-link-alt"></i></a> 《现代C++学习指南-类型系统》)我们探讨了C++的类型系统，并提出了从低到高，又从高到低的学习思路，本文就是一篇从高到低的学习指南，希望能提供一种新的视角。</p></blockquote><h3 id=什么是标准库>什么是标准库</h3><p>编程语言一般分为两个部分，一部分是语法部分，如上一章的类型系统，另一部分则是用这套语法完成的预定义的工具集，如本文的主题——标准库。标准库是一堆我们写代码时直接可以用的代码，就像是我们提前写好的一样，不仅如此，标准库还是跨平台的，还是经过工业级测试的，所以标准库有着靠谱，安全的特点。
C++标准库包括很多方面，有类<code>vector</code>、<code>string</code>等,有对象<code>std::cin</code>，<code>std::cout</code>等，还有函数<code>move</code>，<code>copy</code>等，所以一般按功能来对它们分类</p><ul><li>容器类</li><li>算法类</li><li>智能指针</li><li>线程相关</li><li>其他</li></ul><p>当然，这些还不是全部，标准库是在不断扩充和完善的，学习标准库的宗旨也应该是学习它们的使用场景，而不是深入用法。比如容器类中就有很多功能类似的类，不同的业务场景有不同的选择。通过对它们的了解，我们更容易写出高效，简洁的代码。</p><h3 id=容器类>容器类</h3><p>容器类就是帮助管理一组数据的类，根据实现方式的不同，分为有序列表，无序列表和映射。
有序列表中的有序是指，数据组保存在一块连续的内存区域里，可以通过插入时的索引直接定位到原数据。因为数据是按顺序存入的，所以中途假如需要删除或者新增数据，在操作位置右边的数据都需要移动，操作的代价就比较大。由此也可看出它们的优势是顺序插入和尾部修改，还有直接查找，这方面的代表就是<code>array</code>，<code>vector</code>。
<code>array</code>是对原始数组的封装，并且解决了传递数组变成指针这样的问题，但是缺点是它的大小是固定的，适合用在数据量已知的情况。而<code>vector</code>又是对<code>array</code>的增强，不仅能完成所有<code>array</code>的操作，并且大小可变，所以绝大部分情况下，选择<code>vector</code>都是理想的选择。
<img src=/imgs/img-lazy-loading.gif data-src=https://cdn.nlark.com/yuque/0/2022/jpeg/29458474/1658015351475-f6a5189b-7331-4173-80b4-1a1f83f25f7d.jpeg alt>
无序列表的元素是单独存储的，相互之间用指针来查找相邻元素，由于指针可以轻易修改指向的指，所以对相邻元素的修改就变得很快捷。同样的道理，查找相邻元素只能靠指针跳转，查找某个值需要从一个指针开始查找，一次跳转一条数据，直到找到目标或者没有数据为止。所以无序列表的优势是快速地删除和插入新数据，不适合查找，其代表有<code>list</code>，<code>forward_list</code>。显然，有序列表和无序列表是互补的，我们在实际项目中，应该<strong>根据数据的操作来确定选择哪种容器。</strong>
<img src=/imgs/img-lazy-loading.gif data-src=https://cdn.nlark.com/yuque/0/2022/jpeg/29458474/1658015352400-93e48503-009d-41bb-89b1-4a50bc1ca3d1.jpeg alt></p><p><strong>映射则融合了有序列表和无序列表的优点，既可以快速插入和删除，又可以快速查找</strong>。为了满足各种使用场景，C++提供了<code>map</code>，<code>multimap</code>，<code>unordered_map</code>，<code>unordered_multimap</code>。从名字上就能看出来它们的差别。为了直观，我直接列了一个表</p><table><thead><tr><th></th><th>是否排序</th><th>是否支持相同值</th><th>速度</th></tr></thead><tbody><tr><td>unordered_map</td><td>❌</td><td>❌</td><td>❤️❤️❤️❤️</td></tr><tr><td>map</td><td>✅</td><td>❌</td><td>❤️❤️</td></tr><tr><td>multimap</td><td>✅</td><td>✅</td><td>❤️</td></tr><tr><td>unordered_multimap</td><td>✅</td><td>✅</td><td>❤️❤️❤️</td></tr></tbody></table><p>映射存储的是两个值，不同的类型实现方式不一样。由于<code>map</code>是需要排序的，所以通常它的实现是一种平衡二叉树，键就是它排序的依据。
<img src=/imgs/img-lazy-loading.gif data-src=https://cdn.nlark.com/yuque/0/2022/jpeg/29458474/1658015140161-206f2bf1-345d-4fb7-9b6d-50fbfcb81b2e.jpeg alt>
而<code>unordered_map</code>是不需要排序的，所以它的实现通常是哈希表，即根据哈希函数的确定索引位置继而确定存储位置。
<img src=/imgs/img-lazy-loading.gif data-src=https://cdn.nlark.com/yuque/0/2022/jpeg/29458474/1658015142087-4460ed23-40be-441e-8649-c40eb78dfc9a.jpeg alt>
综上，容器类提供了一种操作多个同类型数据的接口，开发者通过对容器类方法的调用，可以实现对容器内数据的增删改查。大部分情况下，<code>vector</code>都是靠谱的选择，它提供了全功能的数据操作接口，支持动态长度，索引查询，并且简单高效。如果需要频繁地插入或者删除操作，也可以考虑<code>list</code>或者<code>forward_list</code>。<code>map</code>可以让数据保持有序，需要更快的速度而不是排序的话<code>unorderer_map</code>是更好的选择，如果相同值会出现多次就可以使用对应的<code>multi</code>版本。另外容器类也是很好的数据结构学习资源，C++的容器类几乎提供了数据结构中所有的形式，对数据结构越熟悉选择的容器类就越完美。</p><h3 id=算法>算法</h3><p>之所以将算法放在容器类后面，是因为算法大部分是对容器类操作的加强，算法都定义在<code>algorithm</code>文件头里。这些算法都是短小精悍的，可以大大增加代码可读性，并且妥善处理了很多容易遗忘的边界问题。功能上可以分为增删改查几种操作，可以在实际有需要的时候在查看文档，具体可以参阅
<a href=https://cplusplus.com/reference/algorithm/ title=这里 rel="noopener external nofollow noreferrer" target=_blank class=exturl>这里
<i class="fa fa-external-link-alt"></i></a></p><h3 id=智能指针>智能指针</h3><p>很早以前，我对智能指针的态度不是很好。因为刚开始学习C++时我就知道，不能单独使用指针，要把指针封装在类里，利用类的构造函数和析构函数管理指针，也就是<code>RAII</code>。最开始我以为这就够了,直到我遇到下面这种情况</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-cpp data-lang=cpp><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1</span><span><span style=color:#a2f;font-weight:700>public</span><span style=color:#666>:</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2</span><span>    Ptr()<span style=color:#666>:</span>p{ <span style=color:#a2f;font-weight:700>new</span> <span style=color:#0b0;font-weight:700>int</span> } {}
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3</span><span>    <span style=color:#666>~</span>Ptr() {
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4</span><span>        <span style=color:#a2f;font-weight:700>delete</span> p;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5</span><span>    }
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6</span><span>    <span style=color:#0b0;font-weight:700>int</span><span style=color:#666>&amp;</span> get() {
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7</span><span>        <span style=color:#a2f;font-weight:700>return</span> <span style=color:#666>*</span>p;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8</span><span>    }
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9</span><span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10</span><span>    <span style=color:#0b0;font-weight:700>void</span> <span style=color:#00a000>set</span>(<span style=color:#a2f;font-weight:700>const</span> <span style=color:#0b0;font-weight:700>int</span> value) {
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11</span><span>        <span style=color:#666>*</span>p <span style=color:#666>=</span> value;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12</span><span>    }
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13</span><span><span style=color:#a2f;font-weight:700>private</span><span style=color:#666>:</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14</span><span>    <span style=color:#0b0;font-weight:700>int</span><span style=color:#666>*</span> p;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15</span><span>};
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16</span><span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">17</span><span><span style=color:#0b0;font-weight:700>void</span> <span style=color:#00a000>use</span>(Ptr p) {
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">18</span><span>    <span style=color:#080;font-style:italic>//传进来的是复制构造出来的p&#39;,函数返回后p&#39;被销毁啦，两个指针指向的地址被回收，外面的p指针成为了野指针
</span></span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">19</span><span><span style=color:#080;font-style:italic></span>}
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">20</span><span><span style=color:#0b0;font-weight:700>int</span> <span style=color:#00a000>main</span>() {
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">21</span><span>    Ptr p;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">22</span><span>    p.set(<span style=color:#666>1</span>);
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">23</span><span>    use(p); <span style=color:#080;font-style:italic>//p按值传递，调用了Ptr的复制构造函数，构造出了新对象p&#39;,它的指针和p的指针指向同一个地方
</span></span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">24</span><span><span style=color:#080;font-style:italic></span>    std<span style=color:#666>::</span>cout <span style=color:#666>&lt;&lt;</span> p.get() <span style=color:#666>&lt;&lt;</span> std<span style=color:#666>::</span>endl; <span style=color:#080;font-style:italic>//p已经被销毁了，访问p的地址非法
</span></span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">25</span><span><span style=color:#080;font-style:italic></span>    <span style=color:#a2f;font-weight:700>return</span> <span style=color:#666>0</span>;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">26</span><span>}
</span></span></code></pre></div><p>调用<code>use</code>时，变量<code>p</code>被拷贝，也就出现了两个指针同时指向一块内存地址的情况。<code>use</code>函数执行完后，它的参数<code>p</code>被回收。也就是调用了<code>Ptr</code>的析构函数，也就是两个指针指向的地址被回收。所以24行调用<code>get</code>读取那个已经被回收了的地址就是非法操作，程序崩溃。
这可能是新手比较常遇到的一个问题，当然，解决这个问题也很简单，还用不到智能指针，只需要将函数<code>use</code>的参数改为引用类型就可以了，因为引用只是别名，不会产生新的指针，这也是我在类型系统篇中极力推荐引用为首选参数类型的原因之一。对于此例，数据不大，直接重写复制构造函数，重新申请一块内存也是一种思路。
此例中用到Ptr的地方只有一个，实际项目中Ptr往往需要用到很多次，我们不能保证不会出现忘记使用引用类型的情况，这种情况下重新申请内存也不适用，所以这个时候就需要智能指针来帮忙了。
现在思考另一种情况，某些操作我们不得不暴露出我们的指针供外部使用，随着业务的嵌套和调用链增加，很多时候会忘记或者不确定在什么时候调用<code>delete</code>释放内存。这也是用智能指针的一个场景。以上两种情况都是需要分享指针，对应智能指针中的<code>shared_ptr</code>。
<code>shared_ptr</code>顾名思义，它可以帮助开发者完成指针共享的问题，并且完美解决提前释放，不知何时释放，谁负责释放的问题。它的对应关系是一对多，一个实际的内存可以被多个<code>shared_ptr</code>共享
<img src=/imgs/img-lazy-loading.gif data-src=https://cdn.nlark.com/yuque/0/2022/jpeg/29458474/1658146077740-b934d6d5-fc6e-4cff-9863-4e263b5c3848.jpeg alt>
另外一种场景是我们希望<strong>自始至终某个指针某个时刻只属于一个对象</strong>，外部想要使用它要么通过拥有该指针的对象方法，要么把指针的所有权转移到自己身上，这种场景对应智能指针中的<code>unique_ptr</code>。
<img src=/imgs/img-lazy-loading.gif data-src=https://cdn.nlark.com/yuque/0/2022/jpeg/29458474/1658147416713-1b6a7866-1cd8-4be6-b2dc-bdfe41db69d6.jpeg alt>
<code>unique_ptr</code>的对应关系是一对一，无论哪个时刻，只能有一个管理者拥有指针，也就只能由它负责释放了。假如想转移这种对应关系，只能通过<code>std::move</code>操作，不过这个操作之后，原先对象的指针就失效了，它也不再负责管理，所有的任务移交给了新的对象。这种特性特别适合资源敏感型的应用。</p><h3 id=线程库>线程库</h3><p>除了内存，线程是开发中另一个重要的课题。线程的难点在于不仅要管理线程对象，还要管理线程对象管理的资源，并且保证线程间数据同步。当然标准库已经做得足够好了，我们需要理解的是使用场景的问题。线程库主要包括线程对象<code>thread</code>，条件对象<code>condition_variable</code>，锁对象<code>mutex</code>。
使用<code>thread</code>可以很方便地把程序写成多线程，只需要三步：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-cpp data-lang=cpp><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1</span><span><span style=color:#0b0;font-weight:700>void</span> <span style=color:#00a000>plus</span>(<span style=color:#0b0;font-weight:700>int</span> a,<span style=color:#0b0;font-weight:700>int</span> b){ <span style=color:#080;font-style:italic>//第一步：定义线程中要运行的函数
</span></span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2</span><span><span style=color:#080;font-style:italic></span>    std<span style=color:#666>::</span>cout<span style=color:#666>&lt;&lt;</span><span style=color:#b44>&#34;running at sub thread&#34;</span><span style=color:#666>&lt;&lt;</span>std<span style=color:#666>::</span>endl;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3</span><span>    std<span style=color:#666>::</span>cout<span style=color:#666>&lt;&lt;</span><span style=color:#b44>&#34;a + b = &#34;</span><span style=color:#666>&lt;&lt;</span>a<span style=color:#666>+</span>b<span style=color:#666>&lt;&lt;</span>std<span style=color:#666>::</span>endl;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4</span><span>}
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5</span><span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6</span><span><span style=color:#0b0;font-weight:700>int</span> <span style=color:#00a000>main</span>(){
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7</span><span>    std<span style=color:#666>::</span><span style=color:#a2f;font-weight:700>thread</span> <span style=color:#a2f;font-weight:700>thread</span>{plus,<span style=color:#666>1</span>,<span style=color:#666>1</span>}; <span style=color:#080;font-style:italic>//第二步，定义std::thread对象，将函数作为参数
</span></span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8</span><span><span style=color:#080;font-style:italic></span>    std<span style=color:#666>::</span>cout<span style=color:#666>&lt;&lt;</span><span style=color:#b44>&#34;continue running at main thread&#34;</span><span style=color:#666>&lt;&lt;</span>std<span style=color:#666>::</span>endl;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9</span><span>    <span style=color:#a2f;font-weight:700>thread</span>.join(); <span style=color:#080;font-style:italic>//第三步调用线程对象的join函数或者detach函数
</span></span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10</span><span><span style=color:#080;font-style:italic></span>    std<span style=color:#666>::</span>cout<span style=color:#666>&lt;&lt;</span><span style=color:#b44>&#34;sub thread finished!&#34;</span><span style=color:#666>&lt;&lt;</span>std<span style=color:#666>::</span>endl;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11</span><span>}
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12</span><span><span style=color:#080;font-style:italic>//输出
</span></span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13</span><span><span style=color:#080;font-style:italic>//	continue running at main thread
</span></span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14</span><span><span style=color:#080;font-style:italic>//	running at sub thread
</span></span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15</span><span><span style=color:#080;font-style:italic>// 	a + b = 2
</span></span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16</span><span><span style=color:#080;font-style:italic>// 	sub thread finished!
</span></span></span></code></pre></div><p>难点在线程间通信，也就是解决两个问题</p><ol><li>线程1更新了变量v的值</li><li>线程2马上能读取到正确的变量v的值，即线程1更新的那个最新值</li></ol><p>为了协调这两个过程，就出现了锁对象<code>mutex</code>和条件对象<code>condition_variable</code>。锁对象<code>mutex</code>保证变量按照正确的顺序更改。条件对象<code>condition_variable</code>保证更改能被其他线程监听到。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-cpp data-lang=cpp><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1</span><span><span style=color:#0b0;font-weight:700>int</span> a,b;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2</span><span><span style=color:#0b0;font-weight:700>bool</span> ready <span style=color:#666>=</span> <span style=color:#a2f>false</span>;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3</span><span>std<span style=color:#666>::</span>mutex mux;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4</span><span>std<span style=color:#666>::</span>condition_variable con;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5</span><span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6</span><span><span style=color:#0b0;font-weight:700>void</span> <span style=color:#00a000>plus</span>() {
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7</span><span>    std<span style=color:#666>::</span>cout <span style=color:#666>&lt;&lt;</span> <span style=color:#b44>&#34;running at sub thread&#34;</span> <span style=color:#666>&lt;&lt;</span> std<span style=color:#666>::</span>endl;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8</span><span>    <span style=color:#080;font-style:italic>//因为我们要读取ready的最新值，所以要用锁保证读取结果的有效性
</span></span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9</span><span><span style=color:#080;font-style:italic></span>    std<span style=color:#666>::</span>unique_lock<span style=color:#666>&lt;</span>std<span style=color:#666>::</span>mutex<span style=color:#666>&gt;</span> guard{ mux };
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10</span><span>    <span style=color:#a2f;font-weight:700>if</span> (<span style=color:#666>!</span>ready) {
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11</span><span>        <span style=color:#080;font-style:italic>//数据没准备好，休息一下！
</span></span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12</span><span><span style=color:#080;font-style:italic></span>        con.wait(guard); 
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13</span><span>    }
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14</span><span>    <span style=color:#080;font-style:italic>//这里就可以正确读变量a,b了
</span></span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15</span><span><span style=color:#080;font-style:italic></span>    std<span style=color:#666>::</span>cout <span style=color:#666>&lt;&lt;</span> <span style=color:#b44>&#34;a + b =&#34;</span> <span style=color:#666>&lt;&lt;</span> a <span style=color:#666>+</span> b <span style=color:#666>&lt;&lt;</span> std<span style=color:#666>::</span>endl;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16</span><span>}
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">17</span><span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">18</span><span><span style=color:#0b0;font-weight:700>int</span> <span style=color:#00a000>main</span>() {
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">19</span><span>    std<span style=color:#666>::</span><span style=color:#a2f;font-weight:700>thread</span> <span style=color:#a2f;font-weight:700>thread</span>{ plus};
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">20</span><span>    std<span style=color:#666>::</span>cout <span style=color:#666>&lt;&lt;</span> <span style=color:#b44>&#34;continue running at main thread&#34;</span> <span style=color:#666>&lt;&lt;</span> std<span style=color:#666>::</span>endl;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">21</span><span>    std<span style=color:#666>::</span>cout <span style=color:#666>&lt;&lt;</span> <span style=color:#b44>&#34;input a = &#34;</span>;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">22</span><span>    std<span style=color:#666>::</span>cin <span style=color:#666>&gt;&gt;</span> a;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">23</span><span>    std<span style=color:#666>::</span>cout <span style=color:#666>&lt;&lt;</span> <span style=color:#b44>&#34;input b = &#34;</span>;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">24</span><span>    std<span style=color:#666>::</span>cin <span style=color:#666>&gt;&gt;</span> b;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">25</span><span>    {
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">26</span><span>        <span style=color:#080;font-style:italic>//数据准备好了，该通知子线程干活了，用大括号是因为想让锁因为guard的销毁即使释放，从未保证plus里面能重新获得锁
</span></span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">27</span><span><span style=color:#080;font-style:italic></span>        std<span style=color:#666>::</span>unique_lock<span style=color:#666>&lt;</span>std<span style=color:#666>::</span>mutex<span style=color:#666>&gt;</span> guard{ mux };
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">28</span><span>        <span style=color:#080;font-style:italic>//更新数据
</span></span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">29</span><span><span style=color:#080;font-style:italic></span>        ready <span style=color:#666>=</span> <span style=color:#a2f>true</span>;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">30</span><span>        <span style=color:#080;font-style:italic>//通知
</span></span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">31</span><span><span style=color:#080;font-style:italic></span>        con.notify_all();
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">32</span><span>    }
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">33</span><span>    <span style=color:#a2f;font-weight:700>thread</span>.join();
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">34</span><span>    std<span style=color:#666>::</span>cout <span style=color:#666>&lt;&lt;</span> <span style=color:#b44>&#34;sub thread finished!&#34;</span> <span style=color:#666>&lt;&lt;</span> std<span style=color:#666>::</span>endl;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">35</span><span>}
</span></span></code></pre></div><p>多线程另一个需要注意的问题就是死锁。死锁的前提是有两个锁</p><ol><li>线程1得到了锁a，还想得锁b</li><li>线程2得到了锁b，还想得锁a</li></ol><p>然后，再加上一个前提：某一时刻，只有一个线程能拥有某个锁，就不难得出以下结论：线程a，b除非某一个放弃已得的锁，不然两个线程都会因为没得到需要的锁而一直死等，形成死锁。同时解决死锁的思路也呼之欲出：既然一个得了a，一个得了b，而锁同一时间只能被一个线程得到，那么所有线程都按先得a，再得b的顺序来就不会有锁被占用的问题了。另一个思路则可以从放弃上入手，既然都得不到，那么接下来的任务也做不了，不如直接放弃已经得到的，所以可以考虑使用<code>timed_mutex</code>。</p><h3 id=其他>其他</h3><p>还有很多常用的库，如字符串<code>string</code>，时间<code>chrono</code>，还有在定义函数变量时常用的<code>functional</code>,异常<code>exception</code>，更多的内容可以在
<a href=https://cplusplus.com/reference/ title=cplusplus rel="noopener external nofollow noreferrer" target=_blank class=exturl>cplusplus
<i class="fa fa-external-link-alt"></i>
</a>找的参考。</p><h3 id=总结>总结</h3><p>总的来说，标准库提供了一个展现C++语言能力的平台：帮助开发者更好更快完成开发任务的同时，还能启迪开发者实现更好的抽象和实践。如我就从标准库中学到了更规范地定义函数参数，更好的封装，以及其他好的思路。学习标准库不仅更好地掌握了语言本身，还掌握了更全面地分析问题，解决问题的方法，是值得花费一段时间学习的。
容器类是几乎所有项目都会用到的，也是比较好掌握的，主要可以从数据结构方面对照学习；智能指针则是处理指针问题的好帮手；线程相关的库是比较难掌握的，关键是要想明白使用场景和极端情况下的边界问题。很多时候边界问题可能不那么直观。如线程要求获得锁的情况就分为：锁空闲，锁被其他线程占有，锁被自己占有。不同的边界对于不同的锁，预期结果也是不同的，只有在明确场景的情况下，才能更好地理清锁的关系，从而解决好问题。
最好的学习还是在实践中主动使用。对于我，通常在遇到新问题的时候会先查查标准库有没有相应的库，有的话就是学习这个库的好时机。可以先概览库的定义和解决的问题，然后分析它提供的类，函数，对象等，再将自己的理解转换为项目中的代码，最后在实际效果中检验和修正想法，完成库的学习。</p></div><footer class=post-footer><div class=post-tags><a href=/tags/%e5%ad%a6%e4%b9%a0%e6%8c%87%e5%8d%97>学习指南</a>
<a href=/tags/c++>C++</a></div><div class=addthis_inline_share_toolbox style=text-align:center></div><hr><div class=post-copyright><img src=/imgs/cc/cc.svg width=75 height=75 align=right><ul><li class=post-copyright-title><strong>文章标题：</strong>
现代C++学习指南-标准库</li><li class=post-copyright-author><strong>原文作者：</strong>
hongui</li><li class=post-copyright-link><strong>本文链接：</strong>
<a id=post-cr-link href=https://hongui.github.io/post/%E7%8E%B0%E4%BB%A3C++%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97-%E6%A0%87%E5%87%86%E5%BA%93.html title=现代C++学习指南-标准库>https://hongui.github.io/post/%E7%8E%B0%E4%BB%A3C++%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97-%E6%A0%87%E5%87%86%E5%BA%93.html</a></li><li class=post-copyright-license><strong>版权声明：</strong>
本博客所有文章除特别声明外，均采用 <i class="fab fa-fw fa-creative-commons"></i><a target=_blank href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh>BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><div class=post-nav><div class="post-nav-next post-nav-item"><a href=/post/%E7%8E%B0%E4%BB%A3C++%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97%20%E6%A8%A1%E6%9D%BF.html rel=next title="现代C++学习指南 模板"><i class="fa fa-chevron-left"></i> 现代C++学习指南 模板</a></div><div class="post-nav-prev post-nav-item"><a href=/post/%E7%8E%B0%E4%BB%A3C++%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97-%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F.html rel=prev title=现代C++学习指南-类型系统>现代C++学习指南-类型系统
<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div></div></main><footer class=footer><div class=footer-inner><div class=copyright>&copy;
<span itemprop=copyrightYear>2020 - 2022</span>
<span class=with-love><i class="fa fa-heart"></i></span>
<span class=author itemprop=copyrightHolder>hongui</span></div><div class=powered-by>由 <a href=https://gohugo.io title=0.105.0 target=_blank>Hugo</a> & <a href=https://github.com/hugo-next/hugo-theme-next title=4.4.0 target=_blank>Hugo NexT.Gemini</a> 强力驱动</div></div></footer><script type=text/javascript src=https://unpkg.com/animejs@3.2.1/lib/anime.min.js defer></script>
<script type=text/javascript src=https://unpkg.com/viewerjs@1.11.0/dist/viewer.min.js defer></script>
<script class=next-config data-name=main type=application/json>{"bookmark":{"color":"#584394","enable":true,"save":"manual"},"copybtn":true,"darkmode":false,"giscus":{"cfg":{"category":"Comments","categoryid":null,"emit":false,"inputposition":"top","mapping":"title","reactions":false,"repo":"username/repo-name","repoid":null,"theme":"preferred_color_scheme"},"js":"https://giscus.app/client.js"},"hostname":"https://hongui.github.io/","i18n":{"ds_day":" 天前","ds_days":" 天 ","ds_hour":" 小时前","ds_hours":" 小时 ","ds_just":"刚刚","ds_min":" 分钟前","ds_mins":" 分钟","ds_month":" 个月前","ds_years":" 年 ","empty":"没有找到任何搜索结果：${query}","hits":"","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","placeholder":"搜索..."},"lang":"zh-CN","lawidget":{"id":"JrJFibzvtRuObfi1","js":"https://v6-widget.51.la/v6/laId/quote.js?theme=0\u0026col=true\u0026f=12\u0026display=0,0,0,1,0,1,1,1"},"lazyload":false,"localSearch":{"enable":true,"path":"/searchindexes.xml","preload":false,"topnperarticle":-1,"trigger":"auto","unescape":false},"motion":{"async":true,"enable":true,"transition":{"collheader":"fadeInLeft","postblock":"fadeIn","postbody":"fadeInDown","postheader":"fadeInDown","sidebar":"fadeInUp"}},"root":"/","scheme":"Gemini","sidebar":{"display":"always","offset":8,"padding":16,"position":"left","width":240},"statis":{"enable":true,"plugin":"51la"},"vendor":{"plugins":"unpkg","router":"https://unpkg.com"},"version":"4.4.0","waline":{"cfg":{"emoji":false,"imguploader":false,"pageview":"#waline-pageview-count","placeholder":"请文明发言哟 ヾ(≧▽≦*)o","reaction":true,"reactiontext":["点赞","踩一下","得意","不屑","尴尬","睡觉"],"reactiontitle":"你认为这篇文章怎么样？","requiredmeta":["nick","mail"],"serverurl":null,"sofa":"快来发表你的意见吧 (≧∀≦)ゞ","wordlimit":200},"css":{"alias":"waline","file":"dist/waline.css","name":"@waline/client","version":"2.13.0"},"js":{"alias":"waline","file":"dist/waline.js","name":"@waline/client","version":"2.13.0"}}}</script><script type=text/javascript src=/js/main.min.08bda9e4524cd731736163563f52818b7194694c2486534cc8a72a94c7209862.js defer></script></body></html>