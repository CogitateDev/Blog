<!doctype html><html lang=zh-cn dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="现代C++学习指南-标准库"><title>现代C++学习指南-标准库</title><link rel=canonical href=https://hongui.github.io/post/%E7%8E%B0%E4%BB%A3C++%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97-%E6%A0%87%E5%87%86%E5%BA%93.html><link rel=stylesheet href=/scss/style.min.18145888f21de6cb02d8cb0891be8240096206785da14eda35f6c23c239b966a.css><meta property="og:title" content="现代C++学习指南-标准库"><meta property="og:description" content="现代C++学习指南-标准库"><meta property="og:url" content="https://hongui.github.io/post/%E7%8E%B0%E4%BB%A3C++%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97-%E6%A0%87%E5%87%86%E5%BA%93.html"><meta property="og:site_name" content="低头沉思"><meta property="og:type" content="article"><meta property="article:section" content="Posts"><meta property="article:tag" content="学习指南"><meta property="article:tag" content="C++"><meta property="article:published_time" content="2022-07-20T22:15:05+08:00"><meta property="article:modified_time" content="2022-07-20T22:15:05+08:00"><meta name=twitter:title content="现代C++学习指南-标准库"><meta name=twitter:description content="现代C++学习指南-标准库"><link rel="shortcut icon" href=#ZgotmplZ></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column compact"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label=切换菜单>
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/><img src=/img/avatar_huda2458f72ce188392d75c5d51cd8e24e_373_300x0_resize_box_3.png width=300 height=300 class=site-logo loading=lazy alt=Avatar></a></figure><div class=site-meta><h1 class=site-name><a href=/>低头沉思</a></h1><h2 class=site-description></h2></div></header><ol class=menu id=main-menu><li><a href=/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg><span>首页</span></a></li><li><a href=/about.html><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="7" r="4"/><path d="M6 21v-2a4 4 0 014-4h4a4 4 0 014 4v2"/></svg><span>关于</span></a></li><li class=current><a href=/posts/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg><span>归档</span></a></li><li><a href=/404.html><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-infinity" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M9.828 9.172a4 4 0 100 5.656A10 10 0 0012 12a10 10 0 012.172-2.828 4 4 0 110 5.656A10 10 0 0112 12 10 10 0 009.828 9.172"/></svg><span>公益 404</span></a></li><div class=menu-bottom-section><li id=dark-mode-toggle><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg><span>暗色模式</span></li></div></ol></aside><main class="main full-width"><article class=main-article><header class=article-header><div class=article-details><header class=article-category><a href=/categories/c++/>C++</a></header><div class=article-title-wrapper><h2 class=article-title><a href=/post/%E7%8E%B0%E4%BB%A3C++%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97-%E6%A0%87%E5%87%86%E5%BA%93.html>现代C++学习指南-标准库</a></h2><h3 class=article-subtitle>现代C++学习指南-标准库</h3></div><footer class=article-time><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg><time class=article-time--published>2022/07/20 10:15</time></div><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg><time class=article-time--reading>阅读时长: 2 分钟</time></div></footer></div></header><section class=article-content><blockquote><p>在[上一章](<a class=link href=https://www.yuque.com/docs/share/adb5b1e4-f3c6-46fd-ba4b-4dabce9b4f2a?# target=_blank rel=noopener>https://www.yuque.com/docs/share/adb5b1e4-f3c6-46fd-ba4b-4dabce9b4f2a?#</a> 《现代C++学习指南-类型系统》)我们探讨了C++的类型系统，并提出了从低到高，又从高到低的学习思路，本文就是一篇从高到低的学习指南，希望能提供一种新的视角。</p></blockquote><h3 id=什么是标准库>什么是标准库</h3><p>编程语言一般分为两个部分，一部分是语法部分，如上一章的类型系统，另一部分则是用这套语法完成的预定义的工具集，如本文的主题——标准库。标准库是一堆我们写代码时直接可以用的代码，就像是我们提前写好的一样，不仅如此，标准库还是跨平台的，还是经过工业级测试的，所以标准库有着靠谱，安全的特点。
C++标准库包括很多方面，有类<code>vector</code>、<code>string</code>等,有对象<code>std::cin</code>，<code>std::cout</code>等，还有函数<code>move</code>，<code>copy</code>等，所以一般按功能来对它们分类</p><ul><li>容器类</li><li>算法类</li><li>智能指针</li><li>线程相关</li><li>其他</li></ul><p>当然，这些还不是全部，标准库是在不断扩充和完善的，学习标准库的宗旨也应该是学习它们的使用场景，而不是深入用法。比如容器类中就有很多功能类似的类，不同的业务场景有不同的选择。通过对它们的了解，我们更容易写出高效，简洁的代码。</p><h3 id=容器类>容器类</h3><p>容器类就是帮助管理一组数据的类，根据实现方式的不同，分为有序列表，无序列表和映射。
有序列表中的有序是指，数据组保存在一块连续的内存区域里，可以通过插入时的索引直接定位到原数据。因为数据是按顺序存入的，所以中途假如需要删除或者新增数据，在操作位置右边的数据都需要移动，操作的代价就比较大。由此也可看出它们的优势是顺序插入和尾部修改，还有直接查找，这方面的代表就是<code>array</code>，<code>vector</code>。
<code>array</code>是对原始数组的封装，并且解决了传递数组变成指针这样的问题，但是缺点是它的大小是固定的，适合用在数据量已知的情况。而<code>vector</code>又是对<code>array</code>的增强，不仅能完成所有<code>array</code>的操作，并且大小可变，所以绝大部分情况下，选择<code>vector</code>都是理想的选择。
<img src=https://cdn.nlark.com/yuque/0/2022/jpeg/29458474/1658015351475-f6a5189b-7331-4173-80b4-1a1f83f25f7d.jpeg loading=lazy>
无序列表的元素是单独存储的，相互之间用指针来查找相邻元素，由于指针可以轻易修改指向的指，所以对相邻元素的修改就变得很快捷。同样的道理，查找相邻元素只能靠指针跳转，查找某个值需要从一个指针开始查找，一次跳转一条数据，直到找到目标或者没有数据为止。所以无序列表的优势是快速地删除和插入新数据，不适合查找，其代表有<code>list</code>，<code>forward_list</code>。显然，有序列表和无序列表是互补的，我们在实际项目中，应该<strong>根据数据的操作来确定选择哪种容器。</strong>
<img src=https://cdn.nlark.com/yuque/0/2022/jpeg/29458474/1658015352400-93e48503-009d-41bb-89b1-4a50bc1ca3d1.jpeg loading=lazy></p><p><strong>映射则融合了有序列表和无序列表的优点，既可以快速插入和删除，又可以快速查找</strong>。为了满足各种使用场景，C++提供了<code>map</code>，<code>multimap</code>，<code>unordered_map</code>，<code>unordered_multimap</code>。从名字上就能看出来它们的差别。为了直观，我直接列了一个表</p><div class=table-wrapper><table><thead><tr><th></th><th>是否排序</th><th>是否支持相同值</th><th>速度</th></tr></thead><tbody><tr><td>unordered_map</td><td>❌</td><td>❌</td><td>❤️❤️❤️❤️</td></tr><tr><td>map</td><td>✅</td><td>❌</td><td>❤️❤️</td></tr><tr><td>multimap</td><td>✅</td><td>✅</td><td>❤️</td></tr><tr><td>unordered_multimap</td><td>✅</td><td>✅</td><td>❤️❤️❤️</td></tr></tbody></table></div><p>映射存储的是两个值，不同的类型实现方式不一样。由于<code>map</code>是需要排序的，所以通常它的实现是一种平衡二叉树，键就是它排序的依据。
<img src=https://cdn.nlark.com/yuque/0/2022/jpeg/29458474/1658015140161-206f2bf1-345d-4fb7-9b6d-50fbfcb81b2e.jpeg loading=lazy>
而<code>unordered_map</code>是不需要排序的，所以它的实现通常是哈希表，即根据哈希函数的确定索引位置继而确定存储位置。
<img src=https://cdn.nlark.com/yuque/0/2022/jpeg/29458474/1658015142087-4460ed23-40be-441e-8649-c40eb78dfc9a.jpeg loading=lazy>
综上，容器类提供了一种操作多个同类型数据的接口，开发者通过对容器类方法的调用，可以实现对容器内数据的增删改查。大部分情况下，<code>vector</code>都是靠谱的选择，它提供了全功能的数据操作接口，支持动态长度，索引查询，并且简单高效。如果需要频繁地插入或者删除操作，也可以考虑<code>list</code>或者<code>forward_list</code>。<code>map</code>可以让数据保持有序，需要更快的速度而不是排序的话<code>unorderer_map</code>是更好的选择，如果相同值会出现多次就可以使用对应的<code>multi</code>版本。另外容器类也是很好的数据结构学习资源，C++的容器类几乎提供了数据结构中所有的形式，对数据结构越熟悉选择的容器类就越完美。</p><h3 id=算法>算法</h3><p>之所以将算法放在容器类后面，是因为算法大部分是对容器类操作的加强，算法都定义在<code>algorithm</code>文件头里。这些算法都是短小精悍的，可以大大增加代码可读性，并且妥善处理了很多容易遗忘的边界问题。功能上可以分为增删改查几种操作，可以在实际有需要的时候在查看文档，具体可以参阅<a class=link href=https://cplusplus.com/reference/algorithm/ target=_blank rel=noopener>这里</a></p><h3 id=智能指针>智能指针</h3><p>很早以前，我对智能指针的态度不是很好。因为刚开始学习C++时我就知道，不能单独使用指针，要把指针封装在类里，利用类的构造函数和析构函数管理指针，也就是<code>RAII</code>。最开始我以为这就够了,直到我遇到下面这种情况</p><div class=highlight><div style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">18
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">19
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">20
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">21
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">22
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">23
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">24
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">25
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">26
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#000;font-weight:700>public</span><span style=color:#000;font-weight:700>:</span>
</span></span><span style=display:flex><span>    Ptr()<span style=color:#000;font-weight:700>:</span>p{ <span style=color:#000;font-weight:700>new</span> <span style=color:#458;font-weight:700>int</span> } {}
</span></span><span style=display:flex><span>    <span style=color:#000;font-weight:700>~</span>Ptr() {
</span></span><span style=display:flex><span>        <span style=color:#000;font-weight:700>delete</span> p;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#458;font-weight:700>int</span><span style=color:#000;font-weight:700>&amp;</span> get() {
</span></span><span style=display:flex><span>        <span style=color:#000;font-weight:700>return</span> <span style=color:#000;font-weight:700>*</span>p;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#458;font-weight:700>void</span> <span style=color:#900;font-weight:700>set</span>(<span style=color:#000;font-weight:700>const</span> <span style=color:#458;font-weight:700>int</span> value) {
</span></span><span style=display:flex><span>        <span style=color:#000;font-weight:700>*</span>p <span style=color:#000;font-weight:700>=</span> value;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>private</span><span style=color:#000;font-weight:700>:</span>
</span></span><span style=display:flex><span>    <span style=color:#458;font-weight:700>int</span><span style=color:#000;font-weight:700>*</span> p;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#458;font-weight:700>void</span> <span style=color:#900;font-weight:700>use</span>(Ptr p) {
</span></span><span style=display:flex><span>    <span style=color:#998;font-style:italic>//传进来的是复制构造出来的p&#39;,函数返回后p&#39;被销毁啦，两个指针指向的地址被回收，外面的p指针成为了野指针
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>}
</span></span><span style=display:flex><span><span style=color:#458;font-weight:700>int</span> <span style=color:#900;font-weight:700>main</span>() {
</span></span><span style=display:flex><span>    Ptr p;
</span></span><span style=display:flex><span>    p.set(<span style=color:#099>1</span>);
</span></span><span style=display:flex><span>    use(p); <span style=color:#998;font-style:italic>//p按值传递，调用了Ptr的复制构造函数，构造出了新对象p&#39;,它的指针和p的指针指向同一个地方
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>    std<span style=color:#000;font-weight:700>::</span>cout <span style=color:#000;font-weight:700>&lt;&lt;</span> p.get() <span style=color:#000;font-weight:700>&lt;&lt;</span> std<span style=color:#000;font-weight:700>::</span>endl; <span style=color:#998;font-style:italic>//p已经被销毁了，访问p的地址非法
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>    <span style=color:#000;font-weight:700>return</span> <span style=color:#099>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div><p>调用<code>use</code>时，变量<code>p</code>被拷贝，也就出现了两个指针同时指向一块内存地址的情况。<code>use</code>函数执行完后，它的参数<code>p</code>被回收。也就是调用了<code>Ptr</code>的析构函数，也就是两个指针指向的地址被回收。所以24行调用<code>get</code>读取那个已经被回收了的地址就是非法操作，程序崩溃。
这可能是新手比较常遇到的一个问题，当然，解决这个问题也很简单，还用不到智能指针，只需要将函数<code>use</code>的参数改为引用类型就可以了，因为引用只是别名，不会产生新的指针，这也是我在类型系统篇中极力推荐引用为首选参数类型的原因之一。对于此例，数据不大，直接重写复制构造函数，重新申请一块内存也是一种思路。
此例中用到Ptr的地方只有一个，实际项目中Ptr往往需要用到很多次，我们不能保证不会出现忘记使用引用类型的情况，这种情况下重新申请内存也不适用，所以这个时候就需要智能指针来帮忙了。
现在思考另一种情况，某些操作我们不得不暴露出我们的指针供外部使用，随着业务的嵌套和调用链增加，很多时候会忘记或者不确定在什么时候调用<code>delete</code>释放内存。这也是用智能指针的一个场景。以上两种情况都是需要分享指针，对应智能指针中的<code>shared_ptr</code>。
<code>shared_ptr</code>顾名思义，它可以帮助开发者完成指针共享的问题，并且完美解决提前释放，不知何时释放，谁负责释放的问题。它的对应关系是一对多，一个实际的内存可以被多个<code>shared_ptr</code>共享
<img src=https://cdn.nlark.com/yuque/0/2022/jpeg/29458474/1658146077740-b934d6d5-fc6e-4cff-9863-4e263b5c3848.jpeg loading=lazy>
另外一种场景是我们希望<strong>自始至终某个指针某个时刻只属于一个对象</strong>，外部想要使用它要么通过拥有该指针的对象方法，要么把指针的所有权转移到自己身上，这种场景对应智能指针中的<code>unique_ptr</code>。
<img src=https://cdn.nlark.com/yuque/0/2022/jpeg/29458474/1658147416713-1b6a7866-1cd8-4be6-b2dc-bdfe41db69d6.jpeg loading=lazy>
<code>unique_ptr</code>的对应关系是一对一，无论哪个时刻，只能有一个管理者拥有指针，也就只能由它负责释放了。假如想转移这种对应关系，只能通过<code>std::move</code>操作，不过这个操作之后，原先对象的指针就失效了，它也不再负责管理，所有的任务移交给了新的对象。这种特性特别适合资源敏感型的应用。</p><h3 id=线程库>线程库</h3><p>除了内存，线程是开发中另一个重要的课题。线程的难点在于不仅要管理线程对象，还要管理线程对象管理的资源，并且保证线程间数据同步。当然标准库已经做得足够好了，我们需要理解的是使用场景的问题。线程库主要包括线程对象<code>thread</code>，条件对象<code>condition_variable</code>，锁对象<code>mutex</code>。
使用<code>thread</code>可以很方便地把程序写成多线程，只需要三步：</p><div class=highlight><div style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#458;font-weight:700>void</span> <span style=color:#900;font-weight:700>plus</span>(<span style=color:#458;font-weight:700>int</span> a,<span style=color:#458;font-weight:700>int</span> b){ <span style=color:#998;font-style:italic>//第一步：定义线程中要运行的函数
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>    std<span style=color:#000;font-weight:700>::</span>cout<span style=color:#000;font-weight:700>&lt;&lt;</span><span style=color:#d14>&#34;running at sub thread&#34;</span><span style=color:#000;font-weight:700>&lt;&lt;</span>std<span style=color:#000;font-weight:700>::</span>endl;
</span></span><span style=display:flex><span>    std<span style=color:#000;font-weight:700>::</span>cout<span style=color:#000;font-weight:700>&lt;&lt;</span><span style=color:#d14>&#34;a + b = &#34;</span><span style=color:#000;font-weight:700>&lt;&lt;</span>a<span style=color:#000;font-weight:700>+</span>b<span style=color:#000;font-weight:700>&lt;&lt;</span>std<span style=color:#000;font-weight:700>::</span>endl;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#458;font-weight:700>int</span> <span style=color:#900;font-weight:700>main</span>(){
</span></span><span style=display:flex><span>    std<span style=color:#000;font-weight:700>::</span><span style=color:#000;font-weight:700>thread</span> <span style=color:#000;font-weight:700>thread</span>{plus,<span style=color:#099>1</span>,<span style=color:#099>1</span>}; <span style=color:#998;font-style:italic>//第二步，定义std::thread对象，将函数作为参数
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>    std<span style=color:#000;font-weight:700>::</span>cout<span style=color:#000;font-weight:700>&lt;&lt;</span><span style=color:#d14>&#34;continue running at main thread&#34;</span><span style=color:#000;font-weight:700>&lt;&lt;</span>std<span style=color:#000;font-weight:700>::</span>endl;
</span></span><span style=display:flex><span>    <span style=color:#000;font-weight:700>thread</span>.join(); <span style=color:#998;font-style:italic>//第三步调用线程对象的join函数或者detach函数
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>    std<span style=color:#000;font-weight:700>::</span>cout<span style=color:#000;font-weight:700>&lt;&lt;</span><span style=color:#d14>&#34;sub thread finished!&#34;</span><span style=color:#000;font-weight:700>&lt;&lt;</span>std<span style=color:#000;font-weight:700>::</span>endl;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#998;font-style:italic>//输出
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic>//	continue running at main thread
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic>//	running at sub thread
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic>// 	a + b = 2
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic>// 	sub thread finished!
</span></span></span></code></pre></td></tr></table></div></div><p>难点在线程间通信，也就是解决两个问题</p><ol><li>线程1更新了变量v的值</li><li>线程2马上能读取到正确的变量v的值，即线程1更新的那个最新值</li></ol><p>为了协调这两个过程，就出现了锁对象<code>mutex</code>和条件对象<code>condition_variable</code>。锁对象<code>mutex</code>保证变量按照正确的顺序更改。条件对象<code>condition_variable</code>保证更改能被其他线程监听到。</p><div class=highlight><div style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">18
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">19
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">20
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">21
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">22
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">23
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">24
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">25
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">26
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">27
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">28
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">29
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">30
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">31
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">32
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">33
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">34
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">35
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#458;font-weight:700>int</span> a,b;
</span></span><span style=display:flex><span><span style=color:#458;font-weight:700>bool</span> ready <span style=color:#000;font-weight:700>=</span> <span style=color:#0086b3>false</span>;
</span></span><span style=display:flex><span>std<span style=color:#000;font-weight:700>::</span>mutex mux;
</span></span><span style=display:flex><span>std<span style=color:#000;font-weight:700>::</span>condition_variable con;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#458;font-weight:700>void</span> <span style=color:#900;font-weight:700>plus</span>() {
</span></span><span style=display:flex><span>    std<span style=color:#000;font-weight:700>::</span>cout <span style=color:#000;font-weight:700>&lt;&lt;</span> <span style=color:#d14>&#34;running at sub thread&#34;</span> <span style=color:#000;font-weight:700>&lt;&lt;</span> std<span style=color:#000;font-weight:700>::</span>endl;
</span></span><span style=display:flex><span>    <span style=color:#998;font-style:italic>//因为我们要读取ready的最新值，所以要用锁保证读取结果的有效性
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>    std<span style=color:#000;font-weight:700>::</span>unique_lock<span style=color:#000;font-weight:700>&lt;</span>std<span style=color:#000;font-weight:700>::</span>mutex<span style=color:#000;font-weight:700>&gt;</span> guard{ mux };
</span></span><span style=display:flex><span>    <span style=color:#000;font-weight:700>if</span> (<span style=color:#000;font-weight:700>!</span>ready) {
</span></span><span style=display:flex><span>        <span style=color:#998;font-style:italic>//数据没准备好，休息一下！
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>        con.wait(guard); 
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#998;font-style:italic>//这里就可以正确读变量a,b了
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>    std<span style=color:#000;font-weight:700>::</span>cout <span style=color:#000;font-weight:700>&lt;&lt;</span> <span style=color:#d14>&#34;a + b =&#34;</span> <span style=color:#000;font-weight:700>&lt;&lt;</span> a <span style=color:#000;font-weight:700>+</span> b <span style=color:#000;font-weight:700>&lt;&lt;</span> std<span style=color:#000;font-weight:700>::</span>endl;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#458;font-weight:700>int</span> <span style=color:#900;font-weight:700>main</span>() {
</span></span><span style=display:flex><span>    std<span style=color:#000;font-weight:700>::</span><span style=color:#000;font-weight:700>thread</span> <span style=color:#000;font-weight:700>thread</span>{ plus};
</span></span><span style=display:flex><span>    std<span style=color:#000;font-weight:700>::</span>cout <span style=color:#000;font-weight:700>&lt;&lt;</span> <span style=color:#d14>&#34;continue running at main thread&#34;</span> <span style=color:#000;font-weight:700>&lt;&lt;</span> std<span style=color:#000;font-weight:700>::</span>endl;
</span></span><span style=display:flex><span>    std<span style=color:#000;font-weight:700>::</span>cout <span style=color:#000;font-weight:700>&lt;&lt;</span> <span style=color:#d14>&#34;input a = &#34;</span>;
</span></span><span style=display:flex><span>    std<span style=color:#000;font-weight:700>::</span>cin <span style=color:#000;font-weight:700>&gt;&gt;</span> a;
</span></span><span style=display:flex><span>    std<span style=color:#000;font-weight:700>::</span>cout <span style=color:#000;font-weight:700>&lt;&lt;</span> <span style=color:#d14>&#34;input b = &#34;</span>;
</span></span><span style=display:flex><span>    std<span style=color:#000;font-weight:700>::</span>cin <span style=color:#000;font-weight:700>&gt;&gt;</span> b;
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#998;font-style:italic>//数据准备好了，该通知子线程干活了，用大括号是因为想让锁因为guard的销毁即使释放，从未保证plus里面能重新获得锁
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>        std<span style=color:#000;font-weight:700>::</span>unique_lock<span style=color:#000;font-weight:700>&lt;</span>std<span style=color:#000;font-weight:700>::</span>mutex<span style=color:#000;font-weight:700>&gt;</span> guard{ mux };
</span></span><span style=display:flex><span>        <span style=color:#998;font-style:italic>//更新数据
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>        ready <span style=color:#000;font-weight:700>=</span> <span style=color:#0086b3>true</span>;
</span></span><span style=display:flex><span>        <span style=color:#998;font-style:italic>//通知
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>        con.notify_all();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#000;font-weight:700>thread</span>.join();
</span></span><span style=display:flex><span>    std<span style=color:#000;font-weight:700>::</span>cout <span style=color:#000;font-weight:700>&lt;&lt;</span> <span style=color:#d14>&#34;sub thread finished!&#34;</span> <span style=color:#000;font-weight:700>&lt;&lt;</span> std<span style=color:#000;font-weight:700>::</span>endl;
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div><p>多线程另一个需要注意的问题就是死锁。死锁的前提是有两个锁</p><ol><li>线程1得到了锁a，还想得锁b</li><li>线程2得到了锁b，还想得锁a</li></ol><p>然后，再加上一个前提：某一时刻，只有一个线程能拥有某个锁，就不难得出以下结论：线程a，b除非某一个放弃已得的锁，不然两个线程都会因为没得到需要的锁而一直死等，形成死锁。同时解决死锁的思路也呼之欲出：既然一个得了a，一个得了b，而锁同一时间只能被一个线程得到，那么所有线程都按先得a，再得b的顺序来就不会有锁被占用的问题了。另一个思路则可以从放弃上入手，既然都得不到，那么接下来的任务也做不了，不如直接放弃已经得到的，所以可以考虑使用<code>timed_mutex</code>。</p><h3 id=其他>其他</h3><p>还有很多常用的库，如字符串<code>string</code>，时间<code>chrono</code>，还有在定义函数变量时常用的<code>functional</code>,异常<code>exception</code>，更多的内容可以在<a class=link href=https://cplusplus.com/reference/ target=_blank rel=noopener>cplusplus</a>找的参考。</p><h3 id=总结>总结</h3><p>总的来说，标准库提供了一个展现C++语言能力的平台：帮助开发者更好更快完成开发任务的同时，还能启迪开发者实现更好的抽象和实践。如我就从标准库中学到了更规范地定义函数参数，更好的封装，以及其他好的思路。学习标准库不仅更好地掌握了语言本身，还掌握了更全面地分析问题，解决问题的方法，是值得花费一段时间学习的。
容器类是几乎所有项目都会用到的，也是比较好掌握的，主要可以从数据结构方面对照学习；智能指针则是处理指针问题的好帮手；线程相关的库是比较难掌握的，关键是要想明白使用场景和极端情况下的边界问题。很多时候边界问题可能不那么直观。如线程要求获得锁的情况就分为：锁空闲，锁被其他线程占有，锁被自己占有。不同的边界对于不同的锁，预期结果也是不同的，只有在明确场景的情况下，才能更好地理清锁的关系，从而解决好问题。
最好的学习还是在实践中主动使用。对于我，通常在遇到新问题的时候会先查查标准库有没有相应的库，有的话就是学习这个库的好时机。可以先概览库的定义和解决的问题，然后分析它提供的类，函数，对象等，再将自己的理解转换为项目中的代码，最后在实际效果中检验和修正想法，完成库的学习。</p></section><footer class=article-footer><section class=article-tags><a href=/tags/%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/>学习指南</a>
<a href=/tags/c++/>C++</a></section></footer></article><aside class=related-content--wrapper><h2 class=section-title>相关文章</h2><div class=related-content><div class="flex article-list--tile"><article><a href=/post/%E7%8E%B0%E4%BB%A3C++%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97-%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F.html><div class=article-details><h2 class=article-title>现代C++学习指南-类型系统</h2></div></a></article><article><a href=/post/%E7%8E%B0%E4%BB%A3C++%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97-%E6%96%B9%E5%90%91%E7%AF%87.html><div class=article-details><h2 class=article-title>现代C++学习指南-方向篇</h2></div></a></article><article><a href=/post/Android-NDk%E5%BC%80%E5%8F%91%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5.html><div class=article-details><h2 class=article-title>Android-NDk开发——基本概念</h2></div></a></article><article><a href=/post/Linux%E6%89%B9%E9%87%8F%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E2%80%94%E2%80%94%E5%9F%BA%E4%BA%8Efind,xargs.html><div class=article-details><h2 class=article-title>Linux批量文件操作——基于find,xargs</h2></div></a></article><article><a href=/post/%E7%94%A8%E7%BA%AFHTML%EF%BC%8CJS%EF%BC%8CCSS%E5%AE%9E%E7%8E%B0%E6%A8%AA%E5%90%91%E6%BB%9A%E5%8A%A8%E6%A0%87%E7%AD%BE%E9%A1%B5.html><div class=article-details><h2 class=article-title>用纯HTML，JS，CSS实现横向滚动标签页</h2></div></a></article></div></div></aside><footer class=site-footer><section class=copyright>&copy;
2020 -
2022 低头沉思</section><section class=powerby>Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a><br>主题 <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.14.0>Stack</a></b> 由 <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a> 设计</section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"></button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z+KMkF24hUW8WePSA9HM=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.js defer></script>
<script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>