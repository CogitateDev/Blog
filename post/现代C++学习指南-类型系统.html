<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width"><meta name=theme-color content="#584394" media="(prefers-color-scheme: light)"><meta name=generator content="Hugo 0.104.3"><link rel="shortcut icon" type=image/x-icon href=/images/icons/favicon.ico><link rel=icon type=image/x-icon href=/images/icons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=/images/icons/favicon_16x16.png><link rel=icon type=image/png sizes=32x32 href=/images/icons/favicon_32_32.png><link rel=apple-touch-icon sizes=180x180 href=/imgs/icons/apple_touch_icon.png><meta itemprop=name content="现代C++学习指南-类型系统"><meta itemprop=description content="现代C++学习指南-类型系统"><meta itemprop=datePublished zgotmplz><meta itemprop=dateModified zgotmplz><meta itemprop=image content="https://hongui.github.io/images/logo.png"><meta itemprop=keywords content="学习指南,C++"><meta property="og:type" content="article"><meta property="og:title" content="现代C++学习指南-类型系统"><meta property="og:description" content="现代C++学习指南-类型系统"><meta property="og:image" content="/images/logo.png"><meta property="og:image:width" content="312"><meta property="og:image:height" content="312"><meta property="og:image:type" content="image/jpeg/png/svg/jpg"><meta property="og:url" content="https://hongui.github.io/post/%E7%8E%B0%E4%BB%A3C++%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97-%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F.html"><meta property="og:site_name" content="低头沉思"><meta property="og:locale" content="zh-CN"><meta property="article:author" content="hongui"><meta property="article:published_time" content="2022-06-26 11:11:59 +0800 +0800"><meta property="article:modified_time" content="2022-06-26 11:11:59 +0800 +0800"><link type=text/css rel=stylesheet href=https://unpkg.com/@fortawesome/fontawesome-free@6.1.2/css/all.min.css><link type=text/css rel=stylesheet href=https://unpkg.com/animate.css@3.1.1/animate.min.css><link rel=stylesheet href=/css/main.min.647dda56ba9378f49e35b85d48cc6f401ba3e3395b9087ced0be62a8287bf5c3.css><style type=text/css>.post-footer,.flinks-list-footer hr:after{content:"~ 我可是有底线的哟 ~"}</style><script class=next-config data-name=page type=application/json>{"comments":false,"isHome":false,"isPage":true,"path":"%E7%8E%B0%E4%BB%A3C++%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97-%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F.html","permalink":"https://hongui.github.io/post/%E7%8E%B0%E4%BB%A3C++%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97-%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F.html","title":"现代C++学习指南-类型系统"}</script><script type=text/javascript>document.addEventListener("DOMContentLoaded",()=>{var e=document.createElement("script");e.charset="UTF-8",e.id="LA_COLLECT",e.src="https://sdk.51.la/js-sdk-pro.min.js",e.async="true",e.onload=function(){LA.init({id:"JrJFibzvtRuObfi1",ck:"JrJFibzvtRuObfi1",autoTrack:!0})},document.head.appendChild(e)})</script><title>现代C++学习指南-类型系统 - 低头沉思</title><noscript><link rel=stylesheet href=/css/noscript.css></noscript></head><body itemscope itemtype=http://schema.org/WebPage><div class=headband></div><main class=main><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-brand-container><div class=site-nav-toggle><div class=toggle aria-label=切换导航栏 role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div></div><div class=site-meta><a href=/ class=brand rel=start><i class=logo-line></i><h1 class=site-title>低头沉思</h1><i class=logo-line></i></a><p class=site-subtitle itemprop=description>保持思考</p></div><div class=site-nav-right><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class=site-nav><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href=/ class=hvr-icon-pulse rel=section><i class="fa fa-home hvr-icon"></i>首页</a></li><li class="menu-item menu-item-archives"><a href=/ class=hvr-icon-pulse rel=section><i class="fa fa-archives hvr-icon"></i>归档
<span class=badge>14</span></a></li><li class="menu-item menu-item-tags"><a href=/tags/ class=hvr-icon-pulse rel=section><i class="fa fa-tags hvr-icon"></i>标签</a></li><li class="menu-item menu-item-about"><a href=/about.html class=hvr-icon-pulse rel=section><i class="fa fa-user hvr-icon"></i>关于</a></li><li class="menu-item menu-item-search"><a role=button class="popup-trigger hvr-icon-pulse"><i class="fa fa-search fa-fw hvr-icon"></i>搜索</a></li></ul></nav><div class=search-pop-overlay><div class="popup search-popup"><div class=search-header><span class=search-icon><i class="fa fa-search"></i></span><div class=search-input-container><input autocomplete=off autocapitalize=off maxlength=80 placeholder=搜索... spellcheck=false type=search class=search-input></div><span class=popup-btn-close role=button><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class=search-result-icon><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></div><div class="toggle sidebar-toggle" role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div><aside class=sidebar><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class=sidebar-nav><li class=sidebar-nav-toc>文章目录</li><li class=sidebar-nav-overview>站点概览</li></ul><div class=sidebar-panel-container><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><nav id=TableOfContents><ul><li><ul><li><a href=#写在前面>写在前面</a></li><li><a href=#类型系统>类型系统</a></li><li><a href=#类型>类型</a></li><li><a href=#变量定义>变量定义</a></li><li><a href=#变量初始化>变量初始化</a></li><li><a href=#函数>函数</a></li><li><a href=#类>类</a></li><li><a href=#总结>总结</a></li></ul></li></ul></nav></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop=author itemscope itemtype=http://schema.org/Person><img class=site-author-image itemprop=image alt=hongui src=/images/logo.png><p class=site-author-name itemprop=name>hongui</p><div class=site-description itemprop=description>记录生活所思所见。</div></div><div class="site-state-wrap site-overview-item animated"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/><span class=site-state-item-count>14</span>
<span class=site-state-item-name>日志</span></a></div><div class="site-state-item site-state-categories"><a href=/categories/><span class=site-state-item-count>7</span>
<span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/><span class=site-state-item-count>17</span>
<span class=site-state-item-name>标签</span></a></div></nav></div><div class="links-of-social site-overview-item animated"><span class=links-of-social-item><a href=https://github.com/hongui title="Github → https://github.com/hongui" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-github fa-fw hvr-icon"></i></a></span></div><div class="cc-license animated" itemprop=license><a href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh class=cc-opacity rel=noopener target=_blank title=共享知识><img src=/imgs/cc/big/by_nc_sa.svg alt=共享知识></a></div><div class="links-of-blogroll site-overview-item animated"><div class=links-of-blogroll-title><i class="fa fa-globe fa-fw"></i>友情链接</div><ul class=links-of-blogroll-list><li class=links-of-blogroll-item><a href=https://gitee.com/hugo-next/hugo-theme-next title=https://gitee.com/hugo-next/hugo-theme-next target=_blank>Hugo-NexT</a></li></ul></div></div></div></div><div class=sidebar-card-widget><div class=item-headline><i class="fas fa-chart-line"></i>
<span>网站资讯</span></div><div class=siteinfo><div class=siteinfo-item><div class=item-name><i class="fa-solid fa-calendar-check"></i>已运行：</div><div class=item-count id=runTimes data-publishdate=2021/03/21T15:56:53+08:00></div></div><div id=la-siteinfo-widget style=display:none><script id=LA-DATA-WIDGET crossorigin=anonymous src="https://v6-widget.51.la/v6/JrJFibzvtRuObfi1/quote.js?theme=0&col=true&f=12&display=0,0,0,1,0,1,1,1"></script></div><div class=siteinfo-item><div class=item-name><i class="fa fa-user-plus"></i>今日访问：</div><div class=item-count id=today_site_pv></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-user-clock"></i>昨日访问：</div><div class=item-count id=yesterday_site_pv></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-arrows-down-to-people"></i>本月访问：</div><div class=item-count id=month_site_pv></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-users"></i>总访问量：</div><div class=item-count id=total_site_pv></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-font"></i>总字数：</div><div class=item-count id=wordsCount data-count=2824></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-mug-hot"></i>阅读约：</div><div class=item-count id=readTimes data-times=21></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-clock-rotate-left"></i>最后更新于：</div><div class=item-count id=last-push-date data-lastpushdate=2022/07/20T22:15:05+08:00></div></div></div></div></aside><div class=sidebar-dimmer></div></header><div class=tool-buttons><a id=goto-comments class="button goto-comments" href=#comments title=直达评论><i class="fas fa-comments"></i></a><div id=switch-theme class=button title=深浅模式切换><i class="fas fa-adjust"></i></div><div class=back-to-top role=button title=返回顶部><i class="fa fa-arrow-up"></i>
<span>0%</span></div></div><div class=reading-progress-bar></div><a role=button class="book-mark-link book-mark-link-fixed"></a>
<a href=https://github.com/hongui rel="noopener external nofollow noreferrer" target=_blank title="Follow me on GitHub" class="exturl github-corner"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115h15l12 27L250 250V0z"/><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentcolor" style="transform-origin:130px 106px" class="octo-arm"/><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4l13.9-13.8C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8z" fill="currentcolor" class="octo-body"/></svg></a><noscript><div class=noscript-warning>Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner post posts-expand"><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://hongui.github.io/post/%E7%8E%B0%E4%BB%A3C++%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97-%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F.html><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/images/logo.png"><meta itemprop=name content="hongui"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="hongui"><meta itemprop=description content="记录生活所思所见。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="现代C++学习指南-类型系统"><meta itemprop=description content="现代C++学习指南-类型系统"></span><header class=post-header><h1 class=post-title itemprop="name headline">现代C++学习指南-类型系统</h1><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar"></i></span>
<span class=post-meta-item-text>发表于：</span>
<time title="发表于：2022-06-26 11:11:59 +0800 +0800" itemprop="dateCreated datePublished" datetime="2022-06-26 11:11:59 +0800 +0800">2022/06/26</time></span>
<span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-folder-open"></i></span>
<span class=post-meta-item-text>分类于：</span>
<span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/c++ itemprop=url rel=index><span itemprop=name>C++</span></a></span></span></div><div class=post-meta-items><span class=post-meta-item title=字数><span class=post-meta-item-icon><i class="far fa-file-word"></i></span>
<span class=post-meta-item-text>字数：</span><span>269</span></span>
<span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="far fa-eye"></i></span>
<span class=post-meta-item-text>浏览：</span>
<span id=waline-pageview-count data-path=/post/%E7%8E%B0%E4%BB%A3C++%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97-%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F.html><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class="post-body autonumber" itemprop=articleBody><blockquote><p>在前一篇，我们提供了一个方向性的指南，但是学什么，怎么学却没有详细展开。本篇将在前文的基础上，着重介绍下怎样学习C++的类型系统。</p></blockquote><h3 id=写在前面>写在前面</h3><p>在进入类型系统之前，我们应该先达成一项共识——尽可能使用C++的现代语法。众所周知，出于兼容性的考虑，C++中很多语法都是合法的。但是随着新版本的推出，有些语法可能是不推荐或者是需要避免使用的。所以本篇也尽可能采用推荐的语法形式（基于C++11或以上版本），这也是现代C++标题的含义。</p><p>采用现代语法有两点好处。其一，现代语法可以编译出更快更健壮的代码。编译器也是随着语言的发展而发展的，现代语法可以在一定程度上帮助编译器做更好的优化。其二，现代语法通常更简洁，更直观，也更统一，有助于增强可读性和可维护性。
明确了这点后，让我们一起踏入现代C++的大门吧。</p><h3 id=类型系统>类型系统</h3><p><strong>程序是一种计算工具，根据输入，和预定义的计算方法，产生计算结果</strong>。当程序运行起来后，这三者都需要在内存中表示成合适的值才能让程序正常工作，负责解释的这套工具就是类型系统。数字，字符串，键盘鼠标事件等都是数据，而且在内存中实际存在的形式也是一样的，但是按我们人类的眼光来看的话，对它们的处理是不一样的。数字能进行加减乘除等算术运算，但是对字符串进行算术运算就没有意义，而键盘鼠标的值通常只是读取，不进行计算的。正是由于这些差异，编程语言的第一个任务就是需要定义一套类型系统，告诉计算机怎样处理内存中的数据。
为了让编程语言尽可能简单，编程语言一般把类型系统分为两步实现，一部分是编译器，另一部分是类型。编译器那部分负责将开发者的代码解释成合适的形式，以便可以高效，准确在内存中表示。类型部分则定义一些编译器能处理的类型，以便开发者可以找到合适的数据来完成输入输出的表示和计算方法的描述。这两者相辅相成，相互成就。
类型作为类型系统的重要表现形式，在编程语言中的重要性也就不言而喻了。如果把写程序看成是搭积木的话，那么程序的积木就是类型系统。类型系统是开发者能操作的最小单位，它限制了开发者的操作规则，但是提供了无限的可能。C++有着比积木更灵活的类型系统。</p><h3 id=类型>类型</h3><p>:::info
类型是编程语言的最小单位，任何一句代码都是一种内存使用形式。
:::
而谈到C++的类型也就不得不谈到它的三种类型表现形式——普通类型，指针，引用。它们是三种不同的内存使用和解释形式，也是C++的最基础的形式。和大部分编程语言不同，C++对内置类型没有做特权处理，只要开发者愿意，所有的类型都可以有一致的语法形式（通过运算符重载），所以下面关于类型的举例适合所有的类型。
普通类型就是没有修饰的类型，如<code>int</code>,<code>long</code>,<code>double</code>等。它们是按值传递的，也就是赋值和函数传参是拷贝一份值，对拷贝后的值进行操作，不会再影响到老值。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> a<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>; <span style=color:#75715e>//老值,存在地址1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> b<span style=color:#f92672>=</span>a; <span style=color:#75715e>//新值，存在地址2
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>b<span style=color:#f92672>=</span><span style=color:#ae81ff>2</span>; <span style=color:#75715e>//改变新值，改变地址2
</span></span></span><span style=display:flex><span><span style=color:#75715e>//此时a还是1，b变成了2
</span></span></span></code></pre></div><p><img src=https://cdn.nlark.com/yuque/0/2022/jpeg/29458474/1656843295159-ac2e516f-5226-4a08-9b72-d38d138627f6.jpeg alt></p><p>那假如我们需要修改老值呢，有两种途径，一种是指针，另一种则是引用。
指针是C/C++里面的魔法，一切皆可指针。指针包含两个方面，一方面它是指一块内存，另一方面它可以指允许对这块内存进行的操作。指针的值是一块内存地址，操作指针，操作的是它指向的那块地址。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> a<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>; <span style=color:#75715e>//老值,存在地址1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>int</span><span style=color:#f92672>*</span> b<span style=color:#f92672>=&amp;</span>a; <span style=color:#75715e>//&amp;代表取地址，从右往左读，取a的地址——地址1，存在地址2
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#f92672>*</span>b<span style=color:#f92672>=</span><span style=color:#ae81ff>2</span>; <span style=color:#75715e>//*是解引用，意思是把存在地址2(b)的值取出来，并把那个地址（地址1）的值改成2
</span></span></span><span style=display:flex><span><span style=color:#75715e>//此时a，*b变成了2
</span></span></span></code></pre></div><p><img src=https://cdn.nlark.com/yuque/0/2022/jpeg/29458474/1656842930791-9b5ed632-8d54-466a-960e-dfb58f5609c5.jpeg alt>
引用则是指针的改进版，引用能避免无效引用，不过引用不能重设，比指针缺少一定的灵活性。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> a<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>; <span style=color:#75715e>//老值,存在地址1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>int</span><span style=color:#f92672>&amp;</span> b<span style=color:#f92672>=</span>a; <span style=color:#75715e>//&amp;出现在变量声明的位置，代表该变量是引用变量，引用变量必须在声明时初始化
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>b<span style=color:#f92672>=</span><span style=color:#ae81ff>2</span>; <span style=color:#75715e>//可以像普通变量一样操作引用变量，同时，对它的操作也会反应到原始对象上
</span></span></span><span style=display:flex><span><span style=color:#75715e>//此时a，b变成了2
</span></span></span></code></pre></div><h3 id=变量定义>变量定义</h3><p>类型仅仅是一种语法定义，而要真正使用这种定义，我们需要用类型来定义变量，即变量定义。
C++变量定义是以下形式：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-cpp data-lang=cpp><span style=display:flex><span>type name[{initial_value}]
</span></span></code></pre></div><p>这里的关键在于<code>type</code>。<code>type</code>是类型和限定符的组合。看下面的例子：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> a; <span style=color:#75715e>//普通整型
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>int</span><span style=color:#f92672>*</span> b; <span style=color:#75715e>//类型是int和*的组合，组成了整型指针
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span><span style=color:#f92672>*</span> c; <span style=color:#75715e>//从右往左读，*是指针，const int是常量整型，组成了指向常量整型的指针类型
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>const</span> d; <span style=color:#75715e>//也是从右往左读，const是常量，后面是指针，说明这个指针是常量指针，指向最左边的int，组成常量指针指向整型
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>int</span><span style=color:#f92672>&amp;</span> e<span style=color:#f92672>=</span>a; <span style=color:#75715e>//类型是int和&amp;的组合，组成了整型引用
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>constexpr</span> <span style=color:#66d9ef>int</span> f<span style=color:#f92672>=</span>a<span style=color:#f92672>+</span>e; <span style=color:#75715e>//constexpr代表这个变量需要在编译期求值，并且不再可变。
</span></span></span></code></pre></div><p>以上，基本就是变量定义的所有形式了，类型确定了变量的基本属性，而限定符限定了变量的使用范围。
定义变量也是按照这个步骤进行，<strong>首先确定我们需要什么类型的变量，其次再进一步确定是否需要对这个变量添加限定，很多时候是需要的</strong>。可以按以下步骤来确定添加什么样的限定符：</p><ol><li>是个大对象，可以考虑把变量声明成引用类型。通常引用类型是比指针类型更优的选择。</li><li>大对象可能需要被重置，可以考虑声明为指针。</li><li>只想要个常量，添加<code>constexpr</code>。</li><li>只想读这个变量，添加<code>const</code>。</li></ol><h3 id=变量初始化>变量初始化</h3><p>变量定义往往伴随着初始化，这对于局部变量来说很重要，因为局部变量的初值是不确定的，在没有对变量进行有效初始化前就使用变量，会导致不可控的问题。所以严格来说，前面的变量定义是不完全正确的。
C++11推出了全新的，统一的初始化方式，即在变量名后面跟着大括号，大括号里包着初始化的值。这种方式可以用在任何变量上，称之为统一初始化，如：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> a{<span style=color:#ae81ff>9527</span>}; <span style=color:#75715e>//普通类型
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>string b<span style=color:#f92672>=</span>{<span style=color:#e6db74>&#34;abc&#34;</span>}; <span style=color:#75715e>//另一种写法，等价但是不推荐
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>Student c{<span style=color:#e6db74>&#34;张三&#34;</span>,<span style=color:#e6db74>&#34;20220226&#34;</span>,<span style=color:#ae81ff>18</span>}; <span style=color:#75715e>//大括号中是构造函数参数
</span></span></span></code></pre></div><p>当然，除了用类型名来定义变量外，还可以将定义和初始化合二为一，变成下面这种最简洁的形式：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>auto</span> a<span style=color:#f92672>=</span>{<span style=color:#ae81ff>1</span>}; <span style=color:#75715e>//推导为整型
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>auto</span> b<span style=color:#f92672>=</span>string{<span style=color:#e6db74>&#34;abc&#34;</span>}; 
</span></span><span style=display:flex><span><span style=color:#66d9ef>auto</span> c<span style=color:#f92672>=</span>Student{<span style=color:#e6db74>&#34;张三&#34;</span>,<span style=color:#e6db74>&#34;20220226&#34;</span>,<span style=color:#ae81ff>18</span>}
</span></span></code></pre></div><p>这里<code>auto</code>是让编译器自己确定类型的意思。上面这种写法是完全利用了C++的类型推导，这也是好多现代语言推荐的形式。不过需要注意的是，使用类型推导后，<code>=</code>就不能省略了。
有了初始化的变量后，我们就可以用它们完成各种计算任务了。C++为开发者实现了很多内置的计算支持。如数字的加减乘除运算，数组的索引，指针的操作等。还提供了分支<code>if</code>，<code>switch</code>，循环<code>while</code>，<code>for</code>等语句，为我们提供了更灵活的操作。</p><h3 id=函数>函数</h3><p>变量是编程语言中的最小单位，随着业务的复杂度增加，有些时候中间计算会分散业务的逻辑，增加复杂度。为了更好地组织代码，类型系统增加了 函数来解决这个问题。
函数也是类型，是一种复合类型。它的类型由参数列表，返回值组合而成，也就是说两个函数，假如参数列表和返回值一样，那么它们从编译器的角度来看是等价的。当然光有它们还不够，不然怎么能出现两个参数列表和返回值一样的函数呢。一个完整的函数还需要有个函数体和函数名。所以函数一般是下面这种形式：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>//常规函数形式
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>[<span style=color:#66d9ef>constexpr</span>] <span style=color:#960050;background-color:#1e0010>返回值</span> <span style=color:#960050;background-color:#1e0010>函数名</span>(<span style=color:#960050;background-color:#1e0010>参数列表</span>)[<span style=color:#66d9ef>noexcept</span>]{
</span></span><span style=display:flex><span>    <span style=color:#960050;background-color:#1e0010>函数体</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>//返回值后置形式
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>auto</span> <span style=color:#960050;background-color:#1e0010>函数名</span>(<span style=color:#960050;background-color:#1e0010>参数列表</span>)<span style=color:#f92672>-&gt;</span><span style=color:#960050;background-color:#1e0010>返回值</span>
</span></span></code></pre></div><p>当一个函数没有函数体的时候，我们通常称之为函数声明。加上函数体就是一个函数定义。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>f</span>(<span style=color:#66d9ef>int</span>); <span style=color:#75715e>//函数声明
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>fun</span>(<span style=color:#66d9ef>int</span> value){  <span style=color:#75715e>//函数定义，因为有大括号代表的函数体
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>以上就是函数的基本框架，接下来我们分别来看一看组成它的各部分。
先说最简单的函数名，<strong>它其实是函数这种类型的一个变量，这个变量的值表示从内存地址的某个位置开始的一段代码块</strong>。前面也说过之所以能出现两个参数列表和返回值都相同的函数，但是编译器能识别，其主要功劳就在函数名上，所以函数名也和变量名一样，是一种标识符。那假如反过来，函数名相同，但是参数列表或者返回值不同呢，这种情况有个专有名词——函数重载。基于函数是复合类型的认识，它们中只要其中一种不同就算重载。另外，在C++11，还有一种没有名字的函数，称为lambda表达式。lambda表达式是一种类似于直接量的函数值，就像13，&lsquo;c&rsquo;这种，是一种不提前定义函数，直接在调用处定义并使用的函数形式。
参数列表是前面类型定义的升级款。所有前面说的关于变量定义的都适用于它，三种形式的变量定义，多个变量，变量初始化等。不过，它们都有了新名词。参数列表的变量称为形式参数，初始化称为默认参数。同样形参在实际使用的时候需要初始化，不过初始化来自调用方。形式参数没有默认值就需要在调用的时候提供参数，有默认值的可以省略。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>plus</span>(<span style=color:#66d9ef>int</span> a,<span style=color:#66d9ef>int</span> b<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>){ <span style=color:#75715e>//b是一个默认参数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>return</span> a<span style=color:#f92672>+</span>b;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(<span style=color:#66d9ef>void</span>){
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> c<span style=color:#f92672>=</span>plus(<span style=color:#ae81ff>1</span>); <span style=color:#75715e>//没有提供b的值，所以b初始化为1，结果是2
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>int</span> d<span style=color:#f92672>=</span>plus(<span style=color:#ae81ff>2</span>,<span style=color:#ae81ff>2</span>); <span style=color:#75715e>//a,b都初始化为2，结果是4
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>//int f=plus(1,2,3); //plus只有两个形参，也就是两个变量，没法保存三个值，所以编译错误
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>和参数列表一样，返回值也是一个变量，这个变量会通过<code>return</code>语句返回给调用者，所以从内存操作来看，它是一个赋值操作。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-cpp data-lang=cpp><span style=display:flex><span>std<span style=color:#f92672>::</span>string msg(){
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>string input;
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>cin<span style=color:#f92672>&gt;&gt;</span>input;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> input;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(<span style=color:#66d9ef>void</span>){
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>auto</span> a<span style=color:#f92672>=</span>msg();
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>string b<span style=color:#f92672>=</span>msg();<span style=color:#75715e>//msg返回的input复制到了b中
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>遗憾的是C++只支持单返回值，也就是一个函数调用最多只能返回一个值，假如有多个值就只能以形参形式返回了，这种方式对于函数调用就不是很友好，所以C++提出了新的解决思路。</p><h3 id=类>类</h3><p>随着业务的复杂度再次增加，函数形参个数可能会增加，或者可能需要返回多个值，然后在多个不同的函数间传递。这样会导致数据容易错乱，并且增加使用者的学习成本。
为了解决这些问题，工程师们提出了面向对象——多个数据打包的技术。表现在语言层面上，就是<strong>用类把一组操作和完成这组操作需要的数据打包在一起</strong>。数据作为类的属性，操作作为类的方法，使用者通过方法操作内部数据，数据不再需要使用者自己传递，管理。这对于开发者无疑是大大简化了操作。我们称之为面向对象编程，而在函数间传递数据的方式称为面向过程编程。这两种方式底层逻辑其实是一致的，该传递的参数和函数调用一样都不少，但是面向对象的区别是这些繁琐、容易出错的工作交给编译器来做，开发者只需要按照面向对象的规则做好设计工作就好了，剩下的交给编译器。至此，我们的类型系统又向上提升了一级。类不仅是多个类型的聚合体，还是多个函数的聚合体，是比函数更高级的抽象。
可以看下面面向过程编程和面向对象编程的代码对比</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Computer</span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>bool</span> booted;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>friend</span> std<span style=color:#f92672>::</span>ostream<span style=color:#f92672>&amp;</span> <span style=color:#66d9ef>operator</span><span style=color:#f92672>&lt;&lt;</span>(std<span style=color:#f92672>::</span>ostream<span style=color:#f92672>&amp;</span> os,<span style=color:#66d9ef>const</span> Computer <span style=color:#f92672>&amp;</span> c){
</span></span><span style=display:flex><span>        os<span style=color:#f92672>&lt;&lt;</span><span style=color:#e6db74>&#34;Computing&#34;</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> os;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>boot</span>(Computer<span style=color:#f92672>&amp;</span> c){
</span></span><span style=display:flex><span>    c.booted<span style=color:#f92672>=</span>true;
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>cout<span style=color:#f92672>&lt;&lt;</span><span style=color:#e6db74>&#34;Booting...&#34;</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>compute</span>(<span style=color:#66d9ef>const</span> Computer<span style=color:#f92672>&amp;</span> c){
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span>(c.booted){
</span></span><span style=display:flex><span>       std<span style=color:#f92672>::</span>cout<span style=color:#f92672>&lt;&lt;</span><span style=color:#e6db74>&#34;Compute with &#34;</span><span style=color:#f92672>&lt;&lt;</span>c;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>shutdown</span>(Computer<span style=color:#f92672>&amp;</span> c){
</span></span><span style=display:flex><span>    c.booted<span style=color:#f92672>=</span>false;
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>cout<span style=color:#f92672>&lt;&lt;</span><span style=color:#e6db74>&#34;Shutdown...&#34;</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(<span style=color:#66d9ef>void</span>){
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>auto</span> c<span style=color:#f92672>=</span>Computer();
</span></span><span style=display:flex><span>    boot(c);
</span></span><span style=display:flex><span>    compute(c);
</span></span><span style=display:flex><span>    shutdown(c);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;                                                                                                         
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>面向过程最主要的表现就是，开发者需要在函数间传递数据，并维护数据状态，上面例子中的数据是<code>c</code>。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Computer</span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>bool</span> booted;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>friend</span> std<span style=color:#f92672>::</span>ostream<span style=color:#f92672>&amp;</span> <span style=color:#66d9ef>operator</span><span style=color:#f92672>&lt;&lt;</span>(std<span style=color:#f92672>::</span>ostream<span style=color:#f92672>&amp;</span> os,<span style=color:#66d9ef>const</span> Computer <span style=color:#f92672>&amp;</span> c){
</span></span><span style=display:flex><span>        os<span style=color:#f92672>&lt;&lt;</span><span style=color:#e6db74>&#34;Computing&#34;</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> os;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>boot</span>(){
</span></span><span style=display:flex><span>        booted<span style=color:#f92672>=</span>true;
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>cout<span style=color:#f92672>&lt;&lt;</span><span style=color:#e6db74>&#34;Booting...&#34;</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>compute</span>(){
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(booted){
</span></span><span style=display:flex><span>            std<span style=color:#f92672>::</span>cout<span style=color:#f92672>&lt;&lt;</span><span style=color:#e6db74>&#34;Compute with &#34;</span><span style=color:#f92672>&lt;&lt;</span><span style=color:#66d9ef>this</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>shutdown</span>(){
</span></span><span style=display:flex><span>        booted<span style=color:#f92672>=</span>false;
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>cout<span style=color:#f92672>&lt;&lt;</span><span style=color:#e6db74>&#34;Shutdown...&#34;</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(<span style=color:#66d9ef>void</span>){
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>auto</span> c<span style=color:#f92672>=</span>Computer();
</span></span><span style=display:flex><span>    c.boot();
</span></span><span style=display:flex><span>    c.compute();
</span></span><span style=display:flex><span>    c.shutdown();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>可以看出面向对象的代码最主要的变化是，方法的参数变少了，但是可以在方法里面直接访问到类定义的数据。另一个变化发生在调用端。调用端是用数据调用方法，而不是往方法里面传递数据。这也是面向对象的本质——以数据为中心。
当然，类的封装功能只是类功能的一小部分，后面我们会涉及到更多的类知识。作为初学者，我们了解到这一步就能读懂大部分代码了。</p><h3 id=总结>总结</h3><p>类型系统是一门语言的基本构成部分，它支撑着整个系统的高级功能，很多高级特性都是在类型系统的基础上演化而来的。所以学习语言的类型系统有个从低到高，又从高到低的过程，从最基础的类型开始，学习如何从低级类型构筑出高级类型，然后站在高级类型的高度上，审视高级类型是怎样由低级类型构筑的。这一上一下，一高一低基本上就能把语言的大部分特性了解清楚了。
低级类型更偏向于让编译器更好地工作，高级类型偏向于让开发者更好地工作，C++从普通类型，函数，类提供了各个层级的支持，让开发者有更多自由的选择，当然也就增加了开发者的学习难度。但是开发者并不是都需要所有选择的，所以我觉得正确的学习应该是以项目规模为指导的。一些项目，完全用不到面向对象，就可以把精力放在打造好用的函数集上。而有的项目，面向对象是很好的选择，就需要在类上花费时间。回到开头的积木例子，选用什么积木完全看我们想搭什么模型，要是没有合适的积木，我们可以自己创造。这就是C++的迷人之处。</p></div><footer class=post-footer><div class=post-tags><a href=/tags/%e5%ad%a6%e4%b9%a0%e6%8c%87%e5%8d%97>学习指南</a>
<a href=/tags/c++>C++</a></div><div class=addthis_inline_share_toolbox style=text-align:center></div><hr><div class=post-copyright><img src=/imgs/cc/cc.svg width=75 height=75 align=right><ul><li class=post-copyright-title><strong>文章标题：</strong>
现代C++学习指南-类型系统</li><li class=post-copyright-author><strong>原文作者：</strong>
hongui</li><li class=post-copyright-link><strong>本文链接：</strong>
<a id=post-cr-link href=https://hongui.github.io/post/%E7%8E%B0%E4%BB%A3C++%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97-%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F.html title=现代C++学习指南-类型系统>https://hongui.github.io/post/%E7%8E%B0%E4%BB%A3C++%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97-%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F.html</a></li><li class=post-copyright-license><strong>版权声明：</strong>
本博客所有文章除特别声明外，均采用 <i class="fab fa-fw fa-creative-commons"></i><a target=_blank href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh>BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><div class=post-nav><div class="post-nav-next post-nav-item"><a href=/post/%E7%8E%B0%E4%BB%A3C++%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97-%E6%A0%87%E5%87%86%E5%BA%93.html rel=next title=现代C++学习指南-标准库><i class="fa fa-chevron-left"></i> 现代C++学习指南-标准库</a></div><div class="post-nav-prev post-nav-item"><a href=/post/%E7%8E%B0%E4%BB%A3C++%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97-%E6%96%B9%E5%90%91%E7%AF%87.html rel=prev title=现代C++学习指南-方向篇>现代C++学习指南-方向篇
<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div id=comments class=post-comments><div class=comment-head><div class=comment-headline><i class="fas fa-comments fa-fw"></i>
<span>评论交流</span></div><div class=comment-switch><span class=first-comment>Giscus</span>
<span class=switch-btn></span>
<span class=second-comment>Waline</span></div></div><div class=comment-wrap><div><div class=comment-loading><i class="fa fa-sync fa-spin"></i></div><div class=giscus-container></div></div><div><div class=comment-loading><i class="fa fa-sync fa-spin"></i></div><div class=waline-container></div></div></div></div></div></main><footer class=footer><div class=footer-inner><div class=copyright>&copy;
<span itemprop=copyrightYear>2020 - 2022</span>
<span class=with-love><i class="fa fa-heart"></i></span>
<span class=author itemprop=copyrightHolder>hongui</span></div><div class=powered-by>由 <a href=https://gohugo.io title=0.104.3 target=_blank>Hugo</a> & <a href=https://github.com/hugo-next/hugo-theme-next title=4.3.1 target=_blank>Hugo NexT.Mist</a> 强力驱动</div></div></footer><script type=text/javascript src=https://unpkg.com/animejs@3.2.1/lib/anime.min.js defer></script>
<script class=next-config data-name=main type=application/json>{"bookmark":{"color":"#584394","enable":true,"save":"manual"},"copybtn":true,"darkmode":false,"giscus":{"cfg":{"category":"Comments","categoryid":null,"emit":false,"inputposition":"top","mapping":"title","reactions":false,"repo":"username/repo-name","repoid":null,"theme":"preferred_color_scheme"},"js":"https://giscus.app/client.js"},"hostname":"https://hongui.github.io/","i18n":{"ds_day":" 天前","ds_days":" 天 ","ds_hour":" 小时前","ds_hours":" 小时 ","ds_just":"刚刚","ds_min":" 分钟前","ds_mins":" 分钟","ds_month":" 个月前","ds_years":" 年 ","empty":"没有找到任何搜索结果：${query}","hits":"","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","placeholder":"搜索..."},"lang":"zh-CN","lazyload":false,"localSearch":{"enable":true,"path":"/searchindexes.xml","preload":false,"topnperarticle":-1,"trigger":"auto","unescape":false},"motion":{"async":true,"enable":false,"transition":{"collheader":"fadeInLeft","postblock":"fadeIn","postbody":"fadeInDown","postheader":"fadeInDown","sidebar":"fadeInUp"}},"root":"/","scheme":"Mist","sidebar":{"display":"post","offset":12,"padding":18,"position":"left","width":256},"vendor":{"plugins":"unpkg","router":"https://unpkg.com"},"version":"4.3.1","waline":{"cfg":{"emoji":false,"imguploader":false,"pageview":"#waline-pageview-count","placeholder":"请文明发言哟 ヾ(≧▽≦*)o","reaction":true,"reactiontext":["点赞","踩一下","得意","不屑","尴尬","睡觉"],"reactiontitle":"你认为这篇文章怎么样？","requiredmeta":["nick","mail"],"serverurl":null,"sofa":"快来发表你的意见吧 (≧∀≦)ゞ","wordlimit":200},"css":{"alias":"waline","file":"dist/waline.css","name":"@waline/client","version":"2.11.3"},"js":{"alias":"waline","file":"dist/waline.js","name":"@waline/client","version":"2.11.3"}}}</script><script type=text/javascript src=/js/main.min.b28dfe5c5269e780969d70d2aab1f0a1501079780df3a0178998c5edfd89e071.js defer></script></body></html>