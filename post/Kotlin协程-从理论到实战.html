<!doctype html><html lang=zh-cn dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="用纯HTML，JS，CSS实现横向滚动标签页"><title>用纯HTML，JS，CSS实现横向滚动标签页</title><link rel=canonical href=https://hongui.github.io/post/Kotlin%E5%8D%8F%E7%A8%8B-%E4%BB%8E%E7%90%86%E8%AE%BA%E5%88%B0%E5%AE%9E%E6%88%98.html><link rel=stylesheet href=/scss/style.min.18145888f21de6cb02d8cb0891be8240096206785da14eda35f6c23c239b966a.css><meta property="og:title" content="用纯HTML，JS，CSS实现横向滚动标签页"><meta property="og:description" content="用纯HTML，JS，CSS实现横向滚动标签页"><meta property="og:url" content="https://hongui.github.io/post/Kotlin%E5%8D%8F%E7%A8%8B-%E4%BB%8E%E7%90%86%E8%AE%BA%E5%88%B0%E5%AE%9E%E6%88%98.html"><meta property="og:site_name" content="低头沉思"><meta property="og:type" content="article"><meta property="article:section" content="Posts"><meta property="article:tag" content="Android"><meta property="article:tag" content="Kotlin"><meta property="article:tag" content="协程"><meta property="article:published_time" content="2021-03-27T19:02:30+08:00"><meta property="article:modified_time" content="2021-03-27T19:02:30+08:00"><meta name=twitter:title content="用纯HTML，JS，CSS实现横向滚动标签页"><meta name=twitter:description content="用纯HTML，JS，CSS实现横向滚动标签页"><link rel="shortcut icon" href=#ZgotmplZ></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column compact"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label=切换菜单>
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/><img src=/img/avatar_huda2458f72ce188392d75c5d51cd8e24e_373_300x0_resize_box_3.png width=300 height=300 class=site-logo loading=lazy alt=Avatar></a></figure><div class=site-meta><h1 class=site-name><a href=/>低头沉思</a></h1><h2 class=site-description></h2></div></header><ol class=menu id=main-menu><li><a href=/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg><span>首页</span></a></li><li><a href=/about.html><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="7" r="4"/><path d="M6 21v-2a4 4 0 014-4h4a4 4 0 014 4v2"/></svg><span>关于</span></a></li><li class=current><a href=/posts/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg><span>归档</span></a></li><li><a href=/404.html><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-infinity" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M9.828 9.172a4 4 0 100 5.656A10 10 0 0012 12a10 10 0 012.172-2.828 4 4 0 110 5.656A10 10 0 0112 12 10 10 0 009.828 9.172"/></svg><span>公益 404</span></a></li><div class=menu-bottom-section><li id=dark-mode-toggle><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg><span>暗色模式</span></li></div></ol></aside><main class="main full-width"><article class=main-article><header class=article-header><div class=article-details><header class=article-category><a href=/categories/%E5%8D%8F%E7%A8%8B/>协程</a></header><div class=article-title-wrapper><h2 class=article-title><a href=/post/Kotlin%E5%8D%8F%E7%A8%8B-%E4%BB%8E%E7%90%86%E8%AE%BA%E5%88%B0%E5%AE%9E%E6%88%98.html>用纯HTML，JS，CSS实现横向滚动标签页</a></h2><h3 class=article-subtitle>用纯HTML，JS，CSS实现横向滚动标签页</h3></div><footer class=article-time><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg><time class=article-time--published>2021/03/27 07:02</time></div><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg><time class=article-time--reading>阅读时长: 1 分钟</time></div></footer></div></header><section class=article-content><blockquote><p>上一篇文章从理论上对Kotlin协程进行了部分说明，本文将在上一篇的基础上，从实战出发，继续协程之旅。</p></blockquote><h1 id=从源头说起>从源头说起</h1><p>在Kotlin中，要想使用协程，首先需要使用协程创建器创建，但还有个前提——协程作用域(<code>CoroutineScope</code>)。在早期的Kotlin实现中，协程创建器是一等函数，也就是说我们随时随地可以通过协程创建器创建协程。但在协程正式发布以后，协程创建器需要在协程作用域对象上才能创建了，Kotlin添加了协程作用域来实现结构化并发。什么是结构化并发呢，通俗地说就是正确实施多个协程监控、管理的能力。在实际业务中，我们可能需要创建多个协程对象来完成不同的工作。为了对这些不相关的协程管理起来，Kotlin引入了协程作用域，通过某个协程作用域创建的协程都会被它管理着，在条件满足的时候，执行每个协程的取消工作或者结束自己。</p><p>为了方便我们直接上手，官方提供了<code>MainScope</code>和<code>GlobalScope</code>供我们使用。正如名字那样，他们分别有不同的应用场景，前者比较适合用在UI相关的类中，而后者适用于在整个应用生命周期中都需要存活的类中。当然，对于Android开发者，其实我们有更好的选择——使用<code>ViewModel</code>的Kotlin扩展，它不仅有着全部的协程作用域功能，开箱即用，而且还在<code>onCleared</code>方法中实现了自动取消。</p><h1 id=创建协程>创建协程</h1><p>有了协程作用域，那我们来创建一个最简单的协程吧。</p><div class=highlight><div style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span>viewModelScope.launch{
</span></span><span style=display:flex><span>    <span style=color:#998;font-style:italic>//这里就是协程代码啦啦啦啦
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>    delay(<span style=color:#099>2000</span>)
</span></span><span style=display:flex><span>    System.<span style=color:#000;font-weight:700>out</span>.println(<span style=color:#d14>&#34;Hello World&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div><p><code>launch</code>创建并启动了一个协程，协程启动两秒后，在控制抬打印了Hello World，然后协程就结束了（协程是有完整生命周期的）。这个协程完成的工作有限，我们可以使用线程完成相同的功能:</p><div class=highlight><div style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span>thread {
</span></span><span style=display:flex><span>            Thread.sleep(<span style=color:#099>2000</span>)
</span></span><span style=display:flex><span>            System.<span style=color:#000;font-weight:700>out</span>.println(<span style=color:#d14>&#34;Hello World&#34;</span>)
</span></span><span style=display:flex><span>        }
</span></span></code></pre></td></tr></table></div></div><p>我们可以看到，除去构建函数，两段代码唯一的区别就是延迟函数——<code>delay</code>和<code>Thread.sleep</code>.从功能上看他们都是让后面的代码延迟执行，但是效果却是不一样的，前者不会阻塞线程。这段代码其实是放在主线程里面执行的，但是它不会影响到UI的绘制，而后者假如把它放在主线程执行的话，应用会出现两秒的无响应。Kotlin把这种不会阻塞当前线程执行的函数称之为挂起函数，挂起函数可以在挂起点断开与当前线程的联系，让线程空闲下来完成其他的操作，当条件满足后，挂起函数重新在挂起点恢复，接着往下执行后面的代码。</p><p>还有个小问题没有解决，在上一篇文章中，我曾经说过，挂起函数只能在挂起函数中执行，既然<code>delay</code>是挂起函数，那么反推，我们的代码块也应该是个挂起函数，而这个挂起函数就是所谓的协程体。</p><h1 id=让协程跨线程工作>让协程跨线程工作</h1><p>如果你看到上面的代码，然后转手在协程体里面写个网络请求的话，你会发现，你的应用崩溃了，这是怎么回事呢？因为协程虽然不会阻塞主线程，但是主线程是不允许进行网络请求的。如果这时你就急着下了协程没啥用的结论，那么你就肤浅了。让我们稍微改一改上面的代码，让它运行在子线程吧。</p><div class=highlight><div style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span>viewModelScope.launch (Dispatchers.IO){
</span></span><span style=display:flex><span>    <span style=color:#998;font-style:italic>//这里就是协程代码啦啦啦啦
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>    delay(<span style=color:#099>2000</span>)
</span></span><span style=display:flex><span>    System.<span style=color:#000;font-weight:700>out</span>.println(<span style=color:#d14>&#34;Hello World&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div><p>很好，现在协程体里面的网络请求可以顺利执行了，但是很快有读者就会发现新问题了——我怎么把网络请求的结果传回主线程呢，难不成还搞个<code>Handler</code>,那和直接使用线程有什么区别，辣鸡协程。嘿，别急，这个协程其实也为客官处理好了。让我们再次改造一下代码：</p><div class=highlight><div style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">8
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">9
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span>viewModelScope.launch (Dispatchers.IO){
</span></span><span style=display:flex><span>    <span style=color:#998;font-style:italic>//这里就是协程代码啦啦啦啦，这里是在子线程执行的代码哦
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>    <span style=color:#998;font-style:italic>//假装这个是网络请求吧
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>    delay(<span style=color:#099>2000</span>)
</span></span><span style=display:flex><span>    withContext(Dispatchers.Main) {
</span></span><span style=display:flex><span>        <span style=color:#998;font-style:italic>//哦豁豁，这里竟然运行在主线程哦
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>        System.<span style=color:#000;font-weight:700>out</span>.println(<span style=color:#d14>&#34;Hello World&#34;</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div><p>很好，我们可以愉快地使用协程处理网络请求了，那么这些魔法是怎么发生的呢，停下脚步，我们来重新审视一下上面的代码。</p><p>首先，相比于最开始的代码，我们的代码里多了两个对象，一个方法调用。首先我们来看那两个对象，从名字中我们不难猜到它就是调度线程的。
Kotlin提供了四个常用的实现</p><ul><li><p><code>Default</code>,它是标准协程构建者默认使用的调度器，使用共享的线程池工作，适用于计算型的任务；</p></li><li><p><code>Main</code>,它是代表UI线程的调度器，通常来说只有一个线程，使用这个调度器就可以直接在协程中操作UI;</p></li><li><p><code>Unconfined</code>,它没有限定线程范围，它在哪个线程中被调用就会在哪个线程里执行完初始的代码，直到遇到挂起函数，随后它会使用挂起函数指定的调度器恢复，这个过程可以一直持续下去。</p></li><li><p><code>IO</code>,是用来承载阻塞的IO操作的，如文件读写，网络连接等，是我们比较常用的调度器。</p></li></ul><p>所以那两个调度器对象是让协程切换工作环境的魔法。接下来还有一个方法调用没有解释。<code>withContext</code>的作用是将当前的协程调度器切换到指定的调度器上，用这个调度器接着执行构建块中的代码。同时它也是一个挂起函数。提到挂起函数，我们就该想到，它是可恢复的。所以当这个挂起函数的代码块执行完成之后，它会自动恢复成原来的调度器，接着往下执行。</p><h1 id=用协程串联两个异步操作>用协程串联两个异步操作</h1><p>在项目开发中，还有一种常见的应用场景，客户端需要先请求一些配置信息，然后利用配置信息再请求真正的内容信息。这个过程描述起来是串行的，但是代码写起来却是割裂的，需要在第一个网络请求的回调中处理和发起第二个请求，然后在第二个回调中获取真正需要展示的数据，可能这个过程还会加个存库，或者触发另外请求的工作，那么完了，这代码没法看了。这放在以前，这种情况通常会使用RxJava，但是RxJava的代码可读性也还是差点意思。那么Kotlin协程可以写成什么样呢？</p><div class=highlight><div style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">8
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">9
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span>viewModelScope.launch(Dispatchers.IO) {
</span></span><span style=display:flex><span>            <span style=color:#000;font-weight:700>val</span> retrofit=Retrofit.Builder().build()
</span></span><span style=display:flex><span>            <span style=color:#000;font-weight:700>val</span> apiUser=retrofit.create(APIUser<span style=color:#000;font-weight:700>::</span><span style=color:#000;font-weight:700>class</span>.java)
</span></span><span style=display:flex><span>            <span style=color:#000;font-weight:700>val</span> user=api.current()
</span></span><span style=display:flex><span>            <span style=color:#000;font-weight:700>val</span> detail=api.userDetail(user.id)
</span></span><span style=display:flex><span>            withContext(Dispatchers.Main) {
</span></span><span style=display:flex><span>                userLiveData.<span style=color:#000;font-weight:700>value</span>=detail
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span></code></pre></td></tr></table></div></div><p>这和我们写一般的同步代码一摸一样，没有回调，也不需要付出其他代价，这个过程甚至可以一直加下去。其实我觉得这个才是协程的真正威力。</p><h1 id=让多个协程一起工作>让多个协程一起工作</h1><p>我们继续复杂化使用场景——我在做一个多端使用的笔记App，现在用户打开了某一个已存在的笔记，为了让用户能快速浏览到上一次的操作信息，一方面我需要从文件中读取上一次操作的结果，另一方面我要拉取远程的操作结果，然后对两个结果合并，决定最终的展示数据。考虑到这两个操作其实是并行的，上面我们让协程串联起来的思路已经不适用了，因为协程里面的操作都是串行的。既然一个协程解决不了，我们再加一个协程可不可以呢？看着好像是可以，但是，协程操作的结果我们怎么获取到呢？查阅API，我找到了另一个协程构建器<code>async</code>。它会返回一个协程对象，然后通过<code>await</code>方法获取到协程的计算结果。思路来了，我们马上动手</p><div class=highlight><div style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span> <span style=color:#000;font-weight:700>val</span> fileResult=viewModelScope.async(Dispatchers.IO) {
</span></span><span style=display:flex><span>             <span style=color:#998;font-style:italic>//假装是读文件的代码吧
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>             <span style=color:#099>1</span>
</span></span><span style=display:flex><span>         }
</span></span><span style=display:flex><span> <span style=color:#000;font-weight:700>val</span> networkResult=viewModelScope.async(Dispatchers.IO) {
</span></span><span style=display:flex><span>     <span style=color:#998;font-style:italic>//也是假装是网络请求的代码
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>     <span style=color:#099>2</span>
</span></span><span style=display:flex><span> }
</span></span><span style=display:flex><span> <span style=color:#000;font-weight:700>val</span> fResult=fileResult.await()
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>val</span> rResult=networkResult.await()
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>val</span> result=<span style=color:#000;font-weight:700>if</span>(fResult&gt;rResult){
</span></span><span style=display:flex><span>    fResult
</span></span><span style=display:flex><span>}<span style=color:#000;font-weight:700>else</span>{
</span></span><span style=display:flex><span>    networkResult
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div><p>然后你就会发现报错了，<code>await</code>是挂起函数。看来两个协程还完成不了，要三个，所以，让我们创建第三个协程吧</p><div class=highlight><div style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span> <span style=color:#998;font-style:italic>//前面的两个协程不变
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span> viewModelScope.launch {
</span></span><span style=display:flex><span>     <span style=color:#000;font-weight:700>val</span> fResult=fileResult.await()
</span></span><span style=display:flex><span>     <span style=color:#000;font-weight:700>val</span> rResult=networkResult.await()
</span></span><span style=display:flex><span>     <span style=color:#000;font-weight:700>val</span> result=<span style=color:#000;font-weight:700>if</span>(fResult&gt;rResult){
</span></span><span style=display:flex><span>         fResult
</span></span><span style=display:flex><span>     }<span style=color:#000;font-weight:700>else</span>{
</span></span><span style=display:flex><span>         networkResult
</span></span><span style=display:flex><span>     }
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div><p>这就是协程间通信的基本写法啦，从这个基础之上，甚至还能衍生出更复杂的版本，但是万变不离其宗，都可以参考这种思路完成。</p><h1 id=协程的取消>协程的取消</h1><p>正如之前提到的一样，协程有着类似于线程的完整生命周期，包括创建，激活，完成中（取消中），已完成（已取消），刚才我们的示例都是正常状态，协程完成工作后会自动结束，但协程的另一条取消流程我们还没有提到。协程有自己的取消API——<code>cancel</code>可供使用，我们只需要保存好协程创建者返回的协程对象就行了。当然更常见的还是文章开篇提到的使用协程作用域取消。这个操作会取消所有的协程。</p><h1 id=总结>总结</h1><p>本篇文章从协程创建开始，讲到了怎样用协程写出异步代码，怎么让多个协程共同工作，虽然覆盖了很大一部分使用场景，但是依然还有遗漏。由于篇幅限制，遗漏部分将在下一篇博文中继续讲解，希望大家持续关注。</p><p>青山不改，绿水长流，咱们下期见！</p></section><footer class=article-footer><section class=article-tags><a href=/tags/android/>Android</a>
<a href=/tags/kotlin/>Kotlin</a>
<a href=/tags/%E5%8D%8F%E7%A8%8B/>协程</a></section></footer></article><aside class=related-content--wrapper><h2 class=section-title>相关文章</h2><div class=related-content><div class="flex article-list--tile"><article><a href=/post/Kotlin%E5%8D%8F%E7%A8%8B-%E9%82%A3%E4%BA%9B%E7%90%86%E4%B8%8D%E6%B8%85%E4%B9%B1%E4%B8%8D%E6%98%8E%E7%9A%84%E5%85%B3%E7%B3%BB.html><div class=article-details><h2 class=article-title>Kotlin协程-那些理不清乱不明的关系</h2></div></a></article><article><a href=/post/%E6%B2%89%E6%80%9D%E7%AF%87-%E5%89%96%E6%9E%90Jetpack%E7%9A%84LiveData.html><div class=article-details><h2 class=article-title>沉思篇-剖析Jetpack的ViewModel</h2></div></a></article><article><a href=/post/%E6%B2%89%E6%80%9D%E7%AF%87-%E5%89%96%E6%9E%90Jetpack%E7%9A%84LiveData.html><div class=article-details><h2 class=article-title>沉思篇-剖析Jetpack的LiveData</h2></div></a></article><article><a href=/post/%E6%B2%89%E6%80%9D%E7%AF%87-%E5%89%96%E6%9E%90JetPack%E7%9A%84Lifecycle.html><div class=article-details><h2 class=article-title>沉思篇-剖析JetPack的Lifecycle</h2></div></a></article></div></div></aside><footer class=site-footer><section class=copyright>&copy;
2020 -
2022 低头沉思</section><section class=powerby>Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a><br>主题 <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.14.0>Stack</a></b> 由 <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a> 设计</section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"></button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z+KMkF24hUW8WePSA9HM=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.js defer></script>
<script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>