<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on 低头沉思</title><link>https://bravebuffalo.cc/posts/</link><description>Recent content in Posts on 低头沉思</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Tue, 09 May 2023 22:14:38 +0800</lastBuildDate><atom:link href="https://bravebuffalo.cc/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>Android-OpenGLES学习-画个颜色</title><link>https://bravebuffalo.cc/post/Android-OpenGLES%E5%AD%A6%E4%B9%A0-%E7%94%BB%E4%B8%AA%E9%A2%9C%E8%89%B2.html</link><pubDate>Tue, 09 May 2023 22:14:38 +0800</pubDate><guid>https://bravebuffalo.cc/post/Android-OpenGLES%E5%AD%A6%E4%B9%A0-%E7%94%BB%E4%B8%AA%E9%A2%9C%E8%89%B2.html</guid><description>我们知道屏幕显示出内容是靠一个一个发光的RGB灯珠，而决定灯珠亮度的是一块内存区域，通过往这一块内存区域写入数据，我们就能在屏幕上观察到数据显示效果。这是个复杂又灵活的工作，为了方便完成这项工作，先驱们制定出了OpenGL标准，我们的故事也将从这里开始。
OpenGL ES #OpenGL ES是OpenGL的精简版本，Android平台从发行伊始就提供了OpenGL ES的支持，只是不同的版本，支持的OpenGL ES版本不同，目前主流的版本还是2.0和3.0。OpenGL ES是一组API，为开发者提供配置数据，传输数据，绘制内容的能力。它的工作是和绘制严格相关的，所以光是OpenGL ES不会造成很大的理解障碍，问题出在配置OpenGL ES的配置环境上。为什么要将OpenGL ES API和配置环境分开呢，因为OpenGL ES是跨平台的API，但是实际运行的时候需要和特定平台绑定，如Android。平台间准备OpenGL ES环境所需要的条件不同，为了保证OpenGL ES的跨平台能力，就需要将配置环境单独拿出来和特定平台绑定。在Android上这个配置环境就是EGL。明确OpenGL ES API和配置OpenGL ES环境的区别不仅对理解这两个关键概念有很大帮助，更是对后期调试代码，排错帮助极大。
工作流程 #明确了一些基本概念之后，我们接下来最重要的任务是理清OpenGL ES的工作流程。很多教程一上来就列举一大堆名词或者直接上实例，我觉得是不妥的。只有熟悉了工作流程，我们在写代码的时候才能做到心中有数，才能在排错过程中更快更准确地定位问题。
准备环境 #OpenGL ES是由一系列API组成的，但是不代表可以在任何时机下调用这些API，而是需要运行环境进行一些设置，这就是准备环境。准备环境通常是做一些显存分配，窗口配置的工作，很繁琐却必不可少。
准备着色器 #着色器很重要，但是对于初学者来说不需要用太多的精力来关注它，很多效果直接可以在网上找到现成的代码，但是怎样将这些代码组装成一个完整可运行的程序却不一定有。我们只需要明确着色器是OpenGL ES开发中的重要一环，这一环这一是魔法发生的地方。
准备程序 #着色器虽然重要，但是也不能独立运行，需要由一个程序管理。这里说的程序是一个OpenGL ES对象，它负责将着色器组装在一起。在运行大部分OpenGL ES API前都需要先使用到这个对像。
渲染 #渲染环节其实也是在准备数据，我们需要将着色器中用到的一些数据赋值，然后调用绘制API，完成最后的绘制工作。GPU会将数据传递给着色器，着色器经过流水线，将数据转换成最终的显示数据存储在显存中。
上屏 #渲染不代表就是将数据显示出来了，而是说数据计算好了。计算好的数据要想在屏幕上看到，可能需要调用OpenGL ES环境配置工具中的某个函数，如交换缓冲或者切换显示对象。
清理 #和内存一样，我们使用OpenGL ES API也会申请到一些资源，在渲染结束后，我们应该主动将资源释放，以便后续程序使用。很多时候我们正常申请资源没有成功，可能是前面有资源没有释放的原因。
以上就是开发OpenGL ES应用的大致流程。由于OpenGL ES开发不好排错，所以在发现问题时最有效的定位方法是确定出错环节，然后再针对性地处理。所以熟悉流程很重要。
实例上手 #由于OpenGLES相关概念很多，为了尽可能减少相关概念的干扰，本文打算只将上述流程中的第一步拿出来着重讲解。同时利用涉及到的知识点，实现一个最小的示例——将窗口染成红色。
下面开始讲解第一个概念——EGL。
EGL #OpenGL ES只是对绘图的抽象，没有提供运行环境的抽象。如要申请显存，显存在哪里，需要明确，图像计算好了，显示在哪里，也需要指定。EGL就是对这些环境抽象的集合，为了通俗地解释相关概念，我们可以玩一下角色扮演——假如让我们设计相关标准，我们该如何做。</description></item><item><title>现代C++学习指南 模板</title><link>https://bravebuffalo.cc/post/%E7%8E%B0%E4%BB%A3C++%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97%20%E6%A8%A1%E6%9D%BF.html</link><pubDate>Mon, 31 Oct 2022 21:33:38 +0800</pubDate><guid>https://bravebuffalo.cc/post/%E7%8E%B0%E4%BB%A3C++%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97%20%E6%A8%A1%E6%9D%BF.html</guid><description>模板作为C++重要的特性，一直有着举足轻重的地位，是编写高度抽象代码的利器。
什么是模板 #模板在现实生活中就是范例：把都一样的部分固定起来，把变动的部分空出来，使用时将两部分合起来组成有效的东西。如申请书，Word模板都是这种形式。C++中的模板也是如此，不过更明确的是C++中的模板，变动的部分是一个代指类型的东西，称之为泛型参数。
我们先从一个例子来看一看模板是怎样发展而来的。如我们需要计算两个对象相加的结果，该如何写代码呢？在写代码前，我们有几个问题需要讨论清楚： 首先我们需要确定的是这两个对象是什么类型，毕竟C++是强类型的编程语言，变量，函数，类都是要明确指定类型是什么的，不确定的类型编译就不能通过。我们先假设这两个类型是整型。确定了类型之后，还需要确定这两个对象需要怎样加起来，根据我们假设的整型，我们知道可以直接调用运算符+。最后我们需要确定，两个对象相加后的结果类型是什么，整型相加的结果也是整型。综上，这个例子的代码看起来可能是这样的
int sum(int left,int right){ return left + right; } 这个例子很简单，简单到甚至都不需要单独写成一个函数。如果我们需要计算的数据不是两个数，而是一个数组的和呢？基于前面的分析和假设，我们也能很快实现相应的代码
int sum(const int data[], const std::size_t length) { int result{}; for (int i = 0; i &amp;lt; length;++i) { result += *(data + i); } return result; } 同样很简单。但是遗憾的是，这个函数通用性不强，它只能计算整型的数组和，假如我们需要计算带有小数点的数组和，它就不灵了，因为第一个参数类型不匹配，尽管我们知道sum的代码几乎都能复用，除了第一行的int需要替换成double。但是不能！我们只能复制一份，然后把int的地方改成double。
double sum(const double data[], const std::size_t length) { double result{}; for (int i = 0; i &amp;lt; length;++i) { result += *(data + i); } return result; } 这时你就会发现问题了，这个过程，我们仅仅改变了类型信息。这样的问题还会继续增加，我们可能又需要求float的数组和，上面那个double的数组和同样匹配不了，因为float，double是两个类型。正是因为数据类型不一样，所以很多时候我们需要为不同的数据提供相似的代码，这在数据类型膨胀的情况下是很痛苦的，当对算法进行修改的时候我们需要保证所有的数据类型都被修改到，并且要逐个进行测试，这无疑会增加工作量，并放大错误率。但是实际有效的代码都是要明确类型的，如果类型不明确，编译器就没法确定代码是否合法，不确定的事情编译器就要报错，所以按照普通的思路，这个问题是无解的。 但是其实很多时候，这些相似的代码仅仅是数据类型不一样而已，对付这种重复的工作应该让给计算机来完成，也就是编译器。所以我们需要一种技术，让编译器先不管具体类型是什么，而是用一种特殊的类型来替换，这个类型可以替换成任何类型，用这个特殊的类型完成具体的算法，在使用的时候根据实际的需求，将类型信息提供给算法，让编译器生成满足所提供类型的具体算法，而这就是模板。这和生活中的模板思想上是共通的。算法是固定的部分，数据类型是可变的部分，两个合起来就是合法的C++代码。也就是利用模板，我们可以只写一个算法，借助编译器生成所有类型的算法，这些算法之间唯一不同的就是类型。 当然光有模板还不够，上面只解决了类型的问题，没有解决算法实现的问题。怎么说呢，如我们有一个需求，需要将数据先排序，再查找最大值。这对于数字（int,float,double等）类型是有效的，直接使用比较运算符（&amp;lt;,&amp;gt;）就可以完成了，但是假如想让这个算法适用于自定义类型呢？直接在模板实现中写比较运算符对自定义类型是无效的，因为自定义类型没有实现相对应的比较运算函数。解决方法也很简单，自定义类型实现相对应的比较运算符就行了。诸如此类的问题，在模板中会经常遇到，因为我们对类型的信息一无所知，但是又要确保几乎所有的类型都能正常运作，这就不得不运用各种技术对类型进行限定或者检测，这其实才是模板问题的精髓。所以模板问题不仅仅是类型问题，还是其他C++问题的综合体，需要对C++特性有着较为完整的理解，才能写出有用高效的代码。 C++中通常将模板分为函数模板和模板类，我们先从比较简单的函数模板开始认识。</description></item><item><title>现代C++学习指南-标准库</title><link>https://bravebuffalo.cc/post/%E7%8E%B0%E4%BB%A3C++%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97-%E6%A0%87%E5%87%86%E5%BA%93.html</link><pubDate>Wed, 20 Jul 2022 22:15:05 +0800</pubDate><guid>https://bravebuffalo.cc/post/%E7%8E%B0%E4%BB%A3C++%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97-%E6%A0%87%E5%87%86%E5%BA%93.html</guid><description>&lt;blockquote>
&lt;p>在[上一章](&lt;a href="https://www.yuque.com/docs/share/adb5b1e4-f3c6-46fd-ba4b-4dabce9b4f2a?#" target="_blank" rel="noreferrer">https://www.yuque.com/docs/share/adb5b1e4-f3c6-46fd-ba4b-4dabce9b4f2a?#&lt;/a> 《现代C++学习指南-类型系统》)我们探讨了C++的类型系统，并提出了从低到高，又从高到低的学习思路，本文就是一篇从高到低的学习指南，希望能提供一种新的视角。&lt;/p>
&lt;/blockquote></description></item><item><title>现代C++学习指南-类型系统</title><link>https://bravebuffalo.cc/post/%E7%8E%B0%E4%BB%A3C++%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97-%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F.html</link><pubDate>Sun, 26 Jun 2022 11:11:59 +0800</pubDate><guid>https://bravebuffalo.cc/post/%E7%8E%B0%E4%BB%A3C++%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97-%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F.html</guid><description>在前一篇，我们提供了一个方向性的指南，但是学什么，怎么学却没有详细展开。本篇将在前文的基础上，着重介绍下怎样学习C++的类型系统。
写在前面 #在进入类型系统之前，我们应该先达成一项共识——尽可能使用C++的现代语法。众所周知，出于兼容性的考虑，C++中很多语法都是合法的。但是随着新版本的推出，有些语法可能是不推荐或者是需要避免使用的。所以本篇也尽可能采用推荐的语法形式（基于C++11或以上版本），这也是现代C++标题的含义。
采用现代语法有两点好处。其一，现代语法可以编译出更快更健壮的代码。编译器也是随着语言的发展而发展的，现代语法可以在一定程度上帮助编译器做更好的优化。其二，现代语法通常更简洁，更直观，也更统一，有助于增强可读性和可维护性。 明确了这点后，让我们一起踏入现代C++的大门吧。
类型系统 #程序是一种计算工具，根据输入，和预定义的计算方法，产生计算结果。当程序运行起来后，这三者都需要在内存中表示成合适的值才能让程序正常工作，负责解释的这套工具就是类型系统。数字，字符串，键盘鼠标事件等都是数据，而且在内存中实际存在的形式也是一样的，但是按我们人类的眼光来看的话，对它们的处理是不一样的。数字能进行加减乘除等算术运算，但是对字符串进行算术运算就没有意义，而键盘鼠标的值通常只是读取，不进行计算的。正是由于这些差异，编程语言的第一个任务就是需要定义一套类型系统，告诉计算机怎样处理内存中的数据。 为了让编程语言尽可能简单，编程语言一般把类型系统分为两步实现，一部分是编译器，另一部分是类型。编译器那部分负责将开发者的代码解释成合适的形式，以便可以高效，准确在内存中表示。类型部分则定义一些编译器能处理的类型，以便开发者可以找到合适的数据来完成输入输出的表示和计算方法的描述。这两者相辅相成，相互成就。 类型作为类型系统的重要表现形式，在编程语言中的重要性也就不言而喻了。如果把写程序看成是搭积木的话，那么程序的积木就是类型系统。类型系统是开发者能操作的最小单位，它限制了开发者的操作规则，但是提供了无限的可能。C++有着比积木更灵活的类型系统。
类型 #:::info 类型是编程语言的最小单位，任何一句代码都是一种内存使用形式。 ::: 而谈到C++的类型也就不得不谈到它的三种类型表现形式——普通类型，指针，引用。它们是三种不同的内存使用和解释形式，也是C++的最基础的形式。和大部分编程语言不同，C++对内置类型没有做特权处理，只要开发者愿意，所有的类型都可以有一致的语法形式（通过运算符重载），所以下面关于类型的举例适合所有的类型。 普通类型就是没有修饰的类型，如int,long,double等。它们是按值传递的，也就是赋值和函数传参是拷贝一份值，对拷贝后的值进行操作，不会再影响到老值。
int a=1; //老值,存在地址1 int b=a; //新值，存在地址2 b=2; //改变新值，改变地址2 //此时a还是1，b变成了2 那假如我们需要修改老值呢，有两种途径，一种是指针，另一种则是引用。 指针是C/C++里面的魔法，一切皆可指针。指针包含两个方面，一方面它是指一块内存，另一方面它可以指允许对这块内存进行的操作。指针的值是一块内存地址，操作指针，操作的是它指向的那块地址。
int a=1; //老值,存在地址1 int* b=&amp;amp;a; //&amp;amp;代表取地址，从右往左读，取a的地址——地址1，存在地址2 *b=2; //*是解引用，意思是把存在地址2(b)的值取出来，并把那个地址（地址1）的值改成2 //此时a，*b变成了2 引用则是指针的改进版，引用能避免无效引用，不过引用不能重设，比指针缺少一定的灵活性。
int a=1; //老值,存在地址1 int&amp;amp; b=a; //&amp;amp;出现在变量声明的位置，代表该变量是引用变量，引用变量必须在声明时初始化 b=2; //可以像普通变量一样操作引用变量，同时，对它的操作也会反应到原始对象上 //此时a，b变成了2 变量定义 #类型仅仅是一种语法定义，而要真正使用这种定义，我们需要用类型来定义变量，即变量定义。 C++变量定义是以下形式：
type name[{initial_value}] 这里的关键在于type。type是类型和限定符的组合。看下面的例子：</description></item><item><title>现代C++学习指南-方向篇</title><link>https://bravebuffalo.cc/post/%E7%8E%B0%E4%BB%A3C++%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97-%E6%96%B9%E5%90%91%E7%AF%87.html</link><pubDate>Sat, 25 Jun 2022 08:51:01 +0800</pubDate><guid>https://bravebuffalo.cc/post/%E7%8E%B0%E4%BB%A3C++%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97-%E6%96%B9%E5%90%91%E7%AF%87.html</guid><description>&lt;p>C++是一门有着四十年历史的语言，先后经历过四次版本大升级（诞生、98、11、17（20），14算小升级）。每次升级都是很多问题和解决方案的取舍。了解这些历史，能更好地帮助我们理清语言的发展脉络。所以接下来我将借它的发展历程，谈一谈我对它的理解，最后给出我认为比较合理的学习路线指南。&lt;/p></description></item><item><title>Android-NDK开发——基本概念</title><link>https://bravebuffalo.cc/post/Android-NDk%E5%BC%80%E5%8F%91%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5.html</link><pubDate>Sun, 06 Mar 2022 11:30:40 +0800</pubDate><guid>https://bravebuffalo.cc/post/Android-NDk%E5%BC%80%E5%8F%91%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5.html</guid><description>&lt;p>在Android开发中,有时候出于安全，性能，代码共用的考虑，需要使用C/C++编写的库。虽然在现代化工具链的支持下，这个工作的难度已经大大降低，但是毕竟万事开头难，初学者往往还是会遇到很多不可预测的问题。本篇就是基于此背景下写的一份简陋指南，希望能对刚开始编写C/C++库的读者有所帮助。同时为了尽可能减少认知断层，本篇将试着从一个最简单的功能开始，逐步添加工具链，直到实现最终功能，真正做到知其然且之所以然。&lt;/p></description></item><item><title>Linux批量文件操作——基于find,xargs</title><link>https://bravebuffalo.cc/post/Linux%E6%89%B9%E9%87%8F%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E2%80%94%E2%80%94%E5%9F%BA%E4%BA%8Efind,xargs.html</link><pubDate>Fri, 18 Feb 2022 21:19:39 +0800</pubDate><guid>https://bravebuffalo.cc/post/Linux%E6%89%B9%E9%87%8F%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E2%80%94%E2%80%94%E5%9F%BA%E4%BA%8Efind,xargs.html</guid><description>前言 #在项目初创阶段，经常会遇到各种文件操作，拷贝头文件，库，批量重命名等。文件结构一复杂，这就将是个无聊的工作。
查找文件 #find可以在目录结构中搜索文件，这是它在man里面的作用描述。那么怎么搜索呢？有多种方式，按文件时间，大小，按文件名，路径名，按文件类型，权限，按用户。而这些方式又可以通过与或非的逻辑相互组合，完成更苛刻的查找工作，简直是文件查找的福音。 通常介绍一种命令都会以命令形式开始，find的格式如下
find [-H] [-L] [-P] [-D debugopts] [-Olevel] [starting-point...] [expression] [-H] [-L] [-P] [-D debugopts] [-Olevel]这一些统统不重要， [-H] [-L] [-P]是针对软连接的，不常用。[-D debugopts]是显示运行期间的额外信息，信息太乱太杂，用处不大。[-Olevel]则是用于优化查找的，默认的已经够用，所以也没必要深究。 find的最大魔法在最后的[expression],下面将以实例的形式讲解这个[expression]到底该怎么玩，原始的文件结构如下
├── alice.h ├── andy │ ├── jack │ │ └── mary.h │ ├── mark.cpp │ ├── mark.h │ └── pony.txt ├── andy.c ├── bill.cpp ├── bill.</description></item><item><title>用纯HTML，JS，CSS实现横向滚动标签页</title><link>https://bravebuffalo.cc/post/%E7%94%A8%E7%BA%AFHTML%EF%BC%8CJS%EF%BC%8CCSS%E5%AE%9E%E7%8E%B0%E6%A8%AA%E5%90%91%E6%BB%9A%E5%8A%A8%E6%A0%87%E7%AD%BE%E9%A1%B5.html</link><pubDate>Sat, 12 Feb 2022 09:23:30 +0800</pubDate><guid>https://bravebuffalo.cc/post/%E7%94%A8%E7%BA%AFHTML%EF%BC%8CJS%EF%BC%8CCSS%E5%AE%9E%E7%8E%B0%E6%A8%AA%E5%90%91%E6%BB%9A%E5%8A%A8%E6%A0%87%E7%AD%BE%E9%A1%B5.html</guid><description>&lt;h3 id="前言" class="relative group">前言 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e5%89%8d%e8%a8%80" aria-label="锚点">#&lt;/a>&lt;/span>&lt;/h3>&lt;p>前不久，在我的一个项目中，需要展示一个横向滚动的标签页，它支持鼠标横向拖动和点击切换。在实现的过程中，我发现这个小功能需要同时用到前端的三辆马车，但是实现难度不高，而且最终效果还不错，是个难得的初学者项目，于是萌生了写这篇文章的想法，希望对初学者有所帮助。同时为了避免初学者学习框架，我打算用纯原生的方式实现它。&lt;/p></description></item><item><title>Android-JNI开发概论</title><link>https://bravebuffalo.cc/post/Android-JNI%E5%BC%80%E5%8F%91%E6%A6%82%E8%AE%BA.html</link><pubDate>Sun, 12 Sep 2021 21:34:45 +0800</pubDate><guid>https://bravebuffalo.cc/post/Android-JNI%E5%BC%80%E5%8F%91%E6%A6%82%E8%AE%BA.html</guid><description>&lt;h1 id="什么是jni开发" class="relative group">什么是JNI开发 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e4%bb%80%e4%b9%88%e6%98%afjni%e5%bc%80%e5%8f%91" aria-label="锚点">#&lt;/a>&lt;/span>&lt;/h1>&lt;p>JNI的全称是Java Native Interface，顾名思义，这是一种解决Java和C/C++相互调用的编程方式。&lt;em>&lt;strong>它其实只解决两个方面的问题，怎么找到和怎么访问。&lt;/strong>&lt;/em> 弄清楚这两个话题，我们就学会了JNI开发。&lt;em>&lt;strong>需要注意的是，JNI开发只涉及到一小部分C/C++开发知识，遇到问题的时候我们首先要判断是C/C++的问题还是JNI的问题，这可以节省很多搜索和定位的时间。&lt;/strong>&lt;/em>&lt;/p></description></item><item><title>CMake个人理解和使用</title><link>https://bravebuffalo.cc/post/CMake%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3%E5%92%8C%E4%BD%BF%E7%94%A8.html</link><pubDate>Mon, 09 Aug 2021 19:21:49 +0800</pubDate><guid>https://bravebuffalo.cc/post/CMake%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3%E5%92%8C%E4%BD%BF%E7%94%A8.html</guid><description>&lt;h1 id="前言" class="relative group">前言 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e5%89%8d%e8%a8%80" aria-label="锚点">#&lt;/a>&lt;/span>&lt;/h1>&lt;p>CMake是一个构建工具，通过它可以很容易创建跨平台的项目。通常使用它构建项目要分两步，通过源代码生成工程文件，通过工程文件构建目标产物（可能是动态库，静态库，也可能是可执行程序）。使用CMake的一个主要优势是在多平台或者多人协作的项目中，开发人员可以根据自己的喜好来使选择IDE，不用受其他人工程配置的影响，它有点像跨平台的IDE，通过它配置好相关设置之后，可以在多个平台无缝衔接，提高开发效率。&lt;/p></description></item><item><title>Kotlin协程-从一到多</title><link>https://bravebuffalo.cc/post/Kotlin%E5%8D%8F%E7%A8%8B-%E4%BB%8E%E4%B8%80%E5%88%B0%E5%A4%9A.html</link><pubDate>Tue, 30 Mar 2021 19:10:30 +0800</pubDate><guid>https://bravebuffalo.cc/post/Kotlin%E5%8D%8F%E7%A8%8B-%E4%BB%8E%E4%B8%80%E5%88%B0%E5%A4%9A.html</guid><description>上一篇文章，我介绍了Kotlin协程的创建，使用，协作等内容。本篇将引入更多的使用场景，继续带你走进协程世界。
使用协程处理异步数据流 #常用编程语言都会内置对同一类型不同对象的数据集表示，我们通常称之为容器类。不同的容器类适用于不同的使用场景。Kotlin的Flow就是在异步计算的需求下引入的，用于表示异步的数据流。
Flow #“问渠哪得清如许，为有源头活水来”，异步数据流的基本就是以某种方式获得异步数据。Kotlin提供了多种种方式，比较常用的就是Kotlin协程包的asFlow扩展和flow构造器。前者是对普通数据集的Flow化封装，没有更多可言，我们着重来看后者。 flow构造器的主要目标就是产生一个异步数据流，它是一个泛型函数，参数是一个挂起函数，并且是FlowCollector是扩展函数。这个接口只有一个emit方法，就是为创建的Flow提供异步计算的数据的，因为它是挂起函数，所以我们能在里面使用其他挂起函数计算异步值，然后通过emit方法将值发送出去，如此反复就能为下游操作提供源源不断的数据流了。 事情还没完，上面的步骤我们只是规定了创建数据的方式，并没有真正执行，也就是建好了道路，但是还没有车上路。那么，怎样才能让车在路上跑呢，查看Flow的接口会发现，它提供了collect方法来处理数据。collect接收一个挂起函数作为处理逻辑，但是同时，collect方法本身也是挂起函数，所以，这个方法只能在挂起函数中运行。有了这些知识，我们就可以写出最简单的异步数据流了。
1uspend fun compute():Int{ delay(123) return 1024 } viewModelScope.launch { val flow=flow&amp;lt;Int&amp;gt; { emit(9527) emit(compute()) delay(256) emit(256) } flow.collect { println(it) } } 在flow构造器里面随意做各种操作，只要在必要的时候传递结果就行了，但是需要注意的是，emit方法只能运行在同一个协程里。乍一看，这样分开写和写在一起并没有本质上的差别，但Flow还能做到更多。
该给Flow换个工作环境了 #上一节，我们那个简单的示例，假如把构造器里面的数据获取方法换成网络请求，应用就歇菜了。因为它们都是运行在主线程里面的。那么这个时候，看过上一篇文章的小伙伴马上就会反应过来，用withContext方法在构造器里面切换线程就行了哇。思路是很对，因为Flow的默认配置就是构造器和collect方法工作在同一线程，既然现在主线程不让运行，那就把构造器的线程切换一下就行了呗。然后事实并不是这样，这样写出来的代码根本无法运行。因为官方提供了唯一的flowOn方法来切换构造器的执行线程。使用也很简单，就是对创建好的Flow对象配置一次flowOn方法就行了。
val flow=[&amp;#34;1.jpg&amp;#34;,&amp;#34;2.jpg&amp;#34;].asFlow() flow.map { decode(it) } .flowOn(Dispatchers.IO) viewModelScope.launch { flow.collect{ adapter.add(it) } 有些中间处理逻辑 #熟悉RxJava的小伙伴可能有疑问了，这些操作RxJava也能完成，甚至还有更多的操作符来支持中间状态的处理，那么异步数据流能做到这些吗。毫无疑问，它可以。普通的数据集有map,filter等操作方法，对于异步数据流来说，这些方法同样适用。而且这些方法参数都是挂起函数，都可以执行异步操作。而且它还有个更灵活的transform方法，这个方法可以定制自己的操作符，实现更灵活的数据操作。
当然，上面那些操作符都只能实现单一异步流的操作，对于多数据流的支持，它也同样不在话下。zip可以将两个两个数据源两两合并起来，合成的数据流长度为两个数据流中最短的那个数据流的长度。combine则与zip不同，它会将两个数据流最近的发送数据作为输入，也就是说，假如一块一慢的两个数据源，慢的数据源的元素可能会被多次取到，从而最终的数据流比最短的那个都长。
val flow = flowOf(1, 2).</description></item><item><title>Kotlin协程-从理论到实战</title><link>https://bravebuffalo.cc/post/Kotlin%E5%8D%8F%E7%A8%8B-%E4%BB%8E%E7%90%86%E8%AE%BA%E5%88%B0%E5%AE%9E%E6%88%98.html</link><pubDate>Sat, 27 Mar 2021 19:02:30 +0800</pubDate><guid>https://bravebuffalo.cc/post/Kotlin%E5%8D%8F%E7%A8%8B-%E4%BB%8E%E7%90%86%E8%AE%BA%E5%88%B0%E5%AE%9E%E6%88%98.html</guid><description>上一篇文章从理论上对Kotlin协程进行了部分说明，本文将在上一篇的基础上，从实战出发，继续协程之旅。
从源头说起 #在Kotlin中，要想使用协程，首先需要使用协程创建器创建，但还有个前提——协程作用域(CoroutineScope)。在早期的Kotlin实现中，协程创建器是一等函数，也就是说我们随时随地可以通过协程创建器创建协程。但在协程正式发布以后，协程创建器需要在协程作用域对象上才能创建了，Kotlin添加了协程作用域来实现结构化并发。什么是结构化并发呢，通俗地说就是正确实施多个协程监控、管理的能力。在实际业务中，我们可能需要创建多个协程对象来完成不同的工作。为了对这些不相关的协程管理起来，Kotlin引入了协程作用域，通过某个协程作用域创建的协程都会被它管理着，在条件满足的时候，执行每个协程的取消工作或者结束自己。
为了方便我们直接上手，官方提供了MainScope和GlobalScope供我们使用。正如名字那样，他们分别有不同的应用场景，前者比较适合用在UI相关的类中，而后者适用于在整个应用生命周期中都需要存活的类中。当然，对于Android开发者，其实我们有更好的选择——使用ViewModel的Kotlin扩展，它不仅有着全部的协程作用域功能，开箱即用，而且还在onCleared方法中实现了自动取消。
创建协程 #有了协程作用域，那我们来创建一个最简单的协程吧。
viewModelScope.launch{ //这里就是协程代码啦啦啦啦 delay(2000) System.out.println(&amp;#34;Hello World&amp;#34;) } launch创建并启动了一个协程，协程启动两秒后，在控制抬打印了Hello World，然后协程就结束了（协程是有完整生命周期的）。这个协程完成的工作有限，我们可以使用线程完成相同的功能:
thread { Thread.sleep(2000) System.out.println(&amp;#34;Hello World&amp;#34;) } 我们可以看到，除去构建函数，两段代码唯一的区别就是延迟函数——delay和Thread.sleep.从功能上看他们都是让后面的代码延迟执行，但是效果却是不一样的，前者不会阻塞线程。这段代码其实是放在主线程里面执行的，但是它不会影响到UI的绘制，而后者假如把它放在主线程执行的话，应用会出现两秒的无响应。Kotlin把这种不会阻塞当前线程执行的函数称之为挂起函数，挂起函数可以在挂起点断开与当前线程的联系，让线程空闲下来完成其他的操作，当条件满足后，挂起函数重新在挂起点恢复，接着往下执行后面的代码。
还有个小问题没有解决，在上一篇文章中，我曾经说过，挂起函数只能在挂起函数中执行，既然delay是挂起函数，那么反推，我们的代码块也应该是个挂起函数，而这个挂起函数就是所谓的协程体。
让协程跨线程工作 #如果你看到上面的代码，然后转手在协程体里面写个网络请求的话，你会发现，你的应用崩溃了，这是怎么回事呢？因为协程虽然不会阻塞主线程，但是主线程是不允许进行网络请求的。如果这时你就急着下了协程没啥用的结论，那么你就肤浅了。让我们稍微改一改上面的代码，让它运行在子线程吧。
viewModelScope.launch (Dispatchers.IO){ //这里就是协程代码啦啦啦啦 delay(2000) System.out.println(&amp;#34;Hello World&amp;#34;) } 很好，现在协程体里面的网络请求可以顺利执行了，但是很快有读者就会发现新问题了——我怎么把网络请求的结果传回主线程呢，难不成还搞个Handler,那和直接使用线程有什么区别，辣鸡协程。嘿，别急，这个协程其实也为客官处理好了。让我们再次改造一下代码：
viewModelScope.launch (Dispatchers.IO){ //这里就是协程代码啦啦啦啦，这里是在子线程执行的代码哦 //假装这个是网络请求吧 delay(2000) withContext(Dispatchers.Main) { //哦豁豁，这里竟然运行在主线程哦 System.out.println(&amp;#34;Hello World&amp;#34;) } } 很好，我们可以愉快地使用协程处理网络请求了，那么这些魔法是怎么发生的呢，停下脚步，我们来重新审视一下上面的代码。
首先，相比于最开始的代码，我们的代码里多了两个对象，一个方法调用。首先我们来看那两个对象，从名字中我们不难猜到它就是调度线程的。 Kotlin提供了四个常用的实现
Default,它是标准协程构建者默认使用的调度器，使用共享的线程池工作，适用于计算型的任务；
Main,它是代表UI线程的调度器，通常来说只有一个线程，使用这个调度器就可以直接在协程中操作UI;</description></item><item><title>Kotlin协程-那些理不清乱不明的关系</title><link>https://bravebuffalo.cc/post/Kotlin%E5%8D%8F%E7%A8%8B-%E9%82%A3%E4%BA%9B%E7%90%86%E4%B8%8D%E6%B8%85%E4%B9%B1%E4%B8%8D%E6%98%8E%E7%9A%84%E5%85%B3%E7%B3%BB.html</link><pubDate>Fri, 26 Mar 2021 18:50:29 +0800</pubDate><guid>https://bravebuffalo.cc/post/Kotlin%E5%8D%8F%E7%A8%8B-%E9%82%A3%E4%BA%9B%E7%90%86%E4%B8%8D%E6%B8%85%E4%B9%B1%E4%B8%8D%E6%98%8E%E7%9A%84%E5%85%B3%E7%B3%BB.html</guid><description>Kotlin的协程自推出以来，受到了越来越多Android开发者的追捧。另一方面由于它庞大的API，也将相当一部分开发者拒之门外。本篇试图从协程的几个重要概念入手，在复杂API中还原出它本来的面目，以全新的角度带读者走进Kotlin协程世界。
什么是协程 #在很多有关协程的文章中，描述协程通常会用这样的一句描述——协程比线程更加轻量，是可取消的。这句话没有错，这两个都是协程的优点，但是并不是特点，它并没有解释协程是什么。那么什么是协程的特点呢，我觉得可以先用线程做个类比，解释一个概念最好的办法就是类比。 我不打算使用科学严谨的描述，我想给线程一个我自己的定义——线程是一个可供CPU调度的执行单元，它有自己的执行块，可以独立地执行逻辑。我特意将线程的三个关键特征列举出来了：
线程由CPU调度 线程拥有自己的代码块 代码块需要才能调度执行 这是我对线程的直观感受，并且这些特点是能从代码上体现出来的。如Java中的Thread，它是线程的同时，也是一个实体对象，能通过API来认识它，使用它。而它的特别之处就是我上面列举的三点，这些都是线程特有的。我试着用相同的思路来给协程下一个自己的定义——协程是由线程调度执行的执行单元，它也有自己的执行块，可以独立或者协同执行逻辑。其实Kotlin中的协程也有自己对应实体和操作API，甚至和线程的还很像(如生命周期），但是由于Kotlin对协程的封装过于彻底，很多API没有暴露出来，以至于我对协程的认识一直处于盲人摸象的状态。另外，其实协程是有多种实现方式的，以下我的观点仅针对Kotlin的协程实现，可能与其他语言的实现不一致。
Kotlin中的协程对象本质上来讲就是个可执行的代码块， 执行的代码就是创建协程传递进去的。除此之外它还有个最大的特点——协程是不和线程绑定的。它可以在某个时刻断开当前的线程，然后在其他时候，附着到其他线程上。也就是说，它像一个乒乓球，线程就好比是球拍，它可以在球拍间反复横跳。所以，结合这两个特点，官方给协程的定义是 一个可挂起的计算实体。我觉得这个定义不算精确，它只体现了挂起这个概念，没有体现恢复的概念。我给它一个我自己的定义——一个可被调度的计算实体。
协程中几个关键概念 #明白了协程是什么还不够，因为Kotlin的协程还涉及到很多方面，有几个关键概念需要理解。
挂起函数 #提到Kotlin的协程就不得不提到挂起函数，这是Kotlin协程实现的最重要的概念之一。简单来说，挂起函数是一种异步实现方案，它是一个普通函数的前提下，还具备挂起和恢复的特性。 它是解决耗时计算和结果传递的一种方案。那么它和我们常见的基于回调的方案相比，有什么不同呢。在基于回调的方案中，计算过程和结果没有关系，结果需要通过另一个对象，在计算完成后由计算过程手动传递，而这一过程是可能被反复嵌套的，从而导致，一些本该是串行化的代码，被割裂成几个部分，分散到不同的代码块中。如以下读写文件的代码
// asynchronously read into `buf`, and when done run the lambda inChannel.read(buf) { // this lambda is executed when the reading completes bytesRead -&amp;gt; ... ... process(buf, bytesRead) // asynchronously write from `buf`, and when done run the lambda outChannel.</description></item><item><title>沉思篇-剖析Jetpack的ViewModel</title><link>https://bravebuffalo.cc/post/%E6%B2%89%E6%80%9D%E7%AF%87-%E5%89%96%E6%9E%90Jetpack%E7%9A%84LiveData.html</link><pubDate>Wed, 24 Mar 2021 18:18:30 +0800</pubDate><guid>https://bravebuffalo.cc/post/%E6%B2%89%E6%80%9D%E7%AF%87-%E5%89%96%E6%9E%90Jetpack%E7%9A%84LiveData.html</guid><description>&lt;blockquote>
&lt;p>ViewModel做为架构组件的三元老之一，是实现MVVM的有力武器。&lt;/p>
&lt;/blockquote>
&lt;h1 id="viewmodel的设计目标" class="relative group">ViewModel的设计目标 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#viewmodel%e7%9a%84%e8%ae%be%e8%ae%a1%e7%9b%ae%e6%a0%87" aria-label="锚点">#&lt;/a>&lt;/span>&lt;/h1>&lt;p>ViewModel的基本功能就是管理UI的数据。其实，从职责上来说，这又是对Activity和Fragment的一次功能拆分。以前存储在它们内部的数据，需要它们自己处理创建，更新，存储，恢复的所有过程，同时它们还要处理UI的数据绑定，更新，动画等操作。职责的多元化就容易出现不好定位和调试的问题。另外，Activity和Fragment作为UI的承载者，很多时候需要共享数据和复用功能。而UI的差异让复用的粒度划分很难把控，容易写出扩展性差的代码。基于这些痛点，ViewModel被设计出来了。
同时ViewModel还将保存数据的功能强化了——它将设备配置变更后数据保存和恢复自动化了，在UI生命周期内都能保证数据的有效性，这大大减少了样板代码的编写，提高了开发效率。&lt;/p></description></item><item><title>沉思篇-剖析Jetpack的LiveData</title><link>https://bravebuffalo.cc/post/%E6%B2%89%E6%80%9D%E7%AF%87-%E5%89%96%E6%9E%90Jetpack%E7%9A%84LiveData.html</link><pubDate>Tue, 23 Mar 2021 18:14:09 +0800</pubDate><guid>https://bravebuffalo.cc/post/%E6%B2%89%E6%80%9D%E7%AF%87-%E5%89%96%E6%9E%90Jetpack%E7%9A%84LiveData.html</guid><description>&lt;blockquote>
&lt;p>上一篇我们讲到了架构组件中的Lifecycle，由于缺少具体的运用，可能缺少直观的感受，今天我们就用Lifecycle实战一回，看看Lifecycle是怎样运用到LiveData中的。&lt;/p>
&lt;/blockquote>
&lt;h1 id="livedata的功能" class="relative group">LiveData的功能 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#livedata%e7%9a%84%e5%8a%9f%e8%83%bd" aria-label="锚点">#&lt;/a>&lt;/span>&lt;/h1>&lt;p>根据&lt;code>LiveData&lt;/code>的类注释，我们可以知道，&lt;code>LiveData&lt;/code>是一个实现了观察者模式的数据容器，并且是可感知生命周期的。由这个功能描述，我们就能知道&lt;code>LiveData&lt;/code>是由两部分功能合并而来的，一部分是数据容器，一部分是响应生命周期。在阅读源码的时候，我觉得功能拆解是个很有用的手段，合理的功能拆解，就是有目的的省略，有助于快速理清功能实现逻辑。
接下来，我将以这两个功能为突破点，逐一梳理&lt;code>LiveData&lt;/code>的实现思路。&lt;/p></description></item><item><title>沉思篇-剖析JetPack的Lifecycle</title><link>https://bravebuffalo.cc/post/%E6%B2%89%E6%80%9D%E7%AF%87-%E5%89%96%E6%9E%90JetPack%E7%9A%84Lifecycle.html</link><pubDate>Sun, 21 Mar 2021 15:56:53 +0800</pubDate><guid>https://bravebuffalo.cc/post/%E6%B2%89%E6%80%9D%E7%AF%87-%E5%89%96%E6%9E%90JetPack%E7%9A%84Lifecycle.html</guid><description>&lt;blockquote>
&lt;p>这几年，对于Android开发者来说，最时髦的技术当属Jetpack了。谷歌官方从19年开始，就在极力推动Jetpack的使用，经过这几年的发展，Jetpack也基本完成了当时的设计目标——简单，一致，专注。而使得这一切成为可能的基石，我觉得当属架构组件了。最初架构组件作为单独的库和support库并没有太多联系，随着Jetpack的成型，给架构组件也注入了新的活力。在Jetpack库中，建构组件的使用随处可见，扮演着越来越重要的角色。今天，我就以作为架构组件基石的Lifecycle开始，尝试对架构组件进行剖析，向大家展示谷歌开发者是怎样设计一个高内聚，低耦合的库的。&lt;/p>
&lt;/blockquote></description></item></channel></rss>