<!doctype html><html lang=zh-CN dir=ltr class=scroll-smooth data-default-appearance=light data-auto-appearance=true><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=theme-color content="#FFFFFF"><title>现代C++学习指南 模板 &#183; 低头沉思</title>
<meta name=title content="现代C++学习指南 模板 &#183; 低头沉思"><script type=text/javascript src=/js/appearance.min.8a082f81b27f3cb2ee528df0b0bdc39787034cf2cc34d4669fbc9977c929023c.js integrity="sha256-iggvgbJ/PLLuUo3wsL3Dl4cDTPLMNNRmn7yZd8kpAjw="></script><link type=text/css rel=stylesheet href=/css/main.bundle.min.b0785c8131a75f72b211435af86269eb2d4b81dda03a8f2cf5ccb1c967747167.css integrity="sha256-sHhcgTGnX3KyEUNa+GJp6y1Lgd2gOo8s9cyxyWd0cWc="><script defer type=text/javascript id=script-bundle src=/js/main.bundle.min.af5d9722112bedac95702865c340bcd6286c4e9b2c15ce26b531ea1fba974cb8.js integrity="sha256-r12XIhEr7ayVcChlw0C81ihsTpssFc4mtTHqH7qXTLg=" data-copy data-copied></script><meta name=description content="
      现代C++学习指南 模板
    "><link rel=canonical href=https://deep-thinking.top/posts/modern-c++-study-guide-template/><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><meta property="og:url" content="https://deep-thinking.top/posts/modern-c++-study-guide-template/"><meta property="og:site_name" content="低头沉思"><meta property="og:title" content="现代C++学习指南 模板"><meta property="og:description" content="现代C++学习指南 模板"><meta property="og:locale" content="zh_CN"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-10-31T21:33:38+08:00"><meta property="article:modified_time" content="2022-10-31T21:33:38+08:00"><meta property="article:tag" content="学习指南"><meta property="article:tag" content="C++"><meta name=twitter:card content="summary"><meta name=twitter:title content="现代C++学习指南 模板"><meta name=twitter:description content="现代C++学习指南 模板"><script type=application/ld+json>{"@context":"https://schema.org","@type":"Article","articleSection":"Posts","name":"现代C\u002b\u002b学习指南 模板","headline":"现代C\u002b\u002b学习指南 模板","description":"现代C\u002b\u002b学习指南 模板","abstract":"\u003cblockquote\u003e\n\u003cp\u003e模板作为C\u002b\u002b重要的特性，一直有着举足轻重的地位，是编写高度抽象代码的利器。\u003c\/p\u003e\n\u003c\/blockquote\u003e\n\u003ch3 id=\u0022什么是模板\u0022 class=\u0022relative group\u0022\u003e什么是模板 \u003cspan class=\u0022absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100\u0022\u003e\u003ca class=\u0022group-hover:text-primary-300 dark:group-hover:text-neutral-700\u0022 style=\u0022text-decoration-line: none !important;\u0022 href=\u0022#%e4%bb%80%e4%b9%88%e6%98%af%e6%a8%a1%e6%9d%bf\u0022 aria-label=\u0022\u0022\u003e#\u003c\/a\u003e\u003c\/span\u003e\u003c\/h3\u003e\u003cp\u003e模板在现实生活中就是范例：把都一样的部分固定起来，把变动的部分空出来，使用时将两部分合起来组成有效的东西。如申请书，Word模板都是这种形式。C\u002b\u002b中的模板也是如此，不过更明确的是C\u002b\u002b中的模板，变动的部分是一个代指类型的东西，称之为泛型参数。\u003c\/p\u003e\n\u003cp\u003e我们先从一个例子来看一看模板是怎样发展而来的。如我们需要计算两个对象相加的结果，该如何写代码呢？在写代码前，我们有几个问题需要讨论清楚：\n首先我们需要\u003cstrong\u003e确定\u003c\/strong\u003e的是这两个\u003cstrong\u003e对象\u003c\/strong\u003e是什么\u003cstrong\u003e类型\u003c\/strong\u003e，毕竟C\u002b\u002b是强类型的编程语言，变量，函数，类都是要明确指定类型是什么的，不确定的类型编译就不能通过。我们先假设这两个类型是整型。确定了类型之后，还需要确定这两个对象需要怎样加起来，根据我们假设的整型，我们知道可以直接调用运算符\u003ccode\u003e\u002b\u003c\/code\u003e。最后我们需要确定，两个对象相加后的结果类型是什么，整型相加的结果也是整型。综上，这个例子的代码看起来可能是这样的\u003c\/p\u003e\n\u003cdiv class=\u0022highlight\u0022\u003e\u003cpre tabindex=\u00220\u0022 class=\u0022chroma\u0022\u003e\u003ccode class=\u0022language-cpp\u0022 data-lang=\u0022cpp\u0022\u003e\u003cspan class=\u0022line\u0022\u003e\u003cspan class=\u0022cl\u0022\u003e\u003cspan class=\u0022kt\u0022\u003eint\u003c\/span\u003e \u003cspan class=\u0022nf\u0022\u003esum\u003c\/span\u003e\u003cspan class=\u0022p\u0022\u003e(\u003c\/span\u003e\u003cspan class=\u0022kt\u0022\u003eint\u003c\/span\u003e \u003cspan class=\u0022n\u0022\u003eleft\u003c\/span\u003e\u003cspan class=\u0022p\u0022\u003e,\u003c\/span\u003e\u003cspan class=\u0022kt\u0022\u003eint\u003c\/span\u003e \u003cspan class=\u0022n\u0022\u003eright\u003c\/span\u003e\u003cspan class=\u0022p\u0022\u003e){\u003c\/span\u003e\n\u003c\/span\u003e\u003c\/span\u003e\u003cspan class=\u0022line\u0022\u003e\u003cspan class=\u0022cl\u0022\u003e\t\u003cspan class=\u0022k\u0022\u003ereturn\u003c\/span\u003e \u003cspan class=\u0022n\u0022\u003eleft\u003c\/span\u003e \u003cspan class=\u0022o\u0022\u003e\u002b\u003c\/span\u003e \u003cspan class=\u0022n\u0022\u003eright\u003c\/span\u003e\u003cspan class=\u0022p\u0022\u003e;\u003c\/span\u003e\n\u003c\/span\u003e\u003c\/span\u003e\u003cspan class=\u0022line\u0022\u003e\u003cspan class=\u0022cl\u0022\u003e\u003cspan class=\u0022p\u0022\u003e}\u003c\/span\u003e\n\u003c\/span\u003e\u003c\/span\u003e\u003c\/code\u003e\u003c\/pre\u003e\u003c\/div\u003e\u003cp\u003e这个例子很简单，简单到甚至都不需要单独写成一个函数。如果我们需要计算的数据不是两个数，而是一个数组的和呢？基于前面的分析和假设，我们也能很快实现相应的代码\u003c\/p\u003e\n\u003cdiv class=\u0022highlight\u0022\u003e\u003cpre tabindex=\u00220\u0022 class=\u0022chroma\u0022\u003e\u003ccode class=\u0022language-cpp\u0022 data-lang=\u0022cpp\u0022\u003e\u003cspan class=\u0022line\u0022\u003e\u003cspan class=\u0022cl\u0022\u003e\u003cspan class=\u0022kt\u0022\u003eint\u003c\/span\u003e \u003cspan class=\u0022nf\u0022\u003esum\u003c\/span\u003e\u003cspan class=\u0022p\u0022\u003e(\u003c\/span\u003e\u003cspan class=\u0022k\u0022\u003econst\u003c\/span\u003e \u003cspan class=\u0022kt\u0022\u003eint\u003c\/span\u003e \u003cspan class=\u0022n\u0022\u003edata\u003c\/span\u003e\u003cspan class=\u0022p\u0022\u003e[],\u003c\/span\u003e \u003cspan class=\u0022k\u0022\u003econst\u003c\/span\u003e \u003cspan class=\u0022n\u0022\u003estd\u003c\/span\u003e\u003cspan class=\u0022o\u0022\u003e::\u003c\/span\u003e\u003cspan class=\u0022n\u0022\u003esize_t\u003c\/span\u003e \u003cspan class=\u0022n\u0022\u003elength\u003c\/span\u003e\u003cspan class=\u0022p\u0022\u003e)\u003c\/span\u003e \u003cspan class=\u0022p\u0022\u003e{\u003c\/span\u003e\n\u003c\/span\u003e\u003c\/span\u003e\u003cspan class=\u0022line\u0022\u003e\u003cspan class=\u0022cl\u0022\u003e\t\u003cspan class=\u0022kt\u0022\u003eint\u003c\/span\u003e \u003cspan class=\u0022n\u0022\u003eresult\u003c\/span\u003e\u003cspan class=\u0022p\u0022\u003e{};\u003c\/span\u003e\n\u003c\/span\u003e\u003c\/span\u003e\u003cspan class=\u0022line\u0022\u003e\u003cspan class=\u0022cl\u0022\u003e\t\u003cspan class=\u0022k\u0022\u003efor\u003c\/span\u003e \u003cspan class=\u0022p\u0022\u003e(\u003c\/span\u003e\u003cspan class=\u0022kt\u0022\u003eint\u003c\/span\u003e \u003cspan class=\u0022n\u0022\u003ei\u003c\/span\u003e \u003cspan class=\u0022o\u0022\u003e=\u003c\/span\u003e \u003cspan class=\u0022mi\u0022\u003e0\u003c\/span\u003e\u003cspan class=\u0022p\u0022\u003e;\u003c\/span\u003e \u003cspan class=\u0022n\u0022\u003ei\u003c\/span\u003e \u003cspan class=\u0022o\u0022\u003e\u0026lt;\u003c\/span\u003e \u003cspan class=\u0022n\u0022\u003elength\u003c\/span\u003e\u003cspan class=\u0022p\u0022\u003e;\u003c\/span\u003e\u003cspan class=\u0022o\u0022\u003e\u002b\u002b\u003c\/span\u003e\u003cspan class=\u0022n\u0022\u003ei\u003c\/span\u003e\u003cspan class=\u0022p\u0022\u003e)\u003c\/span\u003e \u003cspan class=\u0022p\u0022\u003e{\u003c\/span\u003e\n\u003c\/span\u003e\u003c\/span\u003e\u003cspan class=\u0022line\u0022\u003e\u003cspan class=\u0022cl\u0022\u003e\t\t\u003cspan class=\u0022n\u0022\u003eresult\u003c\/span\u003e \u003cspan class=\u0022o\u0022\u003e\u002b=\u003c\/span\u003e \u003cspan class=\u0022o\u0022\u003e*\u003c\/span\u003e\u003cspan class=\u0022p\u0022\u003e(\u003c\/span\u003e\u003cspan class=\u0022n\u0022\u003edata\u003c\/span\u003e \u003cspan class=\u0022o\u0022\u003e\u002b\u003c\/span\u003e \u003cspan class=\u0022n\u0022\u003ei\u003c\/span\u003e\u003cspan class=\u0022p\u0022\u003e);\u003c\/span\u003e\n\u003c\/span\u003e\u003c\/span\u003e\u003cspan class=\u0022line\u0022\u003e\u003cspan class=\u0022cl\u0022\u003e\t\u003cspan class=\u0022p\u0022\u003e}\u003c\/span\u003e\n\u003c\/span\u003e\u003c\/span\u003e\u003cspan class=\u0022line\u0022\u003e\u003cspan class=\u0022cl\u0022\u003e\t\u003cspan class=\u0022k\u0022\u003ereturn\u003c\/span\u003e \u003cspan class=\u0022n\u0022\u003eresult\u003c\/span\u003e\u003cspan class=\u0022p\u0022\u003e;\u003c\/span\u003e\n\u003c\/span\u003e\u003c\/span\u003e\u003cspan class=\u0022line\u0022\u003e\u003cspan class=\u0022cl\u0022\u003e\u003cspan class=\u0022p\u0022\u003e}\u003c\/span\u003e\n\u003c\/span\u003e\u003c\/span\u003e\u003c\/code\u003e\u003c\/pre\u003e\u003c\/div\u003e\u003cp\u003e同样很简单。但是遗憾的是，这个函数通用性不强，它只能计算整型的数组和，假如我们需要计算带有小数点的数组和，它就不灵了，因为第一个参数类型不匹配，尽管我们知道\u003ccode\u003esum\u003c\/code\u003e的代码几乎都能复用，除了第一行的\u003ccode\u003eint\u003c\/code\u003e需要替换成\u003ccode\u003edouble\u003c\/code\u003e。但是不能！我们只能复制一份，然后把\u003ccode\u003eint\u003c\/code\u003e的地方改成\u003ccode\u003edouble\u003c\/code\u003e。\u003c\/p\u003e\n\u003cdiv class=\u0022highlight\u0022\u003e\u003cpre tabindex=\u00220\u0022 class=\u0022chroma\u0022\u003e\u003ccode class=\u0022language-cpp\u0022 data-lang=\u0022cpp\u0022\u003e\u003cspan class=\u0022line\u0022\u003e\u003cspan class=\u0022cl\u0022\u003e\u003cspan class=\u0022kt\u0022\u003edouble\u003c\/span\u003e \u003cspan class=\u0022nf\u0022\u003esum\u003c\/span\u003e\u003cspan class=\u0022p\u0022\u003e(\u003c\/span\u003e\u003cspan class=\u0022k\u0022\u003econst\u003c\/span\u003e \u003cspan class=\u0022kt\u0022\u003edouble\u003c\/span\u003e \u003cspan class=\u0022n\u0022\u003edata\u003c\/span\u003e\u003cspan class=\u0022p\u0022\u003e[],\u003c\/span\u003e \u003cspan class=\u0022k\u0022\u003econst\u003c\/span\u003e \u003cspan class=\u0022n\u0022\u003estd\u003c\/span\u003e\u003cspan class=\u0022o\u0022\u003e::\u003c\/span\u003e\u003cspan class=\u0022n\u0022\u003esize_t\u003c\/span\u003e \u003cspan class=\u0022n\u0022\u003elength\u003c\/span\u003e\u003cspan class=\u0022p\u0022\u003e)\u003c\/span\u003e \u003cspan class=\u0022p\u0022\u003e{\u003c\/span\u003e\n\u003c\/span\u003e\u003c\/span\u003e\u003cspan class=\u0022line\u0022\u003e\u003cspan class=\u0022cl\u0022\u003e\t\u003cspan class=\u0022kt\u0022\u003edouble\u003c\/span\u003e \u003cspan class=\u0022n\u0022\u003eresult\u003c\/span\u003e\u003cspan class=\u0022p\u0022\u003e{};\u003c\/span\u003e\n\u003c\/span\u003e\u003c\/span\u003e\u003cspan class=\u0022line\u0022\u003e\u003cspan class=\u0022cl\u0022\u003e\t\u003cspan class=\u0022k\u0022\u003efor\u003c\/span\u003e \u003cspan class=\u0022p\u0022\u003e(\u003c\/span\u003e\u003cspan class=\u0022kt\u0022\u003eint\u003c\/span\u003e \u003cspan class=\u0022n\u0022\u003ei\u003c\/span\u003e \u003cspan class=\u0022o\u0022\u003e=\u003c\/span\u003e \u003cspan class=\u0022mi\u0022\u003e0\u003c\/span\u003e\u003cspan class=\u0022p\u0022\u003e;\u003c\/span\u003e \u003cspan class=\u0022n\u0022\u003ei\u003c\/span\u003e \u003cspan class=\u0022o\u0022\u003e\u0026lt;\u003c\/span\u003e \u003cspan class=\u0022n\u0022\u003elength\u003c\/span\u003e\u003cspan class=\u0022p\u0022\u003e;\u003c\/span\u003e\u003cspan class=\u0022o\u0022\u003e\u002b\u002b\u003c\/span\u003e\u003cspan class=\u0022n\u0022\u003ei\u003c\/span\u003e\u003cspan class=\u0022p\u0022\u003e)\u003c\/span\u003e \u003cspan class=\u0022p\u0022\u003e{\u003c\/span\u003e\n\u003c\/span\u003e\u003c\/span\u003e\u003cspan class=\u0022line\u0022\u003e\u003cspan class=\u0022cl\u0022\u003e\t\t\u003cspan class=\u0022n\u0022\u003eresult\u003c\/span\u003e \u003cspan class=\u0022o\u0022\u003e\u002b=\u003c\/span\u003e \u003cspan class=\u0022o\u0022\u003e*\u003c\/span\u003e\u003cspan class=\u0022p\u0022\u003e(\u003c\/span\u003e\u003cspan class=\u0022n\u0022\u003edata\u003c\/span\u003e \u003cspan class=\u0022o\u0022\u003e\u002b\u003c\/span\u003e \u003cspan class=\u0022n\u0022\u003ei\u003c\/span\u003e\u003cspan class=\u0022p\u0022\u003e);\u003c\/span\u003e\n\u003c\/span\u003e\u003c\/span\u003e\u003cspan class=\u0022line\u0022\u003e\u003cspan class=\u0022cl\u0022\u003e\t\u003cspan class=\u0022p\u0022\u003e}\u003c\/span\u003e\n\u003c\/span\u003e\u003c\/span\u003e\u003cspan class=\u0022line\u0022\u003e\u003cspan class=\u0022cl\u0022\u003e\t\u003cspan class=\u0022k\u0022\u003ereturn\u003c\/span\u003e \u003cspan class=\u0022n\u0022\u003eresult\u003c\/span\u003e\u003cspan class=\u0022p\u0022\u003e;\u003c\/span\u003e\n\u003c\/span\u003e\u003c\/span\u003e\u003cspan class=\u0022line\u0022\u003e\u003cspan class=\u0022cl\u0022\u003e\u003cspan class=\u0022p\u0022\u003e}\u003c\/span\u003e\n\u003c\/span\u003e\u003c\/span\u003e\u003c\/code\u003e\u003c\/pre\u003e\u003c\/div\u003e\u003cp\u003e这时你就会发现问题了，\u003cstrong\u003e这个过程，我们仅仅改变了类型信息\u003c\/strong\u003e。这样的问题还会继续增加，我们可能又需要求\u003ccode\u003efloat\u003c\/code\u003e的数组和，上面那个\u003ccode\u003edouble\u003c\/code\u003e的数组和同样匹配不了，因为\u003ccode\u003efloat\u003c\/code\u003e，\u003ccode\u003edouble\u003c\/code\u003e是两个类型。正是因为数据类型不一样，所以很多时候我们需要为不同的数据提供相似的代码，这在数据类型膨胀的情况下是很痛苦的，当对算法进行修改的时候我们需要保证所有的数据类型都被修改到，并且要逐个进行测试，这无疑会增加工作量，并放大错误率。但是实际有效的代码都是要明确类型的，如果类型不明确，编译器就没法确定代码是否合法，不确定的事情编译器就要报错，所以按照普通的思路，这个问题是无解的。\n但是其实很多时候，这些相似的代码仅仅是数据类型不一样而已，对付这种重复的工作应该让给计算机来完成，也就是编译器。所以我们需要一种技术，让\u003cstrong\u003e编译器先不管具体类型是什么，而是用一种特殊的类型来替换，这个类型可以替换成任何类型，用这个特殊的类型完成具体的算法，在使用的时候根据实际的需求，将类型信息提供给算法，让编译器生成满足所提供类型的具体算法，而这就是模板\u003c\/strong\u003e。这和生活中的模板思想上是共通的。算法是固定的部分，数据类型是可变的部分，两个合起来就是合法的C\u002b\u002b代码。也就是利用模板，我们可以只写一个算法，借助编译器生成所有类型的算法，这些算法之间唯一不同的就是类型。\n当然光有模板还不够，上面只解决了类型的问题，没有解决算法实现的问题。怎么说呢，如我们有一个需求，需要将数据先排序，再查找最大值。这对于数字（\u003ccode\u003eint\u003c\/code\u003e,\u003ccode\u003efloat\u003c\/code\u003e,\u003ccode\u003edouble\u003c\/code\u003e等）类型是有效的，直接使用比较运算符（\u003ccode\u003e\u0026lt;\u003c\/code\u003e,\u003ccode\u003e\u0026gt;\u003c\/code\u003e）就可以完成了，但是假如想让这个算法适用于自定义类型呢？直接在模板实现中写比较运算符对自定义类型是无效的，因为自定义类型没有实现相对应的比较运算函数。解决方法也很简单，自定义类型实现相对应的比较运算符就行了。诸如此类的问题，在模板中会经常遇到，因为我们对类型的信息一无所知，但是又要确保几乎所有的类型都能正常运作，这就不得不运用各种技术对类型进行限定或者检测，这其实才是模板问题的精髓。所以模板问题不仅仅是类型问题，还是其他C\u002b\u002b问题的综合体，需要对C\u002b\u002b特性有着较为完整的理解，才能写出有用高效的代码。\nC\u002b\u002b中通常将模板分为函数模板和模板类，我们先从比较简单的函数模板开始认识。\u003c\/p\u003e\n\u003ch3 id=\u0022函数模板\u0022 class=\u0022relative group\u0022\u003e函数模板 \u003cspan class=\u0022absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100\u0022\u003e\u003ca class=\u0022group-hover:text-primary-300 dark:group-hover:text-neutral-700\u0022 style=\u0022text-decoration-line: none !important;\u0022 href=\u0022#%e5%87%bd%e6%95%b0%e6%a8%a1%e6%9d%bf\u0022 aria-label=\u0022\u0022\u003e#\u003c\/a\u003e\u003c\/span\u003e\u003c\/h3\u003e\u003cp\u003e函数模板是一种函数，和普通函数不一样的地方是，它的参数列表中至少有一个是不确定类型的。我们用开头的例子来小试牛刀：\u003c\/p\u003e","inLanguage":"zh-CN","url":"https:\/\/deep-thinking.top\/posts\/modern-c\u002b\u002b-study-guide-template\/","author":{"@type":"Person","name":"低头沉思"},"copyrightYear":"2022","dateCreated":"2022-10-31T21:33:38\u002b08:00","datePublished":"2022-10-31T21:33:38\u002b08:00","dateModified":"2022-10-31T21:33:38\u002b08:00","keywords":["学习指南","C++"],"mainEntityOfPage":"true","wordCount":"783"}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","item":"https://deep-thinking.top/","name":"低头沉思","position":1},{"@type":"ListItem","item":"https://deep-thinking.top/posts/","name":"Posts","position":2},{"@type":"ListItem","item":"https://deep-thinking.top/categories/c++/","name":"C++","position":3},{"@type":"ListItem","name":"现代 C 学习指南 模板","position":4}]}</script><meta name=author content="低头沉思"><link href=mailto:honguilee@163.com rel=me><link href=https://github.com/hongui rel=me><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-9595252324232542" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-9W0KC5D9EZ"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-9W0KC5D9EZ")</script></head><body class="m-auto flex h-screen max-w-7xl flex-col bg-neutral px-6 text-lg leading-7 text-neutral-900 dark:bg-neutral-800 dark:text-neutral sm:px-14 md:px-24 lg:px-32"><div id=the-top class="absolute flex self-center"><a class="-translate-y-8 rounded-b-lg bg-primary-200 px-3 py-1 text-sm focus:translate-y-0 dark:bg-neutral-600" href=#main-content><span class="pe-2 font-bold text-primary-600 dark:text-primary-400">&darr;</span></a></div><header class="py-6 font-semibold text-neutral-900 dark:text-neutral sm:py-10 print:hidden"><nav class="flex items-start justify-between sm:items-center"><div class="flex flex-row items-center"><a href=/ class=mr-2><img src=/images/logo.png width=500 height=500 class="max-h-[10rem] max-w-[10rem] object-scale-down object-left" alt=低头沉思>
</a><a class="decoration-primary-500 hover:underline hover:decoration-2 hover:underline-offset-2" rel=me href=/>低头沉思</a></div><ul class="flex list-none flex-col text-end sm:flex-row"><li class="group mb-1 sm:mb-0 sm:me-7 sm:last:me-0.5"><a href=/posts/ title><span class="decoration-primary-500 group-hover:underline group-hover:decoration-2 group-hover:underline-offset-2">文章</span></a></li><li class="group mb-1 sm:mb-0 sm:me-7 sm:last:me-0.5"><a href=/categories/ title><span class="decoration-primary-500 group-hover:underline group-hover:decoration-2 group-hover:underline-offset-2">分类</span></a></li><li class="group mb-1 sm:mb-0 sm:me-7 sm:last:me-0.5"><a href=/tags/ title><span class="decoration-primary-500 group-hover:underline group-hover:decoration-2 group-hover:underline-offset-2">标签</span></a></li><li class="group mb-1 sm:mb-0 sm:me-7 sm:last:me-0.5"><a href=/about.html title><span class="decoration-primary-500 group-hover:underline group-hover:decoration-2 group-hover:underline-offset-2">关于</span></a></li><li class="group mb-1 sm:mb-0 sm:me-7 sm:last:me-0.5"><button id=search-button-1 title>
<span class="group-dark:hover:text-primary-400 transition-colors group-hover:text-primary-600"><span class="icon relative inline-block px-1 align-text-bottom"><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="search" class="svg-inline--fa fa-search fa-w-16" role="img" viewBox="0 0 512 512"><path fill="currentcolor" d="M505 442.7 405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9.0 208 0S0 93.1.0 208s93.1 208 208 208c48.3.0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9.0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7.0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7.0 128 57.2 128 128 0 70.7-57.2 128-128 128z"/></svg>
</span></span><span class="decoration-primary-500 group-hover:underline group-hover:decoration-2 group-hover:underline-offset-2"></span></button></li><li class="group mb-1 sm:mb-0 sm:me-7 sm:last:me-0.5"><div class="group relative"><button class="group-dark:hover:text-primary-400 flex w-full items-center justify-end transition-colors group-hover:text-primary-600">
<span class="icon relative inline-block px-1 align-text-bottom"><svg viewBox="0 0 16 16"><path fill="currentcolor" d="M4.545 6.714 4.11 8H3l1.862-5h1.284L8 8H6.833l-.435-1.286H4.545zm1.634-.736L5.5 3.956h-.049l-.679 2.022H6.18z"/><path fill="currentcolor" d="M0 2a2 2 0 012-2h7a2 2 0 012 2v3h3a2 2 0 012 2v7a2 2 0 01-2 2H7a2 2 0 01-2-2v-3H2A2 2 0 010 9V2zm2-1A1 1 0 001 2v7a1 1 0 001 1h7a1 1 0 001-1V2A1 1 0 009 1H2zm7.138 9.995c.193.301.402.583.63.846-.748.575-1.673 1.001-2.768 1.292.178.217.451.635.555.867 1.125-.359 2.08-.844 2.886-1.494.777.665 1.739 1.165 2.93 1.472.133-.254.414-.673.629-.89-1.125-.253-2.057-.694-2.82-1.284.681-.747 1.222-1.651 1.621-2.757H14V8h-3v1.047h.765c-.318.844-.74 1.546-1.272 2.13a6.066 6.066.0 01-.415-.492 1.988 1.988.0 01-.94.31z"/></svg>
</span><span class=text-sm>ZH-CN</span><span class=text-[0.6rem]><span class="icon relative inline-block px-1 align-text-bottom"><svg viewBox="0 0 512 512"><path fill="currentcolor" d="M233.4 406.6c12.5 12.5 32.8 12.5 45.3.0l192-192c12.5-12.5 12.5-32.8.0-45.3s-32.8-12.5-45.3.0L256 338.7 86.6 169.4c-12.5-12.5-32.8-12.5-45.3.0s-12.5 32.8.0 45.3l192 192z"/></svg></span></span></button><div class="invisible w-full bg-transparent group-hover:visible"></div><div class="invisible absolute z-50 flex flex-col whitespace-nowrap rounded border border-neutral-300 bg-neutral text-start text-base shadow group-hover:visible ltr:right-0 rtl:left-0 dark:border-neutral-600 dark:bg-neutral-800"><div class="flex flex-grow"><a href=/en/posts/modern-c++-study-guide-template/ class="w-full py-1 pe-10 ps-2 decoration-primary-500 hover:underline hover:decoration-2 hover:underline-offset-2">English</a></div><div class="flex flex-grow"><a href=/posts/modern-c++-study-guide-template/ class="flex w-full items-center justify-between bg-primary-100 px-2 py-1 dark:bg-primary-900">简体中文<span class="ms-2 w-6 text-primary-600 dark:text-primary-400"><span class="icon relative inline-block px-1 align-text-bottom"><svg viewBox="0 0 448 512"><path fill="currentcolor" d="M438.6 105.4c12.5 12.5 12.5 32.7.0 45.2l-256 256c-12.5 12.5-32.7 12.5-45.2.0L9.372 278.6c-12.496-12.5-12.496-32.7.0-45.2 12.498-12.5 32.758-12.5 45.258.0L159.1 338.7 393.4 105.4c12.5-12.52 32.7-12.52 45.2.0h0z"/></svg></span></span></a></div></div></div></li></ul></nav></header><div class="relative flex grow flex-col"><main id=main-content class=grow><article><header class=max-w-prose><h1 class="mb-8 mt-0 text-4xl font-extrabold text-neutral-900 dark:text-neutral">现代C++学习指南 模板</h1><div class="mb-10 text-base text-neutral-500 dark:text-neutral-400 print:hidden"><div class="flex flex-row flex-wrap items-center"><time datetime="2022-10-31 21:33:38 +0800 +0800"></time><span class="px-2 text-primary-500">&#183;</span><span title></span></div></div></header><section class="prose mt-0 flex max-w-full flex-col dark:prose-invert lg:flex-row"><div class="min-h-0 min-w-0 max-w-prose grow"><blockquote><p>模板作为C++重要的特性，一直有着举足轻重的地位，是编写高度抽象代码的利器。</p></blockquote><h3 id=什么是模板 class="relative group">什么是模板 <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%e4%bb%80%e4%b9%88%e6%98%af%e6%a8%a1%e6%9d%bf aria-label>#</a></span></h3><p>模板在现实生活中就是范例：把都一样的部分固定起来，把变动的部分空出来，使用时将两部分合起来组成有效的东西。如申请书，Word模板都是这种形式。C++中的模板也是如此，不过更明确的是C++中的模板，变动的部分是一个代指类型的东西，称之为泛型参数。</p><p>我们先从一个例子来看一看模板是怎样发展而来的。如我们需要计算两个对象相加的结果，该如何写代码呢？在写代码前，我们有几个问题需要讨论清楚：
首先我们需要<strong>确定</strong>的是这两个<strong>对象</strong>是什么<strong>类型</strong>，毕竟C++是强类型的编程语言，变量，函数，类都是要明确指定类型是什么的，不确定的类型编译就不能通过。我们先假设这两个类型是整型。确定了类型之后，还需要确定这两个对象需要怎样加起来，根据我们假设的整型，我们知道可以直接调用运算符<code>+</code>。最后我们需要确定，两个对象相加后的结果类型是什么，整型相加的结果也是整型。综上，这个例子的代码看起来可能是这样的</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=nf>sum</span><span class=p>(</span><span class=kt>int</span> <span class=n>left</span><span class=p>,</span><span class=kt>int</span> <span class=n>right</span><span class=p>){</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=n>left</span> <span class=o>+</span> <span class=n>right</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>这个例子很简单，简单到甚至都不需要单独写成一个函数。如果我们需要计算的数据不是两个数，而是一个数组的和呢？基于前面的分析和假设，我们也能很快实现相应的代码</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=nf>sum</span><span class=p>(</span><span class=k>const</span> <span class=kt>int</span> <span class=n>data</span><span class=p>[],</span> <span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>size_t</span> <span class=n>length</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kt>int</span> <span class=n>result</span><span class=p>{};</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>length</span><span class=p>;</span><span class=o>++</span><span class=n>i</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=n>result</span> <span class=o>+=</span> <span class=o>*</span><span class=p>(</span><span class=n>data</span> <span class=o>+</span> <span class=n>i</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=n>result</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>同样很简单。但是遗憾的是，这个函数通用性不强，它只能计算整型的数组和，假如我们需要计算带有小数点的数组和，它就不灵了，因为第一个参数类型不匹配，尽管我们知道<code>sum</code>的代码几乎都能复用，除了第一行的<code>int</code>需要替换成<code>double</code>。但是不能！我们只能复制一份，然后把<code>int</code>的地方改成<code>double</code>。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>double</span> <span class=nf>sum</span><span class=p>(</span><span class=k>const</span> <span class=kt>double</span> <span class=n>data</span><span class=p>[],</span> <span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>size_t</span> <span class=n>length</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kt>double</span> <span class=n>result</span><span class=p>{};</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>length</span><span class=p>;</span><span class=o>++</span><span class=n>i</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=n>result</span> <span class=o>+=</span> <span class=o>*</span><span class=p>(</span><span class=n>data</span> <span class=o>+</span> <span class=n>i</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=n>result</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>这时你就会发现问题了，<strong>这个过程，我们仅仅改变了类型信息</strong>。这样的问题还会继续增加，我们可能又需要求<code>float</code>的数组和，上面那个<code>double</code>的数组和同样匹配不了，因为<code>float</code>，<code>double</code>是两个类型。正是因为数据类型不一样，所以很多时候我们需要为不同的数据提供相似的代码，这在数据类型膨胀的情况下是很痛苦的，当对算法进行修改的时候我们需要保证所有的数据类型都被修改到，并且要逐个进行测试，这无疑会增加工作量，并放大错误率。但是实际有效的代码都是要明确类型的，如果类型不明确，编译器就没法确定代码是否合法，不确定的事情编译器就要报错，所以按照普通的思路，这个问题是无解的。
但是其实很多时候，这些相似的代码仅仅是数据类型不一样而已，对付这种重复的工作应该让给计算机来完成，也就是编译器。所以我们需要一种技术，让<strong>编译器先不管具体类型是什么，而是用一种特殊的类型来替换，这个类型可以替换成任何类型，用这个特殊的类型完成具体的算法，在使用的时候根据实际的需求，将类型信息提供给算法，让编译器生成满足所提供类型的具体算法，而这就是模板</strong>。这和生活中的模板思想上是共通的。算法是固定的部分，数据类型是可变的部分，两个合起来就是合法的C++代码。也就是利用模板，我们可以只写一个算法，借助编译器生成所有类型的算法，这些算法之间唯一不同的就是类型。
当然光有模板还不够，上面只解决了类型的问题，没有解决算法实现的问题。怎么说呢，如我们有一个需求，需要将数据先排序，再查找最大值。这对于数字（<code>int</code>,<code>float</code>,<code>double</code>等）类型是有效的，直接使用比较运算符（<code>&lt;</code>,<code>></code>）就可以完成了，但是假如想让这个算法适用于自定义类型呢？直接在模板实现中写比较运算符对自定义类型是无效的，因为自定义类型没有实现相对应的比较运算函数。解决方法也很简单，自定义类型实现相对应的比较运算符就行了。诸如此类的问题，在模板中会经常遇到，因为我们对类型的信息一无所知，但是又要确保几乎所有的类型都能正常运作，这就不得不运用各种技术对类型进行限定或者检测，这其实才是模板问题的精髓。所以模板问题不仅仅是类型问题，还是其他C++问题的综合体，需要对C++特性有着较为完整的理解，才能写出有用高效的代码。
C++中通常将模板分为函数模板和模板类，我们先从比较简单的函数模板开始认识。</p><h3 id=函数模板 class="relative group">函数模板 <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%e5%87%bd%e6%95%b0%e6%a8%a1%e6%9d%bf aria-label>#</a></span></h3><p>函数模板是一种函数，和普通函数不一样的地方是，它的参数列表中至少有一个是不确定类型的。我们用开头的例子来小试牛刀：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=n>T</span> <span class=n>sum</span><span class=p>(</span><span class=k>const</span> <span class=n>T</span> <span class=n>data</span><span class=p>[],</span> <span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>size_t</span> <span class=n>length</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=n>T</span> <span class=n>result</span><span class=p>{};</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>length</span><span class=p>;</span><span class=o>++</span><span class=n>i</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=n>result</span> <span class=o>+=</span> <span class=o>*</span><span class=p>(</span><span class=n>data</span> <span class=o>+</span> <span class=n>i</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=n>result</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kt>int</span> <span class=n>intData</span><span class=p>[]</span> <span class=o>=</span> <span class=p>{</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>2</span> <span class=p>};</span>
</span></span><span class=line><span class=cl>	<span class=kt>float</span> <span class=n>floatData</span><span class=p>[]</span> <span class=o>=</span> <span class=p>{</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>2</span> <span class=p>};</span>
</span></span><span class=line><span class=cl>	<span class=kt>double</span> <span class=n>doubleData</span><span class=p>[]</span> <span class=o>=</span> <span class=p>{</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>2</span> <span class=p>};</span>
</span></span><span class=line><span class=cl>	<span class=k>auto</span> <span class=n>len</span> <span class=o>=</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>intData</span><span class=p>)</span><span class=o>/</span><span class=k>sizeof</span><span class=p>(</span><span class=n>intData</span><span class=p>[</span><span class=mi>0</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;intSum = &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>sum</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span><span class=p>(</span><span class=n>intData</span><span class=p>,</span><span class=n>len</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;, floatSum = &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>sum</span><span class=o>&lt;</span><span class=kt>float</span><span class=o>&gt;</span><span class=p>(</span><span class=n>floatData</span><span class=p>,</span><span class=n>len</span><span class=p>)</span> <span class=o>&lt;&lt;</span><span class=s>&#34;, doubleSum = &#34;</span> <span class=o>&lt;&lt;</span><span class=n>sum</span><span class=o>&lt;</span><span class=kt>double</span><span class=o>&gt;</span><span class=p>(</span><span class=n>doubleData</span><span class=p>,</span><span class=n>len</span><span class=p>)</span><span class=o>&lt;&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=c1>// 输出
</span></span></span><span class=line><span class=cl><span class=c1>// intSum = 6, floatSum = 6, doubleSum = 6
</span></span></span></code></pre></div><p>在这里，我们仅仅写了一个函数，就可以同时适用于<code>int</code>，<code>float</code>，<code>double</code>。如果还有其它类型实现了默认初始化和运算符<code>+=</code>就同样可以使用这个函数来求和，不需要改动任何现有代码，这就是模板的魅力。
在继续看新东西前，我们先来认识一下函数模板和普通函数之间有什么不同：</p><ol><li>函数模板需要一个模板头，即<code>template&lt;typename T></code>。它的作用是告诉编译器下面的函数中遇到<code>T</code>的地方都不是具体类型，需要在调用函数时再确定。</li><li>函数声明中，类型位置被<code>T</code>替代了，也就是说<code>T</code>是一个占位类型，可以将它当作普通类型来用。在写模板代码时，这是很有用的。</li></ol><p>再来看使用函数的地方，也就是类似<code>sum&lt;xxx>(xxxData,len)</code>的语句，其中的<code>xxx</code>代表数据类型，也就是函数模板中<code>T</code>的实际类型。简单来说就告诉编译器，用类型<code>xxx</code>替换函数模板中的类型<code>T</code>，这个过程有个官方的名字，<strong>实例化</strong>,这是另一个和普通函数不一样的地方.。用函数模板是需要经过两个步骤的。</p><ol><li>定义模板。这一步没有具体类型，需要使用一个泛型参数来对类型占位，也就是只要是出现实际类型的地方，都要使用泛型参数来占位，并用这个泛型参数来实现完整的算法。这一步编译器由于不知道具体类型，不会对一些类型操作进行禁止，而只是检查标识符是否存在，语法是否合法等。</li><li>实例化。实例化的过程只会发生在开发者调用函数模板的地方，没有实例化的函数模板的代码是不会出现在最执行文件中的。编译器会对每一处发生实例化的地方，用实际参数来替换泛型参数，并检查实际类型是否支持算法中所有的操作，如果不支持，则编译失败，需要开发者实现相关的操作或者修改函数模板。如上例中，假如我们用一个自定义类型来实例化，就会发现编译无法通过，因为自定义类型没有定义操作符<code>+=</code>（除非该操作符已经被定义了），这个过程就发生在实例化。解决方案也很简单，对自定义类型添加操作符<code>+=</code>即可。</li></ol><h3 id=类型推导 class="relative group">类型推导 <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%e7%b1%bb%e5%9e%8b%e6%8e%a8%e5%af%bc aria-label>#</a></span></h3><p>在上例中，我们发现在实例化的过程中，要同时给函数模板传递类型参数和数据参数，并且类型参数往往和数据的类型是一一对应的，这中冗杂的语法对于现代C++来说是不可接受的，所以现代C++编译器都支持类型推导。类型推导可以让开发者省略类型参数，直接根据数据类型来推导出类型参数，所以上例实例化都可以写成<code>sum(xxxData,len)</code>的形式，编译器能分别推导出<code>xxx</code>的类型是<code>int</code>,<code>float</code>，<code>double</code>。
当然类型推导也不是万能的，我们来看下面这个例子</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=n>T</span> <span class=n>max</span><span class=p>(</span><span class=n>T</span> <span class=n>a</span><span class=p>,</span> <span class=n>T</span> <span class=n>b</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=n>a</span> <span class=o>&gt;</span> <span class=n>b</span> <span class=o>?</span> <span class=nl>a</span> <span class=p>:</span> <span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kt>int</span> <span class=n>a</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=kt>int</span> <span class=n>b</span> <span class=o>=</span> <span class=mi>2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;max(&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>a</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;,&#34;</span><span class=o>&lt;&lt;</span><span class=n>b</span><span class=o>&lt;&lt;</span><span class=s>&#34;) = &#34;</span> <span class=o>&lt;&lt;</span><span class=n>max</span><span class=p>(</span><span class=n>a</span><span class=p>,</span><span class=n>b</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 输出
</span></span></span><span class=line><span class=cl><span class=c1>// max(1,2) = 2
</span></span></span></code></pre></div><p>这个例子很直观，结果当然也毫无意外。现在我们要变形了：我们把变量<code>b</code>的类型改为<code>float</code>，就会发现编译无法通过了。提示我们数据类型不匹配，因为<code>a</code>是<code>int</code>，<code>b</code>是<code>float</code>，所以推导出的结果就是<code>max&lt;int,float>()</code>，而实际上我们是只有一个类型参数的。
那既然问题很明了，解决方法也似乎很简单，给<code>max</code>再加一个参数不就行了吗？我们来看一看。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>A</span><span class=p>,</span><span class=k>typename</span> <span class=n>B</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=n>A</span> <span class=n>max</span><span class=p>(</span><span class=n>A</span> <span class=n>a</span><span class=p>,</span> <span class=n>B</span> <span class=n>b</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=n>a</span> <span class=o>&gt;</span> <span class=n>b</span> <span class=o>?</span> <span class=nl>a</span> <span class=p>:</span> <span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kt>int</span> <span class=n>a</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=kt>float</span> <span class=n>b</span> <span class=o>=</span> <span class=mi>2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;max(&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>a</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;,&#34;</span><span class=o>&lt;&lt;</span><span class=n>b</span><span class=o>&lt;&lt;</span><span class=s>&#34;) = &#34;</span> <span class=o>&lt;&lt;</span><span class=n>max</span><span class=p>(</span><span class=n>a</span><span class=p>,</span><span class=n>b</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 输出
</span></span></span><span class=line><span class=cl><span class=c1>// max(1,2) = 2
</span></span></span></code></pre></div><p>经过这样改之后，编译和运行都不报错了，问题似乎解决了，是吗？
并不是，我们把<code>float b = 2;</code>换成<code>float b = 2.5;</code>，</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kt>int</span> <span class=n>a</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=kt>float</span> <span class=n>b</span> <span class=o>=</span> <span class=mf>2.5</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;max(&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>a</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;,&#34;</span><span class=o>&lt;&lt;</span><span class=n>b</span><span class=o>&lt;&lt;</span><span class=s>&#34;) = &#34;</span> <span class=o>&lt;&lt;</span><span class=n>max</span><span class=p>(</span><span class=n>a</span><span class=p>,</span><span class=n>b</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 输出
</span></span></span><span class=line><span class=cl><span class=c1>// max(1,2.5) = 2
</span></span></span></code></pre></div><p>再次运行程序，就会发现输出是错误的了。因为函数模板中，我们把返回值定义成了<code>A</code>，在实例化的时候<code>A</code>被推导成了<code>int</code>类型，所以实际上<code>max</code>的返回值就成了<code>int</code>类型，最大值<code>B</code>就被从<code>float</code>强制转换成了<code>int</code>类型，丢失了数据精度。那有没有解决方法呢？有的，而且不止一种!
根据上面的分析，其问题的根本是数据被强转了，解决方案当然就是阻止它发生强转，也就是保持两种数据类型是一致的，那怎么保证呢？阻止编译器的类型推导，手动填写类型参数。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kt>int</span> <span class=n>a</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=kt>float</span> <span class=n>b</span> <span class=o>=</span> <span class=mf>2.5</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;max(&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>a</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;,&#34;</span><span class=o>&lt;&lt;</span><span class=n>b</span><span class=o>&lt;&lt;</span><span class=s>&#34;) = &#34;</span> <span class=o>&lt;&lt;</span><span class=n>max</span><span class=o>&lt;</span><span class=kt>float</span><span class=o>&gt;</span><span class=p>(</span><span class=n>a</span><span class=p>,</span><span class=n>b</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 输出
</span></span></span><span class=line><span class=cl><span class=c1>// max(1,2.5) = 2.5
</span></span></span></code></pre></div><p>可以看到在此例中，我们只填写了一个类型参数，因为类型<code>B</code>会自动推导成<code>float</code>。没错，类型推导是可以部分禁用的！
另一种解决方案就是完全让编译器计算类型。怎么计算呢，C++11提供了<code>auto</code>和<code>decltype</code>。<code>auto</code>可以计算变量的类型，<code>decltype</code>可以计算表达式的类型，用法如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>auto</span> <span class=n>a</span><span class=o>=</span><span class=mi>1</span><span class=p>;</span> <span class=c1>// a被推导成int类型
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>auto</span> <span class=n>b</span><span class=o>=</span><span class=mf>1.5</span><span class=p>;</span> <span class=c1>// b被推导成double类型
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>decltype</span><span class=p>(</span><span class=n>a</span><span class=o>+</span><span class=n>b</span><span class=p>)</span> <span class=c1>//结果是double类型
</span></span></span></code></pre></div><p>也就是可以将返回值置为<code>auto</code>，然后让编译器决定返回类型</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>A</span><span class=p>,</span><span class=k>typename</span> <span class=n>B</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>auto</span> <span class=n>max</span><span class=p>(</span><span class=n>A</span> <span class=n>a</span><span class=p>,</span> <span class=n>B</span> <span class=n>b</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=n>a</span> <span class=o>&gt;</span> <span class=n>b</span> <span class=o>?</span> <span class=nl>a</span> <span class=p>:</span> <span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kt>int</span> <span class=n>a</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=kt>float</span> <span class=n>b</span> <span class=o>=</span> <span class=mf>2.5</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;max(&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>a</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;,&#34;</span><span class=o>&lt;&lt;</span><span class=n>b</span><span class=o>&lt;&lt;</span><span class=s>&#34;) = &#34;</span> <span class=o>&lt;&lt;</span><span class=n>max</span><span class=o>&lt;</span><span class=kt>float</span><span class=o>&gt;</span><span class=p>(</span><span class=n>a</span><span class=p>,</span><span class=n>b</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 输出
</span></span></span><span class=line><span class=cl><span class=c1>// max(1,2.5) = 2.5
</span></span></span></code></pre></div><p>假如编译器只支持C++11的话，会麻烦一点，不仅要前置<code>auto</code>，在函数头后还要使用<code>decltype</code>来计算返回类型，这个特性称为<strong>尾返回推导。</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>A</span><span class=p>,</span><span class=k>typename</span> <span class=n>B</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>auto</span> <span class=n>max</span><span class=p>(</span><span class=n>A</span> <span class=n>a</span><span class=p>,</span> <span class=n>B</span> <span class=n>b</span><span class=p>)</span><span class=o>-&gt;</span><span class=k>decltype</span><span class=p>(</span><span class=n>a</span> <span class=o>+</span> <span class=n>b</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=n>a</span> <span class=o>&gt;</span> <span class=n>b</span> <span class=o>?</span> <span class=nl>a</span> <span class=p>:</span> <span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>这里<code>decltype</code>里面写的是
函数模板暂时放一放，我们来看一看类模板是怎样的。</p><h3 id=类模板 class="relative group">类模板 <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%e7%b1%bb%e6%a8%a1%e6%9d%bf aria-label>#</a></span></h3><p>和函数模板一样，类模板也至少包含一个泛型参数，这个泛型参数的作用域是整个类，也就是说可以使用这个泛型参数定义成员变量和成员函数。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Result</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=n>T</span> <span class=n>data</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=kt>int</span> <span class=n>code</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>reason</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>	<span class=n>Result</span><span class=p>(</span><span class=n>T</span> <span class=n>data</span><span class=p>,</span> <span class=kt>int</span> <span class=n>code</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>reason</span> <span class=o>=</span> <span class=s>&#34;success&#34;</span><span class=p>)</span> <span class=o>:</span><span class=n>data</span><span class=p>{</span> <span class=n>data</span> <span class=p>},</span> <span class=n>code</span><span class=p>{</span> <span class=n>code</span> <span class=p>},</span> <span class=n>reason</span><span class=p>{</span> <span class=n>reason</span> <span class=p>}</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>friend</span> <span class=n>std</span><span class=o>::</span><span class=n>ostream</span><span class=o>&amp;</span> <span class=k>operator</span><span class=o>&lt;&lt;</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>ostream</span><span class=o>&amp;</span> <span class=n>os</span><span class=p>,</span> <span class=k>const</span> <span class=n>Result</span> <span class=n>result</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=n>os</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Result(data = &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>result</span><span class=p>.</span><span class=n>data</span> <span class=o>&lt;&lt;</span><span class=s>&#34;, code = &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>result</span><span class=p>.</span><span class=n>code</span> <span class=o>&lt;&lt;</span><span class=s>&#34;, reason = &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>result</span><span class=p>.</span><span class=n>reason</span> <span class=o>&lt;&lt;</span><span class=s>&#34;)&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=n>os</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=n>Result</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>result</span><span class=p>{</span> <span class=mi>9527</span> <span class=p>};</span>
</span></span><span class=line><span class=cl>	<span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>result</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 输出
</span></span></span><span class=line><span class=cl><span class=c1>// Result(data = 9527, code = 0, reason = success)
</span></span></span></code></pre></div><p>可以看到，类模板和普通类类似，普通类有的它都有——成员函数，成员变量，构造函数等等，值得一说的依然是这个泛型参数<code>T</code>。上例是SDK中常见的数据类，用于指示操作是否成功并且必要时返回操作结果。对于返回一般数据类型，这个类已经足够了，但是假如我们的某个接口无返回值，按照传统即返回<code>void</code>类型，问题出现了。<code>data</code>的实际类型是<code>void</code>，但是我们找不到任何值来初始化它。更进一步，返回<code>void</code>的时候，我们根本不需要<code>data</code>这个成员变量。为了解决类似这种问题，模板提供了特化。</p><h3 id=特化和偏特化 class="relative group">特化和偏特化 <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%e7%89%b9%e5%8c%96%e5%92%8c%e5%81%8f%e7%89%b9%e5%8c%96 aria-label>#</a></span></h3><p><strong>特化就是用特定类型替代泛型参数重新实现类模板或者函数模板，它依赖于原始模板</strong>。如上例中，我们已经有了原始模板类<code>Result&lt;T></code>，为了解决<code>void</code>不能使用的情况，我们需要为<code>void</code>类型重新定义一个<code>Result</code>，即<code>Result&lt;void></code>，则<code>Result&lt;void></code>就称为<code>Result&lt;T></code>的一种特化，原来的<code>Result&lt;T></code>称为原始模板类。这样的特化版本可以有很多个，一个类型就是一个特化版本，它<strong>完美融合了通用性和特殊性两个优势</strong>。当实例化过程中，如果实例化类型和特化类型一致，则实例化将使用特化的那个类（函数）来完成，如下面的例子</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// Result定义保持不变，新增特化版本
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>template</span> <span class=o>&lt;&gt;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Result</span><span class=o>&lt;</span><span class=kt>void</span><span class=o>&gt;</span><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kt>int</span> <span class=n>code</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>reason</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>	<span class=n>Result</span><span class=p>(</span><span class=kt>int</span> <span class=n>code</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>reason</span> <span class=o>=</span> <span class=s>&#34;success&#34;</span><span class=p>)</span><span class=o>:</span> <span class=n>code</span><span class=p>{</span> <span class=n>code</span> <span class=p>},</span> <span class=n>reason</span><span class=p>{</span> <span class=n>reason</span> <span class=p>}{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>friend</span> <span class=n>std</span><span class=o>::</span><span class=n>ostream</span><span class=o>&amp;</span> <span class=k>operator</span><span class=o>&lt;&lt;</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>ostream</span><span class=o>&amp;</span> <span class=n>os</span><span class=p>,</span> <span class=k>const</span> <span class=n>Result</span> <span class=n>result</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=n>os</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Result(&#34;</span><span class=o>&lt;&lt;</span><span class=s>&#34;code = &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>result</span><span class=p>.</span><span class=n>code</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;, reason = &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>result</span><span class=p>.</span><span class=n>reason</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;)&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=n>os</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=n>Result</span><span class=o>&lt;</span><span class=kt>void</span><span class=o>&gt;</span> <span class=n>voidResult</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>Result</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>intResult</span><span class=p>{</span><span class=mi>9527</span><span class=p>};</span>
</span></span><span class=line><span class=cl>	<span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;void = &#34;</span><span class=o>&lt;&lt;</span> <span class=n>voidResult</span><span class=o>&lt;&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=o>&lt;&lt;</span><span class=s>&#34;int = &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>intResult</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 输出
</span></span></span><span class=line><span class=cl><span class=c1>// void = Result(code = 0, reason = success)
</span></span></span><span class=line><span class=cl><span class=c1>// int = Result(data = 9527, code = 0, reason = success)
</span></span></span></code></pre></div><p>可以看到，当实例化为<code>int</code>类型时，使用的是原始的模板类。而当实例化为<code>void</code>类型时，使用的是特化的版本。
除了特化，还有<strong>偏特化</strong>。偏特化和特化很像，就是对类型进行一个更窄的限定，使之适用于某一类类型，如<code>const</code>，指针，引用等。或者对有多个泛型参数的类进行部分特化。
特化和偏特化是对模板特殊类型的补充，解决的是模板实现上的一些问题。很多时候如果通用模板不好实现，可以考虑使用特化。当然，特化版本越多，模板的维护成本就越高，这时候就该考虑是否是设计上存在缺陷了。</p><h3 id=类型限定 class="relative group">类型限定 <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%e7%b1%bb%e5%9e%8b%e9%99%90%e5%ae%9a aria-label>#</a></span></h3><p>C++模板的强大不仅仅表现在对类型的操作上，有时候为了防止我们的类被滥用，我们还需要对这些能力做一些限定，比如禁止某些特定的类型实例化。
在上面的例子中，假设我们规定<code>Result</code>必须返回实际的数据，禁止<code>void</code>实例化该怎么做呢？容易想到的是，我们首先需要一种方法<strong>判断实例化时的类型是否是特定类型</strong>，然后需要在<strong>实例化类型是禁止类型时告诉编译器编译失败</strong>。所有的这些，标准库<code>type_traits</code>都提供了支持。它提供了一系列工具来帮助我们识别类型参数，如数字，字符串，指针等等，也提供了一些其他工具辅助这些类型参数工具完成更复杂的功能。
此例中，我们希望实例化类型不能是<code>void</code>，经过查找<code>type_traits</code>，我们发现有个<code>is_void</code>的类，它有个<code>value</code>常量，这个常量在类型参数为<code>void</code>是为<code>true</code>，否则为<code>false</code>。当然有了判定方法还不够，我们还需要在类型不匹配时让编译器报错的方法，恰好，我们有<code>enable_if_t</code>。它有两个类型参数，第一个是布尔表达式，第二个是类型参数。当表达式为真时，类型参数才有定义，否则编译失败。所以为了完成禁止<code>void</code>实例化的功能，我们需要借助两个工具，<code>is_void</code>判断类型参数是否是<code>void</code>,<code>enable_if_t</code>完成布尔表达式到类型参数的转换。综上，让我们来看看实现：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Result</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=n>std</span><span class=o>::</span><span class=n>enable_if_t</span><span class=o>&lt;!</span><span class=n>std</span><span class=o>::</span><span class=n>is_void</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;::</span><span class=n>value</span><span class=p>,</span><span class=n>T</span><span class=o>&gt;</span> <span class=n>data</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=kt>int</span> <span class=n>code</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>reason</span><span class=p>;</span> 
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>	<span class=n>Result</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>enable_if_t</span><span class=o>&lt;</span> <span class=o>!</span><span class=n>std</span><span class=o>::</span><span class=n>is_void</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;::</span><span class=n>value</span><span class=p>,</span><span class=n>T</span><span class=o>&gt;</span> <span class=n>data</span><span class=p>,</span> <span class=kt>int</span> <span class=n>code</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>reason</span> <span class=o>=</span> <span class=s>&#34;success&#34;</span><span class=p>)</span> <span class=o>:</span><span class=n>data</span><span class=p>{</span> <span class=n>data</span> <span class=p>},</span> <span class=n>code</span><span class=p>{</span> <span class=n>code</span> <span class=p>},</span> <span class=n>reason</span><span class=p>{</span> <span class=n>reason</span> <span class=p>}</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>friend</span> <span class=n>std</span><span class=o>::</span><span class=n>ostream</span><span class=o>&amp;</span> <span class=k>operator</span><span class=o>&lt;&lt;</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>ostream</span><span class=o>&amp;</span> <span class=n>os</span><span class=p>,</span> <span class=k>const</span> <span class=n>Result</span><span class=o>&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>enable_if_t</span><span class=o>&lt;</span> <span class=o>!</span><span class=n>std</span><span class=o>::</span><span class=n>is_void</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;::</span><span class=n>value</span><span class=p>,</span> <span class=n>T</span><span class=o>&gt;&gt;</span> <span class=n>result</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=n>os</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Result(data = &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>result</span><span class=p>.</span><span class=n>data</span> <span class=o>&lt;&lt;</span><span class=s>&#34;, code = &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>result</span><span class=p>.</span><span class=n>code</span> <span class=o>&lt;&lt;</span><span class=s>&#34;, reason = &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>result</span><span class=p>.</span><span class=n>reason</span> <span class=o>&lt;&lt;</span><span class=s>&#34;)&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=n>os</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>例中，第3行和第8行都用到了类型限定，其实我们只需要在构造函数是对<code>T</code>限定就可以了。当用<code>void</code>来实例化<code>Result</code>时，将无法通过编译。</p><h3 id=其他问题 class="relative group">其他问题 <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%e5%85%b6%e4%bb%96%e9%97%ae%e9%a2%98 aria-label>#</a></span></h3><p>C++模板有两方面的问题要解决，一方面是本身模板相关的问题，而另一方面就是和其他特性一起工作。如C++11引入了右值引用，但是右值引用通过参数传递以后会造成引用坍缩，丢失其右值引用的性质，表现得像一般引用类型，为了解决这个问题，C++提供了<code>std::move</code>工具。这对于普通函数是没问题的，但是假如这是一个模板函数呢？C++同样提供了<strong>完美转发</strong>的解决方法。
所谓完美转发，就是让右值引用保持右值引用，左值引用也保持左值引用。它需要配合万能引用一起使用。万能引用和右值引用很相似，只不过<strong>万能引用类型是不确定的，在编译期才能确定</strong>。看下面的例子</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>test</span><span class=p>(</span><span class=n>T</span><span class=o>&amp;&amp;</span> <span class=n>p</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;p = &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>forward</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=p>(</span><span class=n>p</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kt>int</span> <span class=n>a</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>test</span><span class=p>(</span><span class=n>a</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>test</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>move</span><span class=p>(</span><span class=n>a</span><span class=p>));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 输出
</span></span></span><span class=line><span class=cl><span class=c1>// p = 1
</span></span></span><span class=line><span class=cl><span class=c1>// p = 1
</span></span></span></code></pre></div><p><code>T&&</code>是万能引用，因为它类型不确定，然后通过<code>std::forward&lt;></code>转发参数。可以看到在8，9行，我们成功传递给<code>test</code>左值和右值，并且也成功得到了预期结果，不需要为右值单独写函数来处理。模板的这个功能极大简化了函数的设计，对于API的设计来说简直就是救星。
此外，函数模板还有重载的问题。通常来说普通函数的优先级会高于函数模板的优先级，函数模板之间越特殊的会优先匹配等等。这些问题随着对模板了解的深入，会慢慢出现，但是在学习初期没必要花费太多精力来了解这些特性，一切以实用为主。</p><h3 id=总结 class="relative group">总结 <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%e6%80%bb%e7%bb%93 aria-label>#</a></span></h3><p>模板是C++中很大的一个课题，融合了类型系统，标准库，类等一系列的大课题。所以写出完美的模板代码需要首先对这些课题有较为完整的了解。其次由于模板对类型控制较为宽松，还需要开发者对模板的适用范围有全局的把控，禁止什么，对什么类型需要特殊化处理，都要考虑到位，稍不注意就会隐藏一个难以察觉的bug。
总之就是一句话，模板是常学常新，常用常新的，需要在实践中学习，又要在学习中实践的东西，祝大家每次都有新收获！</p><h3 id=参考资料 class="relative group">参考资料 <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%e5%8f%82%e8%80%83%e8%b5%84%e6%96%99 aria-label>#</a></span></h3><ol><li><a href=https://en.cppreference.com/w/cpp/meta#Type_traits target=_blank rel=noreferrer>type_traints</a></li></ol></div></section><footer class="max-w-prose pt-8 print:hidden"><div class=flex><picture class="!mb-0 !mt-0 me-4 w-24 h-auto rounded-full"><img width=1000 height=1000 class="!mb-0 !mt-0 me-4 w-24 h-auto rounded-full" alt=低头沉思 loading=lazy decoding=async src=/images/logo_hu1444715804356428735.png srcset="/images/logo_hu10122803172005691567.png 330w,/images/logo_hu1444715804356428735.png 660w
,/images/logo.png 1000w
,/images/logo.png 1000w" sizes=100vw></picture><div class=place-self-center><div class="text-[0.6rem] uppercase leading-3 text-neutral-500 dark:text-neutral-400"></div><div class="font-semibold leading-6 text-neutral-800 dark:text-neutral-300">低头沉思</div><div class="text-2xl sm:text-lg"><div class="flex flex-wrap text-neutral-400 dark:text-neutral-500"><a class="px-1 transition-transform hover:scale-125 hover:text-primary-700 dark:hover:text-primary-400" style=will-change:transform href=mailto:honguilee@163.com target=_blank aria-label=Email rel="me noopener noreferrer"><span class="icon relative inline-block px-1 align-text-bottom"><svg viewBox="0 0 512 512"><path fill="currentcolor" d="M207.8 20.73c-93.45 18.32-168.7 93.66-187 187.1-27.64 140.9 68.65 266.2 199.1 285.1 19.01 2.888 36.17-12.26 36.17-31.49l1e-4-.6631c0-15.74-11.44-28.88-26.84-31.24-84.35-12.98-149.2-86.13-149.2-174.2.0-102.9 88.61-185.5 193.4-175.4 91.54 8.869 158.6 91.25 158.6 183.2v16.16c0 22.09-17.94 40.05-40 40.05s-40.01-17.96-40.01-40.05v-120.1c0-8.847-7.161-16.02-16.01-16.02l-31.98.0036c-7.299.0-13.2 4.992-15.12 11.68-24.85-12.15-54.24-16.38-86.06-5.106-38.75 13.73-68.12 48.91-73.72 89.64-9.483 69.01 43.81 128 110.9 128 26.44.0 50.43-9.544 69.59-24.88 24 31.3 65.23 48.69 109.4 37.49C465.2 369.3 496 324.1 495.1 277.2V256.3c0-149.2-133.9-265.632-287.3-235.57zM239.1 304.3c-26.47.0-48-21.56-48-48.05s21.53-48.05 48-48.05 48 21.56 48 48.05-20.6 48.05-48 48.05z"/></svg>
</span></a><a class="px-1 transition-transform hover:scale-125 hover:text-primary-700 dark:hover:text-primary-400" style=will-change:transform href=https://github.com/hongui target=_blank aria-label=Github rel="me noopener noreferrer"><span class="icon relative inline-block px-1 align-text-bottom"><svg viewBox="0 0 496 512"><path fill="currentcolor" d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6.0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6.0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3.0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1.0-6.2-.3-40.4-.3-61.4.0.0-70 15-84.7-29.8.0.0-11.4-29.1-27.8-36.6.0.0-22.9-15.7 1.6-15.4.0.0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5.0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9.0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4.0 33.7-.3 75.4-.3 83.6.0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6.0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9.0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg></span></a></div></div></div></div><div class=pt-8><hr class="border-dotted border-neutral-300 dark:border-neutral-600"><div class="flex justify-between pt-3"><span><a class="group flex" href=/post/%E7%8E%B0%E4%BB%A3C++%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97-%E6%A0%87%E5%87%86%E5%BA%93.html><span class="me-2 text-neutral-700 transition-transform group-hover:-translate-x-[2px] group-hover:text-primary-600 dark:text-neutral dark:group-hover:text-primary-400"><span class="ltr:inline rtl:hidden">&larr;</span><span class="ltr:hidden rtl:inline">&rarr;</span></span>
<span class="flex flex-col"><span class="mt-[0.1rem] leading-6 group-hover:underline group-hover:decoration-primary-500">现代C++学习指南-标准库</span>
<span class="mt-[0.1rem] text-xs text-neutral-500 dark:text-neutral-400"><time datetime="2022-07-20 22:15:05 +0800 +0800"></time>
</span></span></a></span><span><a class="group flex text-right" href=/post/Android-OpenGLES%E5%AD%A6%E4%B9%A0-%E7%94%BB%E4%B8%AA%E9%A2%9C%E8%89%B2.html><span class="flex flex-col"><span class="mt-[0.1rem] leading-6 group-hover:underline group-hover:decoration-primary-500">Android-OpenGLES学习-画个颜色</span>
<span class="mt-[0.1rem] text-xs text-neutral-500 dark:text-neutral-400"><time datetime="2023-05-09 22:14:38 +0800 +0800"></time>
</span></span><span class="ms-2 text-neutral-700 transition-transform group-hover:-translate-x-[-2px] group-hover:text-primary-600 dark:text-neutral dark:group-hover:text-primary-400"><span class="ltr:inline rtl:hidden">&rarr;</span><span class="ltr:hidden rtl:inline">&larr;</span></span></a></span></div></div></footer></article></main><div class="pointer-events-none absolute bottom-0 end-0 top-[100vh] w-12" id=to-top hidden=true><a href=#the-top class="pointer-events-auto sticky top-[calc(100vh-5.5rem)] flex h-12 w-12 items-center justify-center rounded-full bg-neutral/50 text-xl text-neutral-700 backdrop-blur hover:text-primary-600 dark:bg-neutral-800/50 dark:text-neutral dark:hover:text-primary-400" aria-label title>&uarr;</a></div><footer class="py-10 print:hidden"><div class="flex items-center justify-between"><div><p class="text-sm text-neutral-500 dark:text-neutral-400">&copy;
2024
低头沉思</p><p class="text-xs text-neutral-500 dark:text-neutral-400"></p></div><div class="flex flex-row items-center"></div></div></footer><div id=search-wrapper class="invisible fixed inset-0 z-50 flex h-screen w-screen cursor-default flex-col bg-neutral-500/50 p-4 backdrop-blur-sm dark:bg-neutral-900/50 sm:p-6 md:p-[10vh] lg:p-[12vh]" data-url=https://deep-thinking.top/><div id=search-modal class="top-20 mx-auto flex min-h-0 w-full max-w-3xl flex-col rounded-md border border-neutral-200 bg-neutral shadow-lg dark:border-neutral-700 dark:bg-neutral-800"><header class="relative z-10 flex flex-none items-center justify-between px-2"><form class="flex min-w-0 flex-auto items-center"><div class="flex h-8 w-8 items-center justify-center text-neutral-400"><span class="icon relative inline-block px-1 align-text-bottom"><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="search" class="svg-inline--fa fa-search fa-w-16" role="img" viewBox="0 0 512 512"><path fill="currentcolor" d="M505 442.7 405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9.0 208 0S0 93.1.0 208s93.1 208 208 208c48.3.0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9.0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7.0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7.0 128 57.2 128 128 0 70.7-57.2 128-128 128z"/></svg></span></div><input type=search id=search-query class="mx-1 flex h-12 flex-auto appearance-none bg-transparent focus:outline-dotted focus:outline-2 focus:outline-transparent" placeholder tabindex=0></form><button id=close-search-button class="flex h-8 w-8 items-center justify-center text-neutral-700 hover:text-primary-600 dark:text-neutral dark:hover:text-primary-400" title>
<span class="icon relative inline-block px-1 align-text-bottom"><svg viewBox="0 0 320 512"><path fill="currentcolor" d="M310.6 361.4c12.5 12.5 12.5 32.75.0 45.25C304.4 412.9 296.2 416 288 416s-16.38-3.125-22.62-9.375L160 301.3 54.63 406.6C48.38 412.9 40.19 416 32 416S15.63 412.9 9.375 406.6c-12.5-12.5-12.5-32.75.0-45.25l105.4-105.4L9.375 150.6c-12.5-12.5-12.5-32.75.0-45.25s32.75-12.5 45.25.0L160 210.8l105.4-105.4c12.5-12.5 32.75-12.5 45.25.0s12.5 32.75.0 45.25l-105.4 105.4L310.6 361.4z"/></svg></span></button></header><section class="flex-auto overflow-auto px-2"><ul id=search-results></ul></section></div></div></div></body></html>