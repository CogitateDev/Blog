[{"content":"","date":null,"permalink":"/tags/android/","section":"Tags","summary":"","title":"Android"},{"content":" 我们知道屏幕显示出内容是靠一个一个发光的RGB灯珠，而决定灯珠亮度的是一块内存区域，通过往这一块内存区域写入数据，我们就能在屏幕上观察到数据显示效果。这是个复杂又灵活的工作，为了方便完成这项工作，先驱们制定出了OpenGL标准，我们的故事也将从这里开始。\nOpenGL ES #OpenGL ES是OpenGL的精简版本，Android平台从发行伊始就提供了OpenGL ES的支持，只是不同的版本，支持的OpenGL ES版本不同，目前主流的版本还是2.0和3.0。OpenGL ES是一组API，为开发者提供配置数据，传输数据，绘制内容的能力。它的工作是和绘制严格相关的，所以光是OpenGL ES不会造成很大的理解障碍，问题出在配置OpenGL ES的配置环境上。为什么要将OpenGL ES API和配置环境分开呢，因为OpenGL ES是跨平台的API，但是实际运行的时候需要和特定平台绑定，如Android。平台间准备OpenGL ES环境所需要的条件不同，为了保证OpenGL ES的跨平台能力，就需要将配置环境单独拿出来和特定平台绑定。在Android上这个配置环境就是EGL。明确OpenGL ES API和配置OpenGL ES环境的区别不仅对理解这两个关键概念有很大帮助，更是对后期调试代码，排错帮助极大。\n工作流程 #明确了一些基本概念之后，我们接下来最重要的任务是理清OpenGL ES的工作流程。很多教程一上来就列举一大堆名词或者直接上实例，我觉得是不妥的。只有熟悉了工作流程，我们在写代码的时候才能做到心中有数，才能在排错过程中更快更准确地定位问题。\n准备环境 #OpenGL ES是由一系列API组成的，但是不代表可以在任何时机下调用这些API，而是需要运行环境进行一些设置，这就是准备环境。准备环境通常是做一些显存分配，窗口配置的工作，很繁琐却必不可少。\n准备着色器 #着色器很重要，但是对于初学者来说不需要用太多的精力来关注它，很多效果直接可以在网上找到现成的代码，但是怎样将这些代码组装成一个完整可运行的程序却不一定有。我们只需要明确着色器是OpenGL ES开发中的重要一环，这一环这一是魔法发生的地方。\n准备程序 #着色器虽然重要，但是也不能独立运行，需要由一个程序管理。这里说的程序是一个OpenGL ES对象，它负责将着色器组装在一起。在运行大部分OpenGL ES API前都需要先使用到这个对像。\n渲染 #渲染环节其实也是在准备数据，我们需要将着色器中用到的一些数据赋值，然后调用绘制API，完成最后的绘制工作。GPU会将数据传递给着色器，着色器经过流水线，将数据转换成最终的显示数据存储在显存中。\n上屏 #渲染不代表就是将数据显示出来了，而是说数据计算好了。计算好的数据要想在屏幕上看到，可能需要调用OpenGL ES环境配置工具中的某个函数，如交换缓冲或者切换显示对象。\n清理 #和内存一样，我们使用OpenGL ES API也会申请到一些资源，在渲染结束后，我们应该主动将资源释放，以便后续程序使用。很多时候我们正常申请资源没有成功，可能是前面有资源没有释放的原因。\n以上就是开发OpenGL ES应用的大致流程。由于OpenGL ES开发不好排错，所以在发现问题时最有效的定位方法是确定出错环节，然后再针对性地处理。所以熟悉流程很重要。\n实例上手 #由于OpenGLES相关概念很多，为了尽可能减少相关概念的干扰，本文打算只将上述流程中的第一步拿出来着重讲解。同时利用涉及到的知识点，实现一个最小的示例——将窗口染成红色。\n下面开始讲解第一个概念——EGL。\nEGL #OpenGL ES只是对绘图的抽象，没有提供运行环境的抽象。如要申请显存，显存在哪里，需要明确，图像计算好了，显示在哪里，也需要指定。EGL就是对这些环境抽象的集合，为了通俗地解释相关概念，我们可以玩一下角色扮演——假如让我们设计相关标准，我们该如何做。\n首先很容易想到的是，我们需要一个显示器，因为OpenGL ES最终会生成一组颜色数据，我们想要看到这些颜色，肯定就需要一个显示器来显示这些颜色数据。同时我们知道显示器也有很多规格，很多特性，为了兼容各种从低端到高端的显示器，肯定就需要对它做一层抽象，并提供一些设置属性的方法，这就是EGLDisplay的任务。\n确定了显示器之后，我们会发现我们每次只能选择整个显示器或者不使用，而我们实际使用时，肯定有只显示一个区域的情况，或者同时显示多个区域的情况，为了满足这种使用场景，就需要对显示器再做划分，使之可支持同时操作多个区域，而担任这层抽象任务的就是EGLSurface。\n既然都支持了多区域，那肯定也要能够对区域进行配置，可能同一个显示器上，一个区域只需要显示黑白像素，另一个区域需要显示高清图片，为了使这些配置能够生效，并且相互独立，肯定需要一个抽象，它要能保存显示配置，并且能将OpenGL ES环境独立开来，使一个区域对OpenGL ES的API调用不会影响到另一个区域，这就是EGLContext。\n以上就是EGL三个核心的概念，分别是对显示器，显示区域，显示配置的抽象。\n以上的概念都是零散的，我们实际工作肯定需要将各部分连在一起，所以有必要对他们的工作流程做一个概括总结。 首先我们需要获取一个EGLDisplay，从而确定最终的显示设备，然后根据显示设备支持的配置配置一块显示区域EGLSurface。最后，用EGLContext将EGLDisplay、EGLSurface关联起来。一旦关联成功，也就意味着OpenGL ES环境准备完成，下一步就可以创建着色器，创建着色器程序，为绘制做准备了。\n流程梳理完之后，我们来看看代码该怎么写。为了最大限度地降低理解障碍，本文将使用Java端的接口来做示例。\n准备EGLDisplay #学习任何新技能都需要一个入口，而OpenGLES和EGL共同的入口都是EGLDisplay。 所以第一步我们需要得到一个EGLDisplay对象。我们不能直接创建这个对象，而是需要通过eglGetDisplay方法获取一个对象。这个对象很重要，几乎是后面所有EGL相关API的第一个参数，所以，通常需要把它缓存起来以供后续使用。 虽然已经有了EGLDisplay对象，但它还不能直接使用。需要调用eglInitialize进行一次初始化。这种现象在很多SDK中也很常见，获取完对象后都需要做一次初始化，保证内部状态恢复到初始态。\n获取配置 #成功调用eglInitialize方法后，EGLDisplay对象就准备好了，就可以配置显示区域了。但是哪些配置信息有效，哪些配置信息支持我们不知道，因为硬件不同，支持的特性也不同，如果我们不顾硬件特性，直接将配置写死，可能会使代码在某台设备上运行失败，这不是我们想要看到的。因此，为了让配置在所有设备上都有效，有效的方式不是我们规定配置，而是我们主动去查询硬件是否只是我们想要的配置，即让EGLDisplay对象告诉我们。\nEGLDisplay提供了两种方法来查询硬件支持的配置，一种是直接获取设备支持的所有配置信息eglGetConfigs，另一种是开发者列举出期望的配置，然后主动查询设备是否支持列举出的这些配置eglChooseConfig。开发者可以选择任意一种方式来确定显示区域的配置项。如果方法调用成功，则就相当于确定了显示区域的配置项，我们可以用这些配置项配置EGLSurface了。\n配置显示区域 #Android平台上使用Surface代表显示区域，但是通常我们不直接和Surface打交道，而是使用SurfaceView。但是使用SurfaceView也是有限制的，Surface只有在SurafceView中SurfaceHolder回调surfaceCreated发生后，surfaceDestroyed前才有效。也就是配置显示区域的操作，需要在收到surfaceCreated回调发生后才能进行。\n配置显示区域需要通过eglCreateWindowSurface方法，前两个参数都是上面两步我们获得的对象，第三个参数是个Surface相关参数，可以是Surface，也可以是SurfaceView,SurfaceHolder。另外还可以用第四个参数传递一些关于Surface的配置信息。函数调用成功后，我们就获得了一个EGLSurface对象。\n将它们连起来 #目前为止，EGLDisplay对象，EGLSurface对象还是独立的，后者只是通过前者获得了一些配置信息，除此之外再无其他联系。为了让两者关联在一起，我们需要借用EGLContext对象。 同样的，创建EGLContext对象需要通过eglCreateContext函数，前两个参数都是前面步骤中获取到的EGLDisplay、EGLConfig，特别的是第三个参数。第三个参数是EGLContext，通常情况下会传递EGL_NO_CONTEXT,代表创建独立的EGLContext对象。另外一种情况是，当两个渲染环境想共享资源时，创建第一个渲染环境还是正常传递EGL_NO_CONTEXT，创建第二个渲染环境时，则需要将第一个环境创建的EGLContext对象传递进来，则这时候第二个渲染环境就可以使用第一个渲染环境中创建的纹理，着色器，着色器程序，buffer类对象，也就是两个渲染环境共享了一些数据。 至此，三个重要对象都出场了，但是彼此间还没有联系起来，所以需要eglMakeCurrent函数来完成这个工作。这个函数会将EGLContext对象绑定到当前线程上的同时，将EGLContext对象也绑定到EGLSurface上，绑定完成后，三大对象连在了一起，OpenGL ES环境也准备妥当了。\n在进入OpenGL ES世界前，我们最后用代码的方式回顾一下之前的EGL世界\nval display = EGL14.eglGetDisplay(EGL14.EGL_DEFAULT_DISPLAY) if (EGL14.EGL_NO_DISPLAY == display) { log() return } val versions = IntArray(2) var flag = EGL14.eglInitialize(display, versions, 0, versions, 1) if (!flag) { log() return } Log.i(TAG, \u0026#34;EGL version:major = ${versions[0]}, minor = ${versions[1]}\u0026#34;) //我们希望红绿蓝通道是8位宽度 val attr = intArrayOf( EGL14.EGL_RED_SIZE, 8, EGL14.EGL_GREEN_SIZE, 8, EGL14.EGL_BLUE_SIZE, 8, EGL14.EGL_NONE ) val configs=Array\u0026lt;EGLConfig?\u0026gt;(1,{null}) val numConfig=IntArray(1) flag = EGL14.eglChooseConfig(display, attr, 0, configs, 0, 1, numConfig, 0) if (!flag) { log() return } val config=configs.first() val eglSurface=EGL14.eglCreateWindowSurface(display,config,surface, intArrayOf(EGL14.EGL_NONE),0) if (EGL14.EGL_NO_SURFACE == eglSurface) { log() return } val context=EGL14.eglCreateContext(display,config,EGL14.EGL_NO_CONTEXT, intArrayOf(EGL14.EGL_NONE),0) if (EGL14.EGL_NO_CONTEXT == context) { log() return } flag = EGL14.eglMakeCurrent(display, eglSurface, eglSurface, context) if (!flag) { log() return } 进入OpenGL ES世界 #经过漫长的准备，我们终于将渲染环境准备好了，可以正常使用OpenGL ES API了。通常，在这之后就是创建着色器和着色器程序了。当然不同的渲染场景，调用的API通常会不一样，本文我们要将窗口染成红色，则不需要创建这些东西，只需要调用两个API就行，glClearColor设置清屏颜色，glClear设置清屏位。\n当然，光有这两个功能函数还不行，我们还没设置绘制区域。是的，每次绘制都可以单独指定绘制区域，如第一次绘制我们绘制在左上角，第二次绘制，我们可以绘制在右下角，只需要在绘制前将绘制区域指定好就行，绘制区域的指定会在下次重新指定前都有效，用到的函数是glViewport。函数的前两个参数是指定起始位置，后两个参数则是距离起始位置的距离。\n有了这三个函数的帮助，OpenGL ES就会将我们那黑黢黢的黑框框染成红色了。我们来看看代码\n//我们想渲染整个区域，所以起始点是左上角，截至点是view的宽高 GLES20.glViewport(0,0,width,height) //颜色范围是0-1 GLES20.glClearColor(1f,0f,0f,1f) GLES20.glClear(GLES20.GL_COLOR_BUFFER_BIT) 上屏 #上一节我们已经将窗口染成了红色，但是运行应用后会发现显示的还是黑色，那是因为我们忘记了还有最后的上屏操作。因为进入到OpenGL ES世界后，理所应当的就是调用OpenGL ES的API，然而事实是永远记住，OpenGL ES API只负责绘制，显示相关的问题还得找EGL。OpenGL ES绘制完成后，需要使用eglSwapBuffers完成上屏操作。\n总结 #本文是OpenGL ES系列的第一篇，着重写了一下我对EGL，OpenGL ES的大体理解，表述上可能没有那么严谨，旨在帮助读者搭建一个进入这个领域的通道，并对一些主要概念有基本的印象，后期我们会针对各个环节逐个深入，希望能够起到抛砖引玉的效果。\n读完本文，读者应该对开发OpenGL ES应用流程有个简单的印象：EGL环境准备，着色器，着色器程序，渲染，上屏,清理。当然，本文只是着重讲到EGL环境准备这个环节。\n关于EGL环境准备，我们有三个对象，从理解上来说就是显示器，显示区域，显示上下文，对应EGLDisplay，EGLSurface，EGLContext。环境准备主要是从EGLDisplay为起点，获取和配置这三个对象的过程，最后使用eglMakeCurrent关联起来。当然使用OpenGL ES API完成渲染后，记得要使用eglSwapBuffers完成上屏操作。\n以上，就是本文的全部内容，咱们青山不改，绿水长流，下期见。\n源码地址请看这里\n","date":"9 May 2023","permalink":"/post/Android-OpenGLES%E5%AD%A6%E4%B9%A0-%E7%94%BB%E4%B8%AA%E9%A2%9C%E8%89%B2.html","section":"Posts","summary":"我们知道屏幕显示出内容是靠一个一个发光的RGB灯珠，而决定灯珠亮度的是一块内存区域，通过往这一块内存区域写入数据，我们就能在屏幕上观察到数据显示效果。这是个复杂又灵活的工作，为了方便完成这项工作，先驱们制定出了OpenGL标准，我们的故事也将从这里开始。\nOpenGL ES #OpenGL ES是OpenGL的精简版本，Android平台从发行伊始就提供了OpenGL ES的支持，只是不同的版本，支持的OpenGL ES版本不同，目前主流的版本还是2.0和3.0。OpenGL ES是一组API，为开发者提供配置数据，传输数据，绘制内容的能力。它的工作是和绘制严格相关的，所以光是OpenGL ES不会造成很大的理解障碍，问题出在配置OpenGL ES的配置环境上。为什么要将OpenGL ES API和配置环境分开呢，因为OpenGL ES是跨平台的API，但是实际运行的时候需要和特定平台绑定，如Android。平台间准备OpenGL ES环境所需要的条件不同，为了保证OpenGL ES的跨平台能力，就需要将配置环境单独拿出来和特定平台绑定。在Android上这个配置环境就是EGL。明确OpenGL ES API和配置OpenGL ES环境的区别不仅对理解这两个关键概念有很大帮助，更是对后期调试代码，排错帮助极大。\n工作流程 #明确了一些基本概念之后，我们接下来最重要的任务是理清OpenGL ES的工作流程。很多教程一上来就列举一大堆名词或者直接上实例，我觉得是不妥的。只有熟悉了工作流程，我们在写代码的时候才能做到心中有数，才能在排错过程中更快更准确地定位问题。\n准备环境 #OpenGL ES是由一系列API组成的，但是不代表可以在任何时机下调用这些API，而是需要运行环境进行一些设置，这就是准备环境。准备环境通常是做一些显存分配，窗口配置的工作，很繁琐却必不可少。\n准备着色器 #着色器很重要，但是对于初学者来说不需要用太多的精力来关注它，很多效果直接可以在网上找到现成的代码，但是怎样将这些代码组装成一个完整可运行的程序却不一定有。我们只需要明确着色器是OpenGL ES开发中的重要一环，这一环这一是魔法发生的地方。\n准备程序 #着色器虽然重要，但是也不能独立运行，需要由一个程序管理。这里说的程序是一个OpenGL ES对象，它负责将着色器组装在一起。在运行大部分OpenGL ES API前都需要先使用到这个对像。\n渲染 #渲染环节其实也是在准备数据，我们需要将着色器中用到的一些数据赋值，然后调用绘制API，完成最后的绘制工作。GPU会将数据传递给着色器，着色器经过流水线，将数据转换成最终的显示数据存储在显存中。\n上屏 #渲染不代表就是将数据显示出来了，而是说数据计算好了。计算好的数据要想在屏幕上看到，可能需要调用OpenGL ES环境配置工具中的某个函数，如交换缓冲或者切换显示对象。\n清理 #和内存一样，我们使用OpenGL ES API也会申请到一些资源，在渲染结束后，我们应该主动将资源释放，以便后续程序使用。很多时候我们正常申请资源没有成功，可能是前面有资源没有释放的原因。\n以上就是开发OpenGL ES应用的大致流程。由于OpenGL ES开发不好排错，所以在发现问题时最有效的定位方法是确定出错环节，然后再针对性地处理。所以熟悉流程很重要。\n实例上手 #由于OpenGLES相关概念很多，为了尽可能减少相关概念的干扰，本文打算只将上述流程中的第一步拿出来着重讲解。同时利用涉及到的知识点，实现一个最小的示例——将窗口染成红色。\n下面开始讲解第一个概念——EGL。\nEGL #OpenGL ES只是对绘图的抽象，没有提供运行环境的抽象。如要申请显存，显存在哪里，需要明确，图像计算好了，显示在哪里，也需要指定。EGL就是对这些环境抽象的集合，为了通俗地解释相关概念，我们可以玩一下角色扮演——假如让我们设计相关标准，我们该如何做。","title":"Android-OpenGLES学习-画个颜色"},{"content":"","date":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories"},{"content":"","date":null,"permalink":"/tags/opengles/","section":"Tags","summary":"","title":"OpenGLES"},{"content":"","date":null,"permalink":"/categories/opengles/","section":"Categories","summary":"","title":"OpenGLES"},{"content":"","date":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts"},{"content":"","date":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags"},{"content":"","date":null,"permalink":"/","section":"低头沉思","summary":"","title":"低头沉思"},{"content":"","date":null,"permalink":"/tags/%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/","section":"Tags","summary":"","title":"学习指南"},{"content":"","date":null,"permalink":"/tags/c++/","section":"Tags","summary":"","title":"C++"},{"content":"","date":null,"permalink":"/categories/c++/","section":"Categories","summary":"","title":"C++"},{"content":" 模板作为C++重要的特性，一直有着举足轻重的地位，是编写高度抽象代码的利器。\n什么是模板 #模板在现实生活中就是范例：把都一样的部分固定起来，把变动的部分空出来，使用时将两部分合起来组成有效的东西。如申请书，Word模板都是这种形式。C++中的模板也是如此，不过更明确的是C++中的模板，变动的部分是一个代指类型的东西，称之为泛型参数。\n我们先从一个例子来看一看模板是怎样发展而来的。如我们需要计算两个对象相加的结果，该如何写代码呢？在写代码前，我们有几个问题需要讨论清楚： 首先我们需要确定的是这两个对象是什么类型，毕竟C++是强类型的编程语言，变量，函数，类都是要明确指定类型是什么的，不确定的类型编译就不能通过。我们先假设这两个类型是整型。确定了类型之后，还需要确定这两个对象需要怎样加起来，根据我们假设的整型，我们知道可以直接调用运算符+。最后我们需要确定，两个对象相加后的结果类型是什么，整型相加的结果也是整型。综上，这个例子的代码看起来可能是这样的\nint sum(int left,int right){ return left + right; } 这个例子很简单，简单到甚至都不需要单独写成一个函数。如果我们需要计算的数据不是两个数，而是一个数组的和呢？基于前面的分析和假设，我们也能很快实现相应的代码\nint sum(const int data[], const std::size_t length) { int result{}; for (int i = 0; i \u0026lt; length;++i) { result += *(data + i); } return result; } 同样很简单。但是遗憾的是，这个函数通用性不强，它只能计算整型的数组和，假如我们需要计算带有小数点的数组和，它就不灵了，因为第一个参数类型不匹配，尽管我们知道sum的代码几乎都能复用，除了第一行的int需要替换成double。但是不能！我们只能复制一份，然后把int的地方改成double。\ndouble sum(const double data[], const std::size_t length) { double result{}; for (int i = 0; i \u0026lt; length;++i) { result += *(data + i); } return result; } 这时你就会发现问题了，这个过程，我们仅仅改变了类型信息。这样的问题还会继续增加，我们可能又需要求float的数组和，上面那个double的数组和同样匹配不了，因为float，double是两个类型。正是因为数据类型不一样，所以很多时候我们需要为不同的数据提供相似的代码，这在数据类型膨胀的情况下是很痛苦的，当对算法进行修改的时候我们需要保证所有的数据类型都被修改到，并且要逐个进行测试，这无疑会增加工作量，并放大错误率。但是实际有效的代码都是要明确类型的，如果类型不明确，编译器就没法确定代码是否合法，不确定的事情编译器就要报错，所以按照普通的思路，这个问题是无解的。 但是其实很多时候，这些相似的代码仅仅是数据类型不一样而已，对付这种重复的工作应该让给计算机来完成，也就是编译器。所以我们需要一种技术，让编译器先不管具体类型是什么，而是用一种特殊的类型来替换，这个类型可以替换成任何类型，用这个特殊的类型完成具体的算法，在使用的时候根据实际的需求，将类型信息提供给算法，让编译器生成满足所提供类型的具体算法，而这就是模板。这和生活中的模板思想上是共通的。算法是固定的部分，数据类型是可变的部分，两个合起来就是合法的C++代码。也就是利用模板，我们可以只写一个算法，借助编译器生成所有类型的算法，这些算法之间唯一不同的就是类型。 当然光有模板还不够，上面只解决了类型的问题，没有解决算法实现的问题。怎么说呢，如我们有一个需求，需要将数据先排序，再查找最大值。这对于数字（int,float,double等）类型是有效的，直接使用比较运算符（\u0026lt;,\u0026gt;）就可以完成了，但是假如想让这个算法适用于自定义类型呢？直接在模板实现中写比较运算符对自定义类型是无效的，因为自定义类型没有实现相对应的比较运算函数。解决方法也很简单，自定义类型实现相对应的比较运算符就行了。诸如此类的问题，在模板中会经常遇到，因为我们对类型的信息一无所知，但是又要确保几乎所有的类型都能正常运作，这就不得不运用各种技术对类型进行限定或者检测，这其实才是模板问题的精髓。所以模板问题不仅仅是类型问题，还是其他C++问题的综合体，需要对C++特性有着较为完整的理解，才能写出有用高效的代码。 C++中通常将模板分为函数模板和模板类，我们先从比较简单的函数模板开始认识。\n函数模板 #函数模板是一种函数，和普通函数不一样的地方是，它的参数列表中至少有一个是不确定类型的。我们用开头的例子来小试牛刀：\ntemplate \u0026lt;typename T\u0026gt; T sum(const T data[], const std::size_t length) { T result{}; for (int i = 0; i \u0026lt; length;++i) { result += *(data + i); } return result; } int main() { int intData[] = { 1, 1, 2, 2 }; float floatData[] = { 1, 1, 2, 2 }; double doubleData[] = { 1, 1, 2, 2 }; auto len = sizeof(intData)/sizeof(intData[0]); std::cout \u0026lt;\u0026lt; \u0026#34;intSum = \u0026#34; \u0026lt;\u0026lt; sum\u0026lt;int\u0026gt;(intData,len) \u0026lt;\u0026lt; \u0026#34;, floatSum = \u0026#34; \u0026lt;\u0026lt; sum\u0026lt;float\u0026gt;(floatData,len) \u0026lt;\u0026lt;\u0026#34;, doubleSum = \u0026#34; \u0026lt;\u0026lt;sum\u0026lt;double\u0026gt;(doubleData,len)\u0026lt;\u0026lt;std::endl; return 0; } // 输出 // intSum = 6, floatSum = 6, doubleSum = 6 在这里，我们仅仅写了一个函数，就可以同时适用于int，float，double。如果还有其它类型实现了默认初始化和运算符+=就同样可以使用这个函数来求和，不需要改动任何现有代码，这就是模板的魅力。 在继续看新东西前，我们先来认识一下函数模板和普通函数之间有什么不同：\n函数模板需要一个模板头，即template\u0026lt;typename T\u0026gt;。它的作用是告诉编译器下面的函数中遇到T的地方都不是具体类型，需要在调用函数时再确定。 函数声明中，类型位置被T替代了，也就是说T是一个占位类型，可以将它当作普通类型来用。在写模板代码时，这是很有用的。 再来看使用函数的地方，也就是类似sum\u0026lt;xxx\u0026gt;(xxxData,len)的语句，其中的xxx代表数据类型，也就是函数模板中T的实际类型。简单来说就告诉编译器，用类型xxx替换函数模板中的类型T，这个过程有个官方的名字，实例化,这是另一个和普通函数不一样的地方.。用函数模板是需要经过两个步骤的。\n定义模板。这一步没有具体类型，需要使用一个泛型参数来对类型占位，也就是只要是出现实际类型的地方，都要使用泛型参数来占位，并用这个泛型参数来实现完整的算法。这一步编译器由于不知道具体类型，不会对一些类型操作进行禁止，而只是检查标识符是否存在，语法是否合法等。 实例化。实例化的过程只会发生在开发者调用函数模板的地方，没有实例化的函数模板的代码是不会出现在最执行文件中的。编译器会对每一处发生实例化的地方，用实际参数来替换泛型参数，并检查实际类型是否支持算法中所有的操作，如果不支持，则编译失败，需要开发者实现相关的操作或者修改函数模板。如上例中，假如我们用一个自定义类型来实例化，就会发现编译无法通过，因为自定义类型没有定义操作符+=（除非该操作符已经被定义了），这个过程就发生在实例化。解决方案也很简单，对自定义类型添加操作符+=即可。 类型推导 #在上例中，我们发现在实例化的过程中，要同时给函数模板传递类型参数和数据参数，并且类型参数往往和数据的类型是一一对应的，这中冗杂的语法对于现代C++来说是不可接受的，所以现代C++编译器都支持类型推导。类型推导可以让开发者省略类型参数，直接根据数据类型来推导出类型参数，所以上例实例化都可以写成sum(xxxData,len)的形式，编译器能分别推导出xxx的类型是int,float，double。 当然类型推导也不是万能的，我们来看下面这个例子\ntemplate \u0026lt;typename T\u0026gt; T max(T a, T b) { return a \u0026gt; b ? a : b; } int main() { int a = 1; int b = 2; std::cout \u0026lt;\u0026lt; \u0026#34;max(\u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34;,\u0026#34;\u0026lt;\u0026lt;b\u0026lt;\u0026lt;\u0026#34;) = \u0026#34; \u0026lt;\u0026lt;max(a,b) \u0026lt;\u0026lt; std::endl; return 0; } // 输出 // max(1,2) = 2 这个例子很直观，结果当然也毫无意外。现在我们要变形了：我们把变量b的类型改为float，就会发现编译无法通过了。提示我们数据类型不匹配，因为a是int，b是float，所以推导出的结果就是max\u0026lt;int,float\u0026gt;()，而实际上我们是只有一个类型参数的。 那既然问题很明了，解决方法也似乎很简单，给max再加一个参数不就行了吗？我们来看一看。\ntemplate \u0026lt;typename A,typename B\u0026gt; A max(A a, B b) { return a \u0026gt; b ? a : b; } int main() { int a = 1; float b = 2; std::cout \u0026lt;\u0026lt; \u0026#34;max(\u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34;,\u0026#34;\u0026lt;\u0026lt;b\u0026lt;\u0026lt;\u0026#34;) = \u0026#34; \u0026lt;\u0026lt;max(a,b) \u0026lt;\u0026lt; std::endl; return 0; } // 输出 // max(1,2) = 2 经过这样改之后，编译和运行都不报错了，问题似乎解决了，是吗？ 并不是，我们把float b = 2;换成float b = 2.5;，\nint main() { int a = 1; float b = 2.5; std::cout \u0026lt;\u0026lt; \u0026#34;max(\u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34;,\u0026#34;\u0026lt;\u0026lt;b\u0026lt;\u0026lt;\u0026#34;) = \u0026#34; \u0026lt;\u0026lt;max(a,b) \u0026lt;\u0026lt; std::endl; return 0; } // 输出 // max(1,2.5) = 2 再次运行程序，就会发现输出是错误的了。因为函数模板中，我们把返回值定义成了A，在实例化的时候A被推导成了int类型，所以实际上max的返回值就成了int类型，最大值B就被从float强制转换成了int类型，丢失了数据精度。那有没有解决方法呢？有的，而且不止一种! 根据上面的分析，其问题的根本是数据被强转了，解决方案当然就是阻止它发生强转，也就是保持两种数据类型是一致的，那怎么保证呢？阻止编译器的类型推导，手动填写类型参数。\nint main() { int a = 1; float b = 2.5; std::cout \u0026lt;\u0026lt; \u0026#34;max(\u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34;,\u0026#34;\u0026lt;\u0026lt;b\u0026lt;\u0026lt;\u0026#34;) = \u0026#34; \u0026lt;\u0026lt;max\u0026lt;float\u0026gt;(a,b) \u0026lt;\u0026lt; std::endl; return 0; } // 输出 // max(1,2.5) = 2.5 可以看到在此例中，我们只填写了一个类型参数，因为类型B会自动推导成float。没错，类型推导是可以部分禁用的！ 另一种解决方案就是完全让编译器计算类型。怎么计算呢，C++11提供了auto和decltype。auto可以计算变量的类型，decltype可以计算表达式的类型，用法如下：\nauto a=1; // a被推导成int类型 auto b=1.5; // b被推导成double类型 decltype(a+b) //结果是double类型 也就是可以将返回值置为auto，然后让编译器决定返回类型\ntemplate \u0026lt;typename A,typename B\u0026gt; auto max(A a, B b) { return a \u0026gt; b ? a : b; } int main() { int a = 1; float b = 2.5; std::cout \u0026lt;\u0026lt; \u0026#34;max(\u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34;,\u0026#34;\u0026lt;\u0026lt;b\u0026lt;\u0026lt;\u0026#34;) = \u0026#34; \u0026lt;\u0026lt;max\u0026lt;float\u0026gt;(a,b) \u0026lt;\u0026lt; std::endl; return 0; } // 输出 // max(1,2.5) = 2.5 假如编译器只支持C++11的话，会麻烦一点，不仅要前置auto，在函数头后还要使用decltype来计算返回类型，这个特性称为尾返回推导。\ntemplate \u0026lt;typename A,typename B\u0026gt; auto max(A a, B b)-\u0026gt;decltype(a + b) { return a \u0026gt; b ? a : b; } 这里decltype里面写的是 函数模板暂时放一放，我们来看一看类模板是怎样的。\n类模板 #和函数模板一样，类模板也至少包含一个泛型参数，这个泛型参数的作用域是整个类，也就是说可以使用这个泛型参数定义成员变量和成员函数。\ntemplate \u0026lt;typename T\u0026gt; class Result { T data; int code; std::string reason; public: Result(T data, int code = 0, std::string reason = \u0026#34;success\u0026#34;) :data{ data }, code{ code }, reason{ reason } { } friend std::ostream\u0026amp; operator\u0026lt;\u0026lt;(std::ostream\u0026amp; os, const Result result) { os \u0026lt;\u0026lt; \u0026#34;Result(data = \u0026#34; \u0026lt;\u0026lt; result.data \u0026lt;\u0026lt;\u0026#34;, code = \u0026#34; \u0026lt;\u0026lt; result.code \u0026lt;\u0026lt;\u0026#34;, reason = \u0026#34; \u0026lt;\u0026lt; result.reason \u0026lt;\u0026lt;\u0026#34;)\u0026#34; \u0026lt;\u0026lt; std::endl; return os; } }; int main() { Result\u0026lt;int\u0026gt; result{ 9527 }; std::cout \u0026lt;\u0026lt; result \u0026lt;\u0026lt; std::endl; return 0; } // 输出 // Result(data = 9527, code = 0, reason = success) 可以看到，类模板和普通类类似，普通类有的它都有——成员函数，成员变量，构造函数等等，值得一说的依然是这个泛型参数T。上例是SDK中常见的数据类，用于指示操作是否成功并且必要时返回操作结果。对于返回一般数据类型，这个类已经足够了，但是假如我们的某个接口无返回值，按照传统即返回void类型，问题出现了。data的实际类型是void，但是我们找不到任何值来初始化它。更进一步，返回void的时候，我们根本不需要data这个成员变量。为了解决类似这种问题，模板提供了特化。\n特化和偏特化 #特化就是用特定类型替代泛型参数重新实现类模板或者函数模板，它依赖于原始模板。如上例中，我们已经有了原始模板类Result\u0026lt;T\u0026gt;，为了解决void不能使用的情况，我们需要为void类型重新定义一个Result，即Result\u0026lt;void\u0026gt;，则Result\u0026lt;void\u0026gt;就称为Result\u0026lt;T\u0026gt;的一种特化，原来的Result\u0026lt;T\u0026gt;称为原始模板类。这样的特化版本可以有很多个，一个类型就是一个特化版本，它完美融合了通用性和特殊性两个优势。当实例化过程中，如果实例化类型和特化类型一致，则实例化将使用特化的那个类（函数）来完成，如下面的例子\n// Result定义保持不变，新增特化版本 template \u0026lt;\u0026gt; class Result\u0026lt;void\u0026gt;{ int code; std::string reason; public: Result(int code = 0, std::string reason = \u0026#34;success\u0026#34;): code{ code }, reason{ reason }{} friend std::ostream\u0026amp; operator\u0026lt;\u0026lt;(std::ostream\u0026amp; os, const Result result) { os \u0026lt;\u0026lt; \u0026#34;Result(\u0026#34;\u0026lt;\u0026lt;\u0026#34;code = \u0026#34; \u0026lt;\u0026lt; result.code \u0026lt;\u0026lt; \u0026#34;, reason = \u0026#34; \u0026lt;\u0026lt; result.reason \u0026lt;\u0026lt; \u0026#34;)\u0026#34; \u0026lt;\u0026lt; std::endl; return os; } }; int main() { Result\u0026lt;void\u0026gt; voidResult; Result\u0026lt;int\u0026gt; intResult{9527}; std::cout \u0026lt;\u0026lt; \u0026#34;void = \u0026#34;\u0026lt;\u0026lt; voidResult\u0026lt;\u0026lt;std::endl\u0026lt;\u0026lt;\u0026#34;int = \u0026#34; \u0026lt;\u0026lt; intResult \u0026lt;\u0026lt; std::endl; return 0; } // 输出 // void = Result(code = 0, reason = success) // int = Result(data = 9527, code = 0, reason = success) 可以看到，当实例化为int类型时，使用的是原始的模板类。而当实例化为void类型时，使用的是特化的版本。 除了特化，还有偏特化。偏特化和特化很像，就是对类型进行一个更窄的限定，使之适用于某一类类型，如const，指针，引用等。或者对有多个泛型参数的类进行部分特化。 特化和偏特化是对模板特殊类型的补充，解决的是模板实现上的一些问题。很多时候如果通用模板不好实现，可以考虑使用特化。当然，特化版本越多，模板的维护成本就越高，这时候就该考虑是否是设计上存在缺陷了。\n类型限定 #C++模板的强大不仅仅表现在对类型的操作上，有时候为了防止我们的类被滥用，我们还需要对这些能力做一些限定，比如禁止某些特定的类型实例化。 在上面的例子中，假设我们规定Result必须返回实际的数据，禁止void实例化该怎么做呢？容易想到的是，我们首先需要一种方法判断实例化时的类型是否是特定类型，然后需要在实例化类型是禁止类型时告诉编译器编译失败。所有的这些，标准库type_traits都提供了支持。它提供了一系列工具来帮助我们识别类型参数，如数字，字符串，指针等等，也提供了一些其他工具辅助这些类型参数工具完成更复杂的功能。 此例中，我们希望实例化类型不能是void，经过查找type_traits，我们发现有个is_void的类，它有个value常量，这个常量在类型参数为void是为true，否则为false。当然有了判定方法还不够，我们还需要在类型不匹配时让编译器报错的方法，恰好，我们有enable_if_t。它有两个类型参数，第一个是布尔表达式，第二个是类型参数。当表达式为真时，类型参数才有定义，否则编译失败。所以为了完成禁止void实例化的功能，我们需要借助两个工具，is_void判断类型参数是否是void,enable_if_t完成布尔表达式到类型参数的转换。综上，让我们来看看实现：\ntemplate \u0026lt;typename T\u0026gt; class Result { std::enable_if_t\u0026lt;!std::is_void\u0026lt;T\u0026gt;::value,T\u0026gt; data; int code; std::string reason; public: Result(std::enable_if_t\u0026lt; !std::is_void\u0026lt;T\u0026gt;::value,T\u0026gt; data, int code = 0, std::string reason = \u0026#34;success\u0026#34;) :data{ data }, code{ code }, reason{ reason } { } friend std::ostream\u0026amp; operator\u0026lt;\u0026lt;(std::ostream\u0026amp; os, const Result\u0026lt; std::enable_if_t\u0026lt; !std::is_void\u0026lt;T\u0026gt;::value, T\u0026gt;\u0026gt; result) { os \u0026lt;\u0026lt; \u0026#34;Result(data = \u0026#34; \u0026lt;\u0026lt; result.data \u0026lt;\u0026lt;\u0026#34;, code = \u0026#34; \u0026lt;\u0026lt; result.code \u0026lt;\u0026lt;\u0026#34;, reason = \u0026#34; \u0026lt;\u0026lt; result.reason \u0026lt;\u0026lt;\u0026#34;)\u0026#34; \u0026lt;\u0026lt; std::endl; return os; } }; 例中，第3行和第8行都用到了类型限定，其实我们只需要在构造函数是对T限定就可以了。当用void来实例化Result时，将无法通过编译。\n其他问题 #C++模板有两方面的问题要解决，一方面是本身模板相关的问题，而另一方面就是和其他特性一起工作。如C++11引入了右值引用，但是右值引用通过参数传递以后会造成引用坍缩，丢失其右值引用的性质，表现得像一般引用类型，为了解决这个问题，C++提供了std::move工具。这对于普通函数是没问题的，但是假如这是一个模板函数呢？C++同样提供了完美转发的解决方法。 所谓完美转发，就是让右值引用保持右值引用，左值引用也保持左值引用。它需要配合万能引用一起使用。万能引用和右值引用很相似，只不过万能引用类型是不确定的，在编译期才能确定。看下面的例子\ntemplate \u0026lt;typename T\u0026gt; void test(T\u0026amp;\u0026amp; p) { std::cout \u0026lt;\u0026lt; \u0026#34;p = \u0026#34; \u0026lt;\u0026lt; std::forward\u0026lt;T\u0026gt;(p) \u0026lt;\u0026lt; std::endl; } int main() { int a = 1; test(a); test(std::move(a)); return 0; } // 输出 // p = 1 // p = 1 T\u0026amp;\u0026amp;是万能引用，因为它类型不确定，然后通过std::forward\u0026lt;\u0026gt;转发参数。可以看到在8，9行，我们成功传递给test左值和右值，并且也成功得到了预期结果，不需要为右值单独写函数来处理。模板的这个功能极大简化了函数的设计，对于API的设计来说简直就是救星。 此外，函数模板还有重载的问题。通常来说普通函数的优先级会高于函数模板的优先级，函数模板之间越特殊的会优先匹配等等。这些问题随着对模板了解的深入，会慢慢出现，但是在学习初期没必要花费太多精力来了解这些特性，一切以实用为主。\n总结 #模板是C++中很大的一个课题，融合了类型系统，标准库，类等一系列的大课题。所以写出完美的模板代码需要首先对这些课题有较为完整的了解。其次由于模板对类型控制较为宽松，还需要开发者对模板的适用范围有全局的把控，禁止什么，对什么类型需要特殊化处理，都要考虑到位，稍不注意就会隐藏一个难以察觉的bug。 总之就是一句话，模板是常学常新，常用常新的，需要在实践中学习，又要在学习中实践的东西，祝大家每次都有新收获！\n参考资料 # type_traints ","date":"31 October 2022","permalink":"/post/%E7%8E%B0%E4%BB%A3C++%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97%20%E6%A8%A1%E6%9D%BF.html","section":"Posts","summary":"模板作为C++重要的特性，一直有着举足轻重的地位，是编写高度抽象代码的利器。\n什么是模板 #模板在现实生活中就是范例：把都一样的部分固定起来，把变动的部分空出来，使用时将两部分合起来组成有效的东西。如申请书，Word模板都是这种形式。C++中的模板也是如此，不过更明确的是C++中的模板，变动的部分是一个代指类型的东西，称之为泛型参数。\n我们先从一个例子来看一看模板是怎样发展而来的。如我们需要计算两个对象相加的结果，该如何写代码呢？在写代码前，我们有几个问题需要讨论清楚： 首先我们需要确定的是这两个对象是什么类型，毕竟C++是强类型的编程语言，变量，函数，类都是要明确指定类型是什么的，不确定的类型编译就不能通过。我们先假设这两个类型是整型。确定了类型之后，还需要确定这两个对象需要怎样加起来，根据我们假设的整型，我们知道可以直接调用运算符+。最后我们需要确定，两个对象相加后的结果类型是什么，整型相加的结果也是整型。综上，这个例子的代码看起来可能是这样的\nint sum(int left,int right){ return left + right; } 这个例子很简单，简单到甚至都不需要单独写成一个函数。如果我们需要计算的数据不是两个数，而是一个数组的和呢？基于前面的分析和假设，我们也能很快实现相应的代码\nint sum(const int data[], const std::size_t length) { int result{}; for (int i = 0; i \u0026lt; length;++i) { result += *(data + i); } return result; } 同样很简单。但是遗憾的是，这个函数通用性不强，它只能计算整型的数组和，假如我们需要计算带有小数点的数组和，它就不灵了，因为第一个参数类型不匹配，尽管我们知道sum的代码几乎都能复用，除了第一行的int需要替换成double。但是不能！我们只能复制一份，然后把int的地方改成double。\ndouble sum(const double data[], const std::size_t length) { double result{}; for (int i = 0; i \u0026lt; length;++i) { result += *(data + i); } return result; } 这时你就会发现问题了，这个过程，我们仅仅改变了类型信息。这样的问题还会继续增加，我们可能又需要求float的数组和，上面那个double的数组和同样匹配不了，因为float，double是两个类型。正是因为数据类型不一样，所以很多时候我们需要为不同的数据提供相似的代码，这在数据类型膨胀的情况下是很痛苦的，当对算法进行修改的时候我们需要保证所有的数据类型都被修改到，并且要逐个进行测试，这无疑会增加工作量，并放大错误率。但是实际有效的代码都是要明确类型的，如果类型不明确，编译器就没法确定代码是否合法，不确定的事情编译器就要报错，所以按照普通的思路，这个问题是无解的。 但是其实很多时候，这些相似的代码仅仅是数据类型不一样而已，对付这种重复的工作应该让给计算机来完成，也就是编译器。所以我们需要一种技术，让编译器先不管具体类型是什么，而是用一种特殊的类型来替换，这个类型可以替换成任何类型，用这个特殊的类型完成具体的算法，在使用的时候根据实际的需求，将类型信息提供给算法，让编译器生成满足所提供类型的具体算法，而这就是模板。这和生活中的模板思想上是共通的。算法是固定的部分，数据类型是可变的部分，两个合起来就是合法的C++代码。也就是利用模板，我们可以只写一个算法，借助编译器生成所有类型的算法，这些算法之间唯一不同的就是类型。 当然光有模板还不够，上面只解决了类型的问题，没有解决算法实现的问题。怎么说呢，如我们有一个需求，需要将数据先排序，再查找最大值。这对于数字（int,float,double等）类型是有效的，直接使用比较运算符（\u0026lt;,\u0026gt;）就可以完成了，但是假如想让这个算法适用于自定义类型呢？直接在模板实现中写比较运算符对自定义类型是无效的，因为自定义类型没有实现相对应的比较运算函数。解决方法也很简单，自定义类型实现相对应的比较运算符就行了。诸如此类的问题，在模板中会经常遇到，因为我们对类型的信息一无所知，但是又要确保几乎所有的类型都能正常运作，这就不得不运用各种技术对类型进行限定或者检测，这其实才是模板问题的精髓。所以模板问题不仅仅是类型问题，还是其他C++问题的综合体，需要对C++特性有着较为完整的理解，才能写出有用高效的代码。 C++中通常将模板分为函数模板和模板类，我们先从比较简单的函数模板开始认识。","title":"现代C++学习指南 模板"},{"content":"个人简介 #喜欢编程，喜欢一个人\n技术栈 # Android Kotlin C++ Python JavaScript HTML/CSS 联系方式 #QQ:632518410\nhonguilee@163.com\nBuy me a coffee\n","date":"26 July 2022","permalink":"/about.html","section":"低头沉思","summary":"个人简介 #喜欢编程，喜欢一个人\n技术栈 # Android Kotlin C++ Python JavaScript HTML/CSS 联系方式 #QQ:632518410\nhonguilee@163.com\nBuy me a coffee","title":"关于我"},{"content":" 在[上一章](https://www.yuque.com/docs/share/adb5b1e4-f3c6-46fd-ba4b-4dabce9b4f2a?# 《现代C++学习指南-类型系统》)我们探讨了C++的类型系统，并提出了从低到高，又从高到低的学习思路，本文就是一篇从高到低的学习指南，希望能提供一种新的视角。\n什么是标准库 #编程语言一般分为两个部分，一部分是语法部分，如上一章的类型系统，另一部分则是用这套语法完成的预定义的工具集，如本文的主题——标准库。标准库是一堆我们写代码时直接可以用的代码，就像是我们提前写好的一样，不仅如此，标准库还是跨平台的，还是经过工业级测试的，所以标准库有着靠谱，安全的特点。 C++标准库包括很多方面，有类vector、string等,有对象std::cin，std::cout等，还有函数move，copy等，所以一般按功能来对它们分类\n容器类 算法类 智能指针 线程相关 其他 当然，这些还不是全部，标准库是在不断扩充和完善的，学习标准库的宗旨也应该是学习它们的使用场景，而不是深入用法。比如容器类中就有很多功能类似的类，不同的业务场景有不同的选择。通过对它们的了解，我们更容易写出高效，简洁的代码。\n容器类 #容器类就是帮助管理一组数据的类，根据实现方式的不同，分为有序列表，无序列表和映射。 有序列表中的有序是指，数据组保存在一块连续的内存区域里，可以通过插入时的索引直接定位到原数据。因为数据是按顺序存入的，所以中途假如需要删除或者新增数据，在操作位置右边的数据都需要移动，操作的代价就比较大。由此也可看出它们的优势是顺序插入和尾部修改，还有直接查找，这方面的代表就是array，vector。 array是对原始数组的封装，并且解决了传递数组变成指针这样的问题，但是缺点是它的大小是固定的，适合用在数据量已知的情况。而vector又是对array的增强，不仅能完成所有array的操作，并且大小可变，所以绝大部分情况下，选择vector都是理想的选择。 无序列表的元素是单独存储的，相互之间用指针来查找相邻元素，由于指针可以轻易修改指向的指，所以对相邻元素的修改就变得很快捷。同样的道理，查找相邻元素只能靠指针跳转，查找某个值需要从一个指针开始查找，一次跳转一条数据，直到找到目标或者没有数据为止。所以无序列表的优势是快速地删除和插入新数据，不适合查找，其代表有list，forward_list。显然，有序列表和无序列表是互补的，我们在实际项目中，应该根据数据的操作来确定选择哪种容器。 映射则融合了有序列表和无序列表的优点，既可以快速插入和删除，又可以快速查找。为了满足各种使用场景，C++提供了map，multimap，unordered_map，unordered_multimap。从名字上就能看出来它们的差别。为了直观，我直接列了一个表\n是否排序 是否支持相同值 速度 unordered_map ❌ ❌ ❤️❤️❤️❤️ map ✅ ❌ ❤️❤️ multimap ✅ ✅ ❤️ unordered_multimap ✅ ✅ ❤️❤️❤️ 映射存储的是两个值，不同的类型实现方式不一样。由于map是需要排序的，所以通常它的实现是一种平衡二叉树，键就是它排序的依据。 而unordered_map是不需要排序的，所以它的实现通常是哈希表，即根据哈希函数的确定索引位置继而确定存储位置。 综上，容器类提供了一种操作多个同类型数据的接口，开发者通过对容器类方法的调用，可以实现对容器内数据的增删改查。大部分情况下，vector都是靠谱的选择，它提供了全功能的数据操作接口，支持动态长度，索引查询，并且简单高效。如果需要频繁地插入或者删除操作，也可以考虑list或者forward_list。map可以让数据保持有序，需要更快的速度而不是排序的话unorderer_map是更好的选择，如果相同值会出现多次就可以使用对应的multi版本。另外容器类也是很好的数据结构学习资源，C++的容器类几乎提供了数据结构中所有的形式，对数据结构越熟悉选择的容器类就越完美。\n算法 #之所以将算法放在容器类后面，是因为算法大部分是对容器类操作的加强，算法都定义在algorithm文件头里。这些算法都是短小精悍的，可以大大增加代码可读性，并且妥善处理了很多容易遗忘的边界问题。功能上可以分为增删改查几种操作，可以在实际有需要的时候在查看文档，具体可以参阅这里\n智能指针 #很早以前，我对智能指针的态度不是很好。因为刚开始学习C++时我就知道，不能单独使用指针，要把指针封装在类里，利用类的构造函数和析构函数管理指针，也就是RAII。最开始我以为这就够了,直到我遇到下面这种情况\npublic: Ptr():p{ new int } {} ~Ptr() { delete p; } int\u0026amp; get() { return *p; } void set(const int value) { *p = value; } private: int* p; }; void use(Ptr p) { //传进来的是复制构造出来的p\u0026#39;,函数返回后p\u0026#39;被销毁啦，两个指针指向的地址被回收，外面的p指针成为了野指针 } int main() { Ptr p; p.set(1); use(p); //p按值传递，调用了Ptr的复制构造函数，构造出了新对象p\u0026#39;,它的指针和p的指针指向同一个地方 std::cout \u0026lt;\u0026lt; p.get() \u0026lt;\u0026lt; std::endl; //p已经被销毁了，访问p的地址非法 return 0; } 调用use时，变量p被拷贝，也就出现了两个指针同时指向一块内存地址的情况。use函数执行完后，它的参数p被回收。也就是调用了Ptr的析构函数，也就是两个指针指向的地址被回收。所以24行调用get读取那个已经被回收了的地址就是非法操作，程序崩溃。 这可能是新手比较常遇到的一个问题，当然，解决这个问题也很简单，还用不到智能指针，只需要将函数use的参数改为引用类型就可以了，因为引用只是别名，不会产生新的指针，这也是我在类型系统篇中极力推荐引用为首选参数类型的原因之一。对于此例，数据不大，直接重写复制构造函数，重新申请一块内存也是一种思路。 此例中用到Ptr的地方只有一个，实际项目中Ptr往往需要用到很多次，我们不能保证不会出现忘记使用引用类型的情况，这种情况下重新申请内存也不适用，所以这个时候就需要智能指针来帮忙了。 现在思考另一种情况，某些操作我们不得不暴露出我们的指针供外部使用，随着业务的嵌套和调用链增加，很多时候会忘记或者不确定在什么时候调用delete释放内存。这也是用智能指针的一个场景。以上两种情况都是需要分享指针，对应智能指针中的shared_ptr。 shared_ptr顾名思义，它可以帮助开发者完成指针共享的问题，并且完美解决提前释放，不知何时释放，谁负责释放的问题。它的对应关系是一对多，一个实际的内存可以被多个shared_ptr共享 另外一种场景是我们希望自始至终某个指针某个时刻只属于一个对象，外部想要使用它要么通过拥有该指针的对象方法，要么把指针的所有权转移到自己身上，这种场景对应智能指针中的unique_ptr。 unique_ptr的对应关系是一对一，无论哪个时刻，只能有一个管理者拥有指针，也就只能由它负责释放了。假如想转移这种对应关系，只能通过std::move操作，不过这个操作之后，原先对象的指针就失效了，它也不再负责管理，所有的任务移交给了新的对象。这种特性特别适合资源敏感型的应用。\n线程库 #除了内存，线程是开发中另一个重要的课题。线程的难点在于不仅要管理线程对象，还要管理线程对象管理的资源，并且保证线程间数据同步。当然标准库已经做得足够好了，我们需要理解的是使用场景的问题。线程库主要包括线程对象thread，条件对象condition_variable，锁对象mutex。 使用thread可以很方便地把程序写成多线程，只需要三步：\nvoid plus(int a,int b){ //第一步：定义线程中要运行的函数 std::cout\u0026lt;\u0026lt;\u0026#34;running at sub thread\u0026#34;\u0026lt;\u0026lt;std::endl; std::cout\u0026lt;\u0026lt;\u0026#34;a + b = \u0026#34;\u0026lt;\u0026lt;a+b\u0026lt;\u0026lt;std::endl; } int main(){ std::thread thread{plus,1,1}; //第二步，定义std::thread对象，将函数作为参数 std::cout\u0026lt;\u0026lt;\u0026#34;continue running at main thread\u0026#34;\u0026lt;\u0026lt;std::endl; thread.join(); //第三步调用线程对象的join函数或者detach函数 std::cout\u0026lt;\u0026lt;\u0026#34;sub thread finished!\u0026#34;\u0026lt;\u0026lt;std::endl; } //输出 //\tcontinue running at main thread //\trunning at sub thread // a + b = 2 // sub thread finished! 难点在线程间通信，也就是解决两个问题\n线程1更新了变量v的值 线程2马上能读取到正确的变量v的值，即线程1更新的那个最新值 为了协调这两个过程，就出现了锁对象mutex和条件对象condition_variable。锁对象mutex保证变量按照正确的顺序更改。条件对象condition_variable保证更改能被其他线程监听到。\nint a,b; bool ready = false; std::mutex mux; std::condition_variable con; void plus() { std::cout \u0026lt;\u0026lt; \u0026#34;running at sub thread\u0026#34; \u0026lt;\u0026lt; std::endl; //因为我们要读取ready的最新值，所以要用锁保证读取结果的有效性 std::unique_lock\u0026lt;std::mutex\u0026gt; guard{ mux }; if (!ready) { //数据没准备好，休息一下！ con.wait(guard); } //这里就可以正确读变量a,b了 std::cout \u0026lt;\u0026lt; \u0026#34;a + b =\u0026#34; \u0026lt;\u0026lt; a + b \u0026lt;\u0026lt; std::endl; } int main() { std::thread thread{ plus}; std::cout \u0026lt;\u0026lt; \u0026#34;continue running at main thread\u0026#34; \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;input a = \u0026#34;; std::cin \u0026gt;\u0026gt; a; std::cout \u0026lt;\u0026lt; \u0026#34;input b = \u0026#34;; std::cin \u0026gt;\u0026gt; b; { //数据准备好了，该通知子线程干活了，用大括号是因为想让锁因为guard的销毁即使释放，从未保证plus里面能重新获得锁 std::unique_lock\u0026lt;std::mutex\u0026gt; guard{ mux }; //更新数据 ready = true; //通知 con.notify_all(); } thread.join(); std::cout \u0026lt;\u0026lt; \u0026#34;sub thread finished!\u0026#34; \u0026lt;\u0026lt; std::endl; } 多线程另一个需要注意的问题就是死锁。死锁的前提是有两个锁\n线程1得到了锁a，还想得锁b 线程2得到了锁b，还想得锁a 然后，再加上一个前提：某一时刻，只有一个线程能拥有某个锁，就不难得出以下结论：线程a，b除非某一个放弃已得的锁，不然两个线程都会因为没得到需要的锁而一直死等，形成死锁。同时解决死锁的思路也呼之欲出：既然一个得了a，一个得了b，而锁同一时间只能被一个线程得到，那么所有线程都按先得a，再得b的顺序来就不会有锁被占用的问题了。另一个思路则可以从放弃上入手，既然都得不到，那么接下来的任务也做不了，不如直接放弃已经得到的，所以可以考虑使用timed_mutex。\n其他 #还有很多常用的库，如字符串string，时间chrono，还有在定义函数变量时常用的functional,异常exception，更多的内容可以在cplusplus找的参考。\n总结 #总的来说，标准库提供了一个展现C++语言能力的平台：帮助开发者更好更快完成开发任务的同时，还能启迪开发者实现更好的抽象和实践。如我就从标准库中学到了更规范地定义函数参数，更好的封装，以及其他好的思路。学习标准库不仅更好地掌握了语言本身，还掌握了更全面地分析问题，解决问题的方法，是值得花费一段时间学习的。 容器类是几乎所有项目都会用到的，也是比较好掌握的，主要可以从数据结构方面对照学习；智能指针则是处理指针问题的好帮手；线程相关的库是比较难掌握的，关键是要想明白使用场景和极端情况下的边界问题。很多时候边界问题可能不那么直观。如线程要求获得锁的情况就分为：锁空闲，锁被其他线程占有，锁被自己占有。不同的边界对于不同的锁，预期结果也是不同的，只有在明确场景的情况下，才能更好地理清锁的关系，从而解决好问题。 最好的学习还是在实践中主动使用。对于我，通常在遇到新问题的时候会先查查标准库有没有相应的库，有的话就是学习这个库的好时机。可以先概览库的定义和解决的问题，然后分析它提供的类，函数，对象等，再将自己的理解转换为项目中的代码，最后在实际效果中检验和修正想法，完成库的学习。\n","date":"20 July 2022","permalink":"/post/%E7%8E%B0%E4%BB%A3C++%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97-%E6%A0%87%E5%87%86%E5%BA%93.html","section":"Posts","summary":"\u003cblockquote\u003e\n\u003cp\u003e在[上一章](\u003ca href=\"https://www.yuque.com/docs/share/adb5b1e4-f3c6-46fd-ba4b-4dabce9b4f2a?#\" target=\"_blank\" rel=\"noreferrer\"\u003ehttps://www.yuque.com/docs/share/adb5b1e4-f3c6-46fd-ba4b-4dabce9b4f2a?#\u003c/a\u003e 《现代C++学习指南-类型系统》)我们探讨了C++的类型系统，并提出了从低到高，又从高到低的学习思路，本文就是一篇从高到低的学习指南，希望能提供一种新的视角。\u003c/p\u003e\n\u003c/blockquote\u003e","title":"现代C++学习指南-标准库"},{"content":" 在前一篇，我们提供了一个方向性的指南，但是学什么，怎么学却没有详细展开。本篇将在前文的基础上，着重介绍下怎样学习C++的类型系统。\n写在前面 #在进入类型系统之前，我们应该先达成一项共识——尽可能使用C++的现代语法。众所周知，出于兼容性的考虑，C++中很多语法都是合法的。但是随着新版本的推出，有些语法可能是不推荐或者是需要避免使用的。所以本篇也尽可能采用推荐的语法形式（基于C++11或以上版本），这也是现代C++标题的含义。\n采用现代语法有两点好处。其一，现代语法可以编译出更快更健壮的代码。编译器也是随着语言的发展而发展的，现代语法可以在一定程度上帮助编译器做更好的优化。其二，现代语法通常更简洁，更直观，也更统一，有助于增强可读性和可维护性。 明确了这点后，让我们一起踏入现代C++的大门吧。\n类型系统 #程序是一种计算工具，根据输入，和预定义的计算方法，产生计算结果。当程序运行起来后，这三者都需要在内存中表示成合适的值才能让程序正常工作，负责解释的这套工具就是类型系统。数字，字符串，键盘鼠标事件等都是数据，而且在内存中实际存在的形式也是一样的，但是按我们人类的眼光来看的话，对它们的处理是不一样的。数字能进行加减乘除等算术运算，但是对字符串进行算术运算就没有意义，而键盘鼠标的值通常只是读取，不进行计算的。正是由于这些差异，编程语言的第一个任务就是需要定义一套类型系统，告诉计算机怎样处理内存中的数据。 为了让编程语言尽可能简单，编程语言一般把类型系统分为两步实现，一部分是编译器，另一部分是类型。编译器那部分负责将开发者的代码解释成合适的形式，以便可以高效，准确在内存中表示。类型部分则定义一些编译器能处理的类型，以便开发者可以找到合适的数据来完成输入输出的表示和计算方法的描述。这两者相辅相成，相互成就。 类型作为类型系统的重要表现形式，在编程语言中的重要性也就不言而喻了。如果把写程序看成是搭积木的话，那么程序的积木就是类型系统。类型系统是开发者能操作的最小单位，它限制了开发者的操作规则，但是提供了无限的可能。C++有着比积木更灵活的类型系统。\n类型 #:::info 类型是编程语言的最小单位，任何一句代码都是一种内存使用形式。 ::: 而谈到C++的类型也就不得不谈到它的三种类型表现形式——普通类型，指针，引用。它们是三种不同的内存使用和解释形式，也是C++的最基础的形式。和大部分编程语言不同，C++对内置类型没有做特权处理，只要开发者愿意，所有的类型都可以有一致的语法形式（通过运算符重载），所以下面关于类型的举例适合所有的类型。 普通类型就是没有修饰的类型，如int,long,double等。它们是按值传递的，也就是赋值和函数传参是拷贝一份值，对拷贝后的值进行操作，不会再影响到老值。\nint a=1; //老值,存在地址1 int b=a; //新值，存在地址2 b=2; //改变新值，改变地址2 //此时a还是1，b变成了2 那假如我们需要修改老值呢，有两种途径，一种是指针，另一种则是引用。 指针是C/C++里面的魔法，一切皆可指针。指针包含两个方面，一方面它是指一块内存，另一方面它可以指允许对这块内存进行的操作。指针的值是一块内存地址，操作指针，操作的是它指向的那块地址。\nint a=1; //老值,存在地址1 int* b=\u0026amp;a; //\u0026amp;代表取地址，从右往左读，取a的地址——地址1，存在地址2 *b=2; //*是解引用，意思是把存在地址2(b)的值取出来，并把那个地址（地址1）的值改成2 //此时a，*b变成了2 引用则是指针的改进版，引用能避免无效引用，不过引用不能重设，比指针缺少一定的灵活性。\nint a=1; //老值,存在地址1 int\u0026amp; b=a; //\u0026amp;出现在变量声明的位置，代表该变量是引用变量，引用变量必须在声明时初始化 b=2; //可以像普通变量一样操作引用变量，同时，对它的操作也会反应到原始对象上 //此时a，b变成了2 变量定义 #类型仅仅是一种语法定义，而要真正使用这种定义，我们需要用类型来定义变量，即变量定义。 C++变量定义是以下形式：\ntype name[{initial_value}] 这里的关键在于type。type是类型和限定符的组合。看下面的例子：\nint a; //普通整型 int* b; //类型是int和*的组合，组成了整型指针 const int* c; //从右往左读，*是指针，const int是常量整型，组成了指向常量整型的指针类型 int *const d; //也是从右往左读，const是常量，后面是指针，说明这个指针是常量指针，指向最左边的int，组成常量指针指向整型 int\u0026amp; e=a; //类型是int和\u0026amp;的组合，组成了整型引用 constexpr int f=a+e; //constexpr代表这个变量需要在编译期求值，并且不再可变。 以上，基本就是变量定义的所有形式了，类型确定了变量的基本属性，而限定符限定了变量的使用范围。 定义变量也是按照这个步骤进行，首先确定我们需要什么类型的变量，其次再进一步确定是否需要对这个变量添加限定，很多时候是需要的。可以按以下步骤来确定添加什么样的限定符：\n是个大对象，可以考虑把变量声明成引用类型。通常引用类型是比指针类型更优的选择。 大对象可能需要被重置，可以考虑声明为指针。 只想要个常量，添加constexpr。 只想读这个变量，添加const。 变量初始化 #变量定义往往伴随着初始化，这对于局部变量来说很重要，因为局部变量的初值是不确定的，在没有对变量进行有效初始化前就使用变量，会导致不可控的问题。所以严格来说，前面的变量定义是不完全正确的。 C++11推出了全新的，统一的初始化方式，即在变量名后面跟着大括号，大括号里包着初始化的值。这种方式可以用在任何变量上，称之为统一初始化，如：\nint a{9527}; //普通类型 string b={\u0026#34;abc\u0026#34;}; //另一种写法，等价但是不推荐 Student c{\u0026#34;张三\u0026#34;,\u0026#34;20220226\u0026#34;,18}; //大括号中是构造函数参数 当然，除了用类型名来定义变量外，还可以将定义和初始化合二为一，变成下面这种最简洁的形式：\nauto a={1}; //推导为整型 auto b=string{\u0026#34;abc\u0026#34;}; auto c=Student{\u0026#34;张三\u0026#34;,\u0026#34;20220226\u0026#34;,18} 这里auto是让编译器自己确定类型的意思。上面这种写法是完全利用了C++的类型推导，这也是好多现代语言推荐的形式。不过需要注意的是，使用类型推导后，=就不能省略了。 有了初始化的变量后，我们就可以用它们完成各种计算任务了。C++为开发者实现了很多内置的计算支持。如数字的加减乘除运算，数组的索引，指针的操作等。还提供了分支if，switch，循环while，for等语句，为我们提供了更灵活的操作。\n函数 #变量是编程语言中的最小单位，随着业务的复杂度增加，有些时候中间计算会分散业务的逻辑，增加复杂度。为了更好地组织代码，类型系统增加了 函数来解决这个问题。 函数也是类型，是一种复合类型。它的类型由参数列表，返回值组合而成，也就是说两个函数，假如参数列表和返回值一样，那么它们从编译器的角度来看是等价的。当然光有它们还不够，不然怎么能出现两个参数列表和返回值一样的函数呢。一个完整的函数还需要有个函数体和函数名。所以函数一般是下面这种形式：\n//常规函数形式 [constexpr] 返回值 函数名(参数列表)[noexcept]{ 函数体 } //返回值后置形式 auto 函数名(参数列表)-\u0026gt;返回值 当一个函数没有函数体的时候，我们通常称之为函数声明。加上函数体就是一个函数定义。\nvoid f(int); //函数声明 void fun(int value){ //函数定义，因为有大括号代表的函数体 } 以上就是函数的基本框架，接下来我们分别来看一看组成它的各部分。 先说最简单的函数名，它其实是函数这种类型的一个变量，这个变量的值表示从内存地址的某个位置开始的一段代码块。前面也说过之所以能出现两个参数列表和返回值都相同的函数，但是编译器能识别，其主要功劳就在函数名上，所以函数名也和变量名一样，是一种标识符。那假如反过来，函数名相同，但是参数列表或者返回值不同呢，这种情况有个专有名词——函数重载。基于函数是复合类型的认识，它们中只要其中一种不同就算重载。另外，在C++11，还有一种没有名字的函数，称为lambda表达式。lambda表达式是一种类似于直接量的函数值，就像13，\u0026lsquo;c\u0026rsquo;这种，是一种不提前定义函数，直接在调用处定义并使用的函数形式。 参数列表是前面类型定义的升级款。所有前面说的关于变量定义的都适用于它，三种形式的变量定义，多个变量，变量初始化等。不过，它们都有了新名词。参数列表的变量称为形式参数，初始化称为默认参数。同样形参在实际使用的时候需要初始化，不过初始化来自调用方。形式参数没有默认值就需要在调用的时候提供参数，有默认值的可以省略。\nint plus(int a,int b=1){ //b是一个默认参数 return a+b; } int main(void){ int c=plus(1); //没有提供b的值，所以b初始化为1，结果是2 int d=plus(2,2); //a,b都初始化为2，结果是4 //int f=plus(1,2,3); //plus只有两个形参，也就是两个变量，没法保存三个值，所以编译错误 return 0; } 和参数列表一样，返回值也是一个变量，这个变量会通过return语句返回给调用者，所以从内存操作来看，它是一个赋值操作。\nstd::string msg(){ std::string input; std::cin\u0026gt;\u0026gt;input; return input; } int main(void){ auto a=msg(); std::string b=msg();//msg返回的input复制到了b中 return 0; } 遗憾的是C++只支持单返回值，也就是一个函数调用最多只能返回一个值，假如有多个值就只能以形参形式返回了，这种方式对于函数调用就不是很友好，所以C++提出了新的解决思路。\n类 #随着业务的复杂度再次增加，函数形参个数可能会增加，或者可能需要返回多个值，然后在多个不同的函数间传递。这样会导致数据容易错乱，并且增加使用者的学习成本。 为了解决这些问题，工程师们提出了面向对象——多个数据打包的技术。表现在语言层面上，就是用类把一组操作和完成这组操作需要的数据打包在一起。数据作为类的属性，操作作为类的方法，使用者通过方法操作内部数据，数据不再需要使用者自己传递，管理。这对于开发者无疑是大大简化了操作。我们称之为面向对象编程，而在函数间传递数据的方式称为面向过程编程。这两种方式底层逻辑其实是一致的，该传递的参数和函数调用一样都不少，但是面向对象的区别是这些繁琐、容易出错的工作交给编译器来做，开发者只需要按照面向对象的规则做好设计工作就好了，剩下的交给编译器。至此，我们的类型系统又向上提升了一级。类不仅是多个类型的聚合体，还是多个函数的聚合体，是比函数更高级的抽象。 可以看下面面向过程编程和面向对象编程的代码对比\nstruct Computer{ bool booted; friend std::ostream\u0026amp; operator\u0026lt;\u0026lt;(std::ostream\u0026amp; os,const Computer \u0026amp; c){ os\u0026lt;\u0026lt;\u0026#34;Computing\u0026#34;; return os; } }; void boot(Computer\u0026amp; c){ c.booted=true; std::cout\u0026lt;\u0026lt;\u0026#34;Booting...\u0026#34;; } void compute(const Computer\u0026amp; c){ if(c.booted){ std::cout\u0026lt;\u0026lt;\u0026#34;Compute with \u0026#34;\u0026lt;\u0026lt;c; } } void shutdown(Computer\u0026amp; c){ c.booted=false; std::cout\u0026lt;\u0026lt;\u0026#34;Shutdown...\u0026#34;; } int main(void){ auto c=Computer(); boot(c); compute(c); shutdown(c); return 0; } 面向过程最主要的表现就是，开发者需要在函数间传递数据，并维护数据状态，上面例子中的数据是c。\nstruct Computer{ bool booted; friend std::ostream\u0026amp; operator\u0026lt;\u0026lt;(std::ostream\u0026amp; os,const Computer \u0026amp; c){ os\u0026lt;\u0026lt;\u0026#34;Computing\u0026#34;; return os; } void boot(){ booted=true; std::cout\u0026lt;\u0026lt;\u0026#34;Booting...\u0026#34;; } void compute(){ if(booted){ std::cout\u0026lt;\u0026lt;\u0026#34;Compute with \u0026#34;\u0026lt;\u0026lt;this; } } void shutdown(){ booted=false; std::cout\u0026lt;\u0026lt;\u0026#34;Shutdown...\u0026#34;; } }; int main(void){ auto c=Computer(); c.boot(); c.compute(); c.shutdown(); return 0; } 可以看出面向对象的代码最主要的变化是，方法的参数变少了，但是可以在方法里面直接访问到类定义的数据。另一个变化发生在调用端。调用端是用数据调用方法，而不是往方法里面传递数据。这也是面向对象的本质——以数据为中心。 当然，类的封装功能只是类功能的一小部分，后面我们会涉及到更多的类知识。作为初学者，我们了解到这一步就能读懂大部分代码了。\n总结 #类型系统是一门语言的基本构成部分，它支撑着整个系统的高级功能，很多高级特性都是在类型系统的基础上演化而来的。所以学习语言的类型系统有个从低到高，又从高到低的过程，从最基础的类型开始，学习如何从低级类型构筑出高级类型，然后站在高级类型的高度上，审视高级类型是怎样由低级类型构筑的。这一上一下，一高一低基本上就能把语言的大部分特性了解清楚了。 低级类型更偏向于让编译器更好地工作，高级类型偏向于让开发者更好地工作，C++从普通类型，函数，类提供了各个层级的支持，让开发者有更多自由的选择，当然也就增加了开发者的学习难度。但是开发者并不是都需要所有选择的，所以我觉得正确的学习应该是以项目规模为指导的。一些项目，完全用不到面向对象，就可以把精力放在打造好用的函数集上。而有的项目，面向对象是很好的选择，就需要在类上花费时间。回到开头的积木例子，选用什么积木完全看我们想搭什么模型，要是没有合适的积木，我们可以自己创造。这就是C++的迷人之处。\n","date":"26 June 2022","permalink":"/post/%E7%8E%B0%E4%BB%A3C++%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97-%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F.html","section":"Posts","summary":"在前一篇，我们提供了一个方向性的指南，但是学什么，怎么学却没有详细展开。本篇将在前文的基础上，着重介绍下怎样学习C++的类型系统。\n写在前面 #在进入类型系统之前，我们应该先达成一项共识——尽可能使用C++的现代语法。众所周知，出于兼容性的考虑，C++中很多语法都是合法的。但是随着新版本的推出，有些语法可能是不推荐或者是需要避免使用的。所以本篇也尽可能采用推荐的语法形式（基于C++11或以上版本），这也是现代C++标题的含义。\n采用现代语法有两点好处。其一，现代语法可以编译出更快更健壮的代码。编译器也是随着语言的发展而发展的，现代语法可以在一定程度上帮助编译器做更好的优化。其二，现代语法通常更简洁，更直观，也更统一，有助于增强可读性和可维护性。 明确了这点后，让我们一起踏入现代C++的大门吧。\n类型系统 #程序是一种计算工具，根据输入，和预定义的计算方法，产生计算结果。当程序运行起来后，这三者都需要在内存中表示成合适的值才能让程序正常工作，负责解释的这套工具就是类型系统。数字，字符串，键盘鼠标事件等都是数据，而且在内存中实际存在的形式也是一样的，但是按我们人类的眼光来看的话，对它们的处理是不一样的。数字能进行加减乘除等算术运算，但是对字符串进行算术运算就没有意义，而键盘鼠标的值通常只是读取，不进行计算的。正是由于这些差异，编程语言的第一个任务就是需要定义一套类型系统，告诉计算机怎样处理内存中的数据。 为了让编程语言尽可能简单，编程语言一般把类型系统分为两步实现，一部分是编译器，另一部分是类型。编译器那部分负责将开发者的代码解释成合适的形式，以便可以高效，准确在内存中表示。类型部分则定义一些编译器能处理的类型，以便开发者可以找到合适的数据来完成输入输出的表示和计算方法的描述。这两者相辅相成，相互成就。 类型作为类型系统的重要表现形式，在编程语言中的重要性也就不言而喻了。如果把写程序看成是搭积木的话，那么程序的积木就是类型系统。类型系统是开发者能操作的最小单位，它限制了开发者的操作规则，但是提供了无限的可能。C++有着比积木更灵活的类型系统。\n类型 #:::info 类型是编程语言的最小单位，任何一句代码都是一种内存使用形式。 ::: 而谈到C++的类型也就不得不谈到它的三种类型表现形式——普通类型，指针，引用。它们是三种不同的内存使用和解释形式，也是C++的最基础的形式。和大部分编程语言不同，C++对内置类型没有做特权处理，只要开发者愿意，所有的类型都可以有一致的语法形式（通过运算符重载），所以下面关于类型的举例适合所有的类型。 普通类型就是没有修饰的类型，如int,long,double等。它们是按值传递的，也就是赋值和函数传参是拷贝一份值，对拷贝后的值进行操作，不会再影响到老值。\nint a=1; //老值,存在地址1 int b=a; //新值，存在地址2 b=2; //改变新值，改变地址2 //此时a还是1，b变成了2 那假如我们需要修改老值呢，有两种途径，一种是指针，另一种则是引用。 指针是C/C++里面的魔法，一切皆可指针。指针包含两个方面，一方面它是指一块内存，另一方面它可以指允许对这块内存进行的操作。指针的值是一块内存地址，操作指针，操作的是它指向的那块地址。\nint a=1; //老值,存在地址1 int* b=\u0026amp;a; //\u0026amp;代表取地址，从右往左读，取a的地址——地址1，存在地址2 *b=2; //*是解引用，意思是把存在地址2(b)的值取出来，并把那个地址（地址1）的值改成2 //此时a，*b变成了2 引用则是指针的改进版，引用能避免无效引用，不过引用不能重设，比指针缺少一定的灵活性。\nint a=1; //老值,存在地址1 int\u0026amp; b=a; //\u0026amp;出现在变量声明的位置，代表该变量是引用变量，引用变量必须在声明时初始化 b=2; //可以像普通变量一样操作引用变量，同时，对它的操作也会反应到原始对象上 //此时a，b变成了2 变量定义 #类型仅仅是一种语法定义，而要真正使用这种定义，我们需要用类型来定义变量，即变量定义。 C++变量定义是以下形式：\ntype name[{initial_value}] 这里的关键在于type。type是类型和限定符的组合。看下面的例子：","title":"现代C++学习指南-类型系统"},{"content":"C++是一门有着四十年历史的语言，先后经历过四次版本大升级（诞生、98、11、17（20），14算小升级）。每次升级都是很多问题和解决方案的取舍。了解这些历史，能更好地帮助我们理清语言的发展脉络。所以接下来我将借它的发展历程，谈一谈我对它的理解，最后给出我认为比较合理的学习路线指南。\nC++0——诞生 #C++诞生的目的是为了解决两个主要问题——性能和抽象。性能指的是拥有像C一样的底层访问能力和执行效率，抽象则意在语言层面提供对问题的描述能力和思考方法。这是C++的立命之本，也是C++经久不衰的原因。对于这两个目标，Bjarne Stroustrup想到的解决方法是充分利用现有的C的技术和工具，然后提供类来解决抽象问题。基于这个前提，我们就可以看出类是C++学习路上的第一个关卡。\nC++认为类是一种抽象思维，类的相关特性都是为抽象提供服务的。所以C++中的类比其他面向对象的类提供了更多的能力，所以也具有更多的复杂性。为了描述这种复杂性，就不得不提到C++的两个特点，静态类型安全，资源管理。\n静态类型安全可以帮助开发者定义出更合理合法的自定义类，如通过操作符重载，自定义类可以写出和基本类型一样的简洁代码。可以通过构造函数避免隐式类型转换而造成的运行时错误，也可以通过明确阻止某些操作阻止自己的类被滥用。所有的自主权都由开发者决定。所以假如我们是库的使用者，完全可以不用关心这些细节，我们只需要按照一般的语言一样写代码，遇到不合理的，编译器会直接告诉我们，不用担心这些问题会隐匿在程序运行时的某个时刻。\n资源管理则可以帮助开发者提供资源管理的指导和支撑。资源有很多种，而在计算机中的资源大部分都是有限的，必须有借有还，而且借和还必须一一对应，不然就是内存泄漏。在C时代，资源管理靠的是开发者对资源的全局掌控力，语言层面没有提供更好的支持。为了更好地支持资源管理，C++提出了构造函数和析构函数，两者分别可以对应资源的获取和回收。但是很多时候资源不仅仅供自己使用，还需要提供给外部使用。为了配合这种资源的转移，C++又提供了移动和复制两种操作来支持。\n综上，总结一下，C++的类提供了很多特性，但是不是所有的特性都是开发者需要的。开发者在定义类的时候需要考虑的主要问题是，对这个类提供哪些支持，然后再在这些提供的功能中选择合适的语法特性来实现。构造函数和析构函数可以提供很好的一一对应的操作，移动和复制则提供了资源在对象中怎么共享，操作符重载则可以让类使用更加简洁和优雅。\nC++98——标准化 #C++98最大的升级是模板和异常，并且搭配了好用的标准库。\n模板在C++中的地位怎么强调都不为过。它属于另一种抽象机制。所以它解决的也是抽象问题。C++中的类解决的是相似概念的抽象，更注重概念间的相似性。而模板解决的是通用问题的抽象，更注重概念的通用性。两者共同构成了C++的两大抽象基石。前面已经谈过了类，这里我们着重说一下模板。\n得益于C++强大的静态类型安全，模板编写起来也很简单，普通的函数怎么写，它就可以怎么写，无非就是把特定类型换成泛型。但是，另一方面，模板还可以做得更多。模板可以支持多种参数，多个参数，限定参数，并且是类型安全的。更厉害的是，它还可以指定值。合理地配合使用类型和值，基本上就能解决大部分问题了。\n说起异常。对于普通开发者没有多大吸引力。因为异常主要解决的问题是怎样告诉调用者发生错误了，是什么错误，并将执行能力转移到调用者一方。而我们大部分时间开发的都是业务代码，我们知道发生了什么，该怎样解决，大部分情况下是不太需要异常的。当然，并非说异常一无是处，异常对库开发者来说异常重要。对于库开发者来说，他需要在异常发生后，告诉调用者发生了错误，操作没有办法顺利执行。但是很多时候，库开发者并不知道调用者该怎样处理这个错误，是忽略呢，还是清理现场。异常机制提供了抛异常和异常捕获两种方式来支持库开发者和使用者。\n对于新手来说，可能不太喜欢标准库，而倾向于自己写。这不是个好主意。标准库是经过工业级测试的代码，可以在绝大部分情况下正常工作，而自己手写虽然成就感更好，但是更可能携带BUG。早期的标准库提供的功能有限，只有string，输入输出流，位运算，三大容器，和一些小算法。不过，这些都足够我们日常使用了，尤其是现在标准库功能越来越完善了，大部分编程场景都能找到合适的工具来完成，完全可以放弃手写特定代码了。\nC++98更多着眼于标准化，模板是一种标准，标准库也是一种标准。自此，C++的三座大山算是构筑完成了，类，模板，标准库。每一项都为C++带来了无限可能和旺盛生命力。\nC++11——全新语言 #C++11的改动是革命性的，但是还保留着难以置信的兼容性，是非常不容易的。这里我们不细谈具体的特性和细节，只从大方向上来个笼统的概述。\n首先直观的变化是在类型系统上，C++11将类型系统做了尽可能的规范化和统一化。\n通过同意初始化规范了对象的初始化形式； 通过auto简化了类型声明的形式； 通过nullptr规范化了空指针的形式； 通过enum class提供了静态类型安全的枚举； 通过别名简化了类型书写的方式； 还有其他更多更多 类型系统的改进意味着开发者可以写出更简洁，更规范，也更安全的代码，但是对编译器的挑战却是巨大的，所以，很长时间内，C++11都没有得到很好的支持，同时也妨碍了C++的发展。\n除了类型系统，另一项大改进就是提供了对线程的支持。C++11的标准库中提供了线程，条件对象，锁等线程相关的工具，这对库开发者来说是革命性的。在几乎不损失性能的情况下，提供了跨平台的线程支持，这极大地提高了库的稳定性和性能，也节省了很多平台测试时间，不得不说是顶呱呱。\n另一个重要升级就是资源管理了。标准库提供了unique_ptr，shared_ptr来协助资源管理。同时为了更出色的性能，引入了右值引用和移动语义。右值引用和移动语义听起来很高端，实际上就是解决一个问题，避免大对象的反复销创建和销毁，转而使用代价更低的移动。根本思路就是两条，对于直接量提供了右值引用，以增加它的生存时间，使之可以像普通变量一样通过参数传递。而对于变量来说，提供了移动语义，将不再需要使用的对象管理的资源转移到另一个对想象中。同时增加了移动构造，复制构造方式来优化函数的返回值。可谓是榨干了计算机的每一寸内存。\nC++11无疑是C++里程碑式的更新，在对历史遗留问题清理的同时，引领了接下来C++的发展方向，它的作用是承上启下的。对类型系统的改进无疑弥补了最开始从C继承来的一些缺陷。同时也充分考虑了现代计算机的发展，引入了线程支持。在内存管理上也是更上一层楼，引入了智能指针，移动语义，右值引用。它基本上抛开了历史束缚，但依旧是不忘使命，依旧是奔着更好的静态类型支持，更多的自主性，更高效的资源管理，更克制的特性支持来展开的。\nC++17，20——新生 #C++17和C++20应该是相辅相成的，绝大部分特性都已经得到支持和完善了。但是由于编译器的限制，我用的特性比较少。C++17比较期待的是跨平台的文件系统支持，这对于大部分应用开发者来说无疑是激动和喜悦的。另一个我喜欢的特性是结构化绑定，这个特性我在Python里面用得很顺手，当然现在基本上所有现代语言都支持它了。\n而对于C++20就用得更少了，更多的是示例性质的。我比较在意的是模块和协程，但是由于了解得不深入，就不详谈了。\n什么是C++的基本面 #从前几个章节不难看出，我着重夸了C++的类，模板，标准库，类型系统。这些都是我觉得学习C++比较重要的方面。但对于初学者来说，我觉得类型系统和标准库就足够了。\n类型系统是一门语言最小的单元了，在C++中它包括类型声明，对象初始化，函数传参，函数返回值。在学习初期学多少特性都是骗人的，实际上手还是需要从这个最小的单元入手。比如声明一个变量，这个变量该是什么类型的，可以是指针吗，可以是引用吗。定义函数的时候，参数列表该怎样确定，返回值是什么，怎样才能让函数传参高效，怎样阻止和避免无用的参数检查，返回值该是什么类型，等等，这些都是在实际项目中需要直接面对的问题。所以对类型系统的学习，是写出高效可用代码的第一步，也是最重要的一步。考虑的问题越深入、全面，得到的回报就越大。\n标准库则是提供了很好的算法支持和容器支持，可以帮助我们写更健壮的代码。对标准库接口的学习，一方面可以促进对类型系统的认识，另一方面也是积累好习惯的地方。\n有了这两项技能的支持，我觉得已经能够写出很棒的应用程序了。但是对于库设计者来说，写出很好的库还需要对类和模板有着更深刻的理解。\n一个定义良好的类需要对对象的生命周期进行严格的控制，构造，转移，销毁都是需要控制的。对于需要支持的操作，类设计者应该提供尽可能便捷和高效的支持，对于类禁止的操作，类设计者应该明确禁止，防止发生误用或者隐藏BUG。所以对于类，着重需要关注的是资源的构造，以及在多个对象间的传递和共享。容易发生问题的地方在于函数传参和返回值上，特别是层层调用的函数上，高效和安全就是必须要考虑的了，所以这就回到了前面提到的类型系统，只有对它有了比较深入的了解，才能设计出比较好的类。\n模板则是类的另一方面，它和类的概念虽然是不同的，但是思路上却是相通的。模板和Java里面的泛型相似，却更加灵活和重要，是和类一样的高度。模板需要考虑的问题是，提供什么算法，什么对象可以使用这个算法，怎样避免和阻止错误对象的滥用，在使用过程中怎样尽可能利用编译错误来避免运行时错误。所以它是比类更进一步的抽象概念，对开发者有着比类更高的要求。\nC++学习路线图 #从上一章节，可以看出我推荐的学习路线是类型系统，到标准库，到类，最后才到模板。其他的语言细节不是说不重要，而是在学习这四大板块的同时会融入到学习过程中，没必要单独去学习和理解，毕竟细节是繁杂而且散乱的，不会增加对语言的掌握，却会打乱学习节奏，分散注意力。\n类型系统的学习又可以按以下步骤进行\n变量声明（常量和编译时常量） 初始化（统一初始化，赋值） 函数定义，函数参数定义，返回值（引用，指针的使用） 简单类定义，不涉及到内存管理，资源管理 标准库可以按以下步骤进行\n智能指针（shared_ptr,unique_ptr等） 字符串 容器类对象（list,map等）。 标准输入输出使用 线程库使用 通用算法（sort，find等） 类可以按以下步骤进行\n类的构造函数，移动构造，复制构造 类的运算符重载 继承 虚函数 多继承 模板可以按以下步骤进行\n模板函数 模板类 模板递归 模板特化 总结 #C++细节繁多，初学者容易一头扎进语法细节而不自知，最终白白浪费了大把时间不算，还严重打击了学习积极性。本篇的主旨是在帮初学者理清这门语言的主要脉络，并提供我认为比较科学的学习路线，希望对初学者有所帮助。\nC++语言是一门通用型语言，有着很长的发展历史。这导致了它有着不小的历史包袱，所以在引入语言特性和怎样引入的事情上一直保持着克制。但是为了更好地服务于现代硬件和简化开发者工作，又不得不引入新特性，遗弃一些老特性。基于这种原因，语言表现出了一定的复杂性和杂乱性。但是它的核心方向是明确的，就是为了更好地解决效率和抽象问题。抓住这两个核心，再结合这份指南，先难后易，抓大放小，再加上一点归纳和总结就能很好地掌握这门语言的大部分内容。对于指南外的特性，在实际项目中需要了再学习完全是来得及的，毕竟大部分时间我们用到的特性也是很少的一部分，应该把精力花在性价比最高的部分。\n","date":"25 June 2022","permalink":"/post/%E7%8E%B0%E4%BB%A3C++%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97-%E6%96%B9%E5%90%91%E7%AF%87.html","section":"Posts","summary":"\u003cp\u003eC++是一门有着四十年历史的语言，先后经历过四次版本大升级（诞生、98、11、17（20），14算小升级）。每次升级都是很多问题和解决方案的取舍。了解这些历史，能更好地帮助我们理清语言的发展脉络。所以接下来我将借它的发展历程，谈一谈我对它的理解，最后给出我认为比较合理的学习路线指南。\u003c/p\u003e","title":"现代C++学习指南-方向篇"},{"content":"在Android开发中,有时候出于安全，性能，代码共用的考虑，需要使用C/C++编写的库。虽然在现代化工具链的支持下，这个工作的难度已经大大降低，但是毕竟万事开头难，初学者往往还是会遇到很多不可预测的问题。本篇就是基于此背景下写的一份简陋指南，希望能对刚开始编写C/C++库的读者有所帮助。同时为了尽可能减少认知断层，本篇将试着从一个最简单的功能开始，逐步添加工具链，直到实现最终功能，真正做到知其然且之所以然。\n目标 #本篇的目标很简单，就是能在Android应用中调用到C/C++的函数——接收两个整型值，返回两者相加后的值，暂定这个函数为plus。\n从C++源文件开始 #为了从我们最熟悉的地方开始,我们先不用复杂工具,先从最原始的C++源文件开始.\n打开你喜欢的任何一个文本编辑器，VS Code，Notpad++，记事本都行，新建一个文本文件，并另存为math.cpp。接下来,就可以在这个文件中编写代码了.\n前面我们的目标已经说得很清楚,实现个plus函数，接收两个整型值，返回两者之和，所以它可能是下面这样\nint plus(int left,int right) { return left + right; } 我们的源文件就这样完成了，是不是很简单。\n但是仅仅有源文件是不够的，因为这个只是给人看的，机器看不懂。所以我们就需要第一个工具——编译器。编译器能帮我们把人看得懂的转化成机器也能看得懂的东西。\n编译器 #编译器是个复杂工程，但是都是服务于两个基本功能\n理解源文件的内容（人能看懂的）——检查出源文件中的语法错误 理解二进制的内容（机器能看懂的）——生成二进制的机器码。 基于这两个朴素的功能，编译器却是挠断了头。难点在于功能2。基于这个难点编译器分成了很多种，常见的像Windows平台的VS，Linux平台的G++,Apple的Clang。而对于Android来说，情况略有不同，前面这些编译器都是运行在特定系统上的，编译出来的程序通常也只能运行在对应的系统上。以我现在的机器为例，我现在是在Deepin上写的C++代码，但是我们的目标是让代码跑在Android手机上，是两个不同的平台。更悲观的是，目前为止，还没有一款可以在手机上运行的编译器。那我们是不是就不能在手机上运行C++代码了？当然不是，因为有交叉编译。\n交叉编译就是在一个平台上将代码生成另一个平台可执行对象的技术。它和普通编译最大的不同是在链接上。因为一般的链接直接可以去系统库找到合适的库文件，而交叉编译不行，因为当前的平台不是最终运行代码的平台。所以交叉编译还需要有目标平台的常用库。当然，这些Google都替我们准备好了，称为NDK。\nNDK #NDK全称是Native Development Kit，里面有很多工具，编译器，链接器，标准库，共享库。这些都是交叉编译必不可少的部分。为了理解方便，我们首先来看看它的文件结构。以我这台机器上的版本为例——/home/Andy/Android/Sdk/ndk/21.4.7075529（Windows上默认位置则是c:\\Users\\xxx\\AppData\\Local\\Android\\Sdk\\）。 NDK就保存在Sdk目录下，以ndk命名，并且使用版本号作为该版本的根目录，如示例中，我安装的NDK版本就是21.4.7075529。同时该示例还是ANDROID_NDK这个环境变量的值。也就是说，在确定环境变量前，我们需要先确定选用的NDK版本，并且路径的值取到版本号目录。\n了解了它的存储位置，接下来我们需要认识两个重要的目录\nbuild/cmake/，这个文件夹，稍后我们再展开。 toolchains/llvm/prebuild/linux-x86_64，最后的linux-x86_64根据平台不同，名称也不同，如Windows平台上就是以Windows开头，但是一般不会找错，因为这个路径下就一个文件夹，并且前面都是一样的。这里有我们心心念念的编译器，链接器，库，文件头等。如编译器就存在这个路径下的bin目录里，它们都是以clang和clang++结尾的，如aarch64-linux-android21-clang++ aarch64代表着这个编译器能生成用在arm64架构机器上的二进制文件，其他对应的还有armv7a，x86_64等。不同的平台要使用相匹配的编译器。它就是交叉编译中所说的目标平台。\nlinux代表我们执行编译这个操作发生在linux机器上，它就是交叉编译中所说的主机平台。\nandroid21这个显然就是目标系统版本了\nclang++代表它是个C++编译器，对应的C编译器是clang。\n可以看到，对于Android来说，不同的主机，不同的指令集，不同的Android版本，都对应着一个编译器。 了解了这么多，终于到激动人性的时刻啦，接下来，我们来编译一下前面的C++文件看看。\n编译 #通过aarch64-linux-android21-clang++ --help查看参数，会发现它有很多参数和选项，现在我们只想验证下我们的C++源文件有没有语法错误，所以就不管那些复杂的东西，直接一个aarch64-linux-android21-clang++ -c math.cpp执行编译。\n命令执行完后，假如一切顺利，就会在math.cpp相同目录下生成math.o对象文件，说明我们的源码没有语法错误，可进行到下一步的链接。\n不过，在此之前，先打断一下。通常我们的项目会包含很多源文件，引用一些第三方库，每次都用手工的形式编译，链接显然是低效且容易出错的。在工具已经很成熟的现在，我们应该尽量使用成熟的工具，将重心放在我们的业务逻辑上来，CMake就是这样的一个工具。\nCMake #CMake是个跨平台的项目构建工具。怎么理解呢？编写C++代码时，有时候需要引用其他目录的文件头，但是在编译阶段，编译器是不知道该去哪里查找文件头的，所以需要一种配置告诉编译器文件头的查找位置。再者，分布在不同目录的源码，需要根据一定的需求打包成不同的库。又或者，项目中引用了第三方库，需要在链接阶段告诉链接器从哪个位置查找库，种种这些都是需要配置的东西。\n而不同的系统，不同的IDE对于上述配置的支持是不尽相同的，如Windows上的Visual Studio就是需要在项目的属性里面配置。在开发者使用同样的工具时，问题还不是很大。但是一旦涉及到多平台，多IDE的情况，协同开发就会花费大把的时间在配置上。CMake就是为了解决这些问题应运而生的。\nCMake的配置信息都是写在名为CMakeLists.txt的文件中。如前面提到头文件引用，源码依赖，库依赖等等，只需要在CmakeLists.txt中写一次，就可以在Windows，MacOS，Linux平台上的主流IDE上无缝使用。如我在Windows的Visual Studio上创建了一个CMake的项目，配置好了依赖信息,传给同事。同事用MacOS开发，他可以在一点不修改的情况下，马上完成编译，打包，测试等工作。这就是CMake跨平台的威力——简洁，高效，灵活。\n使用CMake管理项目 #建CMake项目 #我们前面已经有了math.cpp，又有了CMake，现在就把他们结合一下。\n怎样建立一个CMake项目呢？一共分三步：\n建一个文件夹 示例中我们就建一个math的文件夹吧。\n在新建的文件夹里新建CMakeLists.txt文本文件。注意，这里的文件名不能变。\n在新建的CMakeLists.txt文件里配置项目信息。 最简单的CMake项目信息需要包括至少三个东西 1）、支持的最低CMake版本\ncmake_minimum_required(VERSION 3.18.1) 2）、项目名称\nproject(math) 3）、生成物——生成物可能是可执行文件，也可能是库。因为我们要生成Android上的库，所以这里是的生成物是库。\nadd_library(${PROJECT_NAME} SHARED math.cpp) 经过这三步，CMake项目就建成了。下一步我们来试试用CMake来编译项目。\n编译CMake项目 #在执行真正的编译前，CMake有个准备阶段，这个阶段CMake会收集必要的信息，然后生成满足条件的工程项目，然后才能执行编译。\n那么什么是必要的信息呢？CMake为了尽可能降低复杂性，会自己猜测收集一些信息。\n如我们在Windows上执行生成操作，CMake会默认目标平台就是Windows，默认生成VS的工程，所以在Windows上编译Windows上的库就几乎是零配置的。\n在math目录下新建一个build的目录，然后把工作目录切换到build目录。\ncd build cmake .. 在命令执行之后，就能在build目录下找到VS的工程，可以直接使用VS打开，无错误地完成编译。当然，更快的方法还是直接使用CMake编译.\n使用CMake编译\ncmake --build . 注意前面的..代表父目录，也就是CMakeLists.txt文件存在的math目录，而.则代表当前目录，即build这个目录。假如这两步都顺利执行了，我们就能在build目录下收获一个库文件。Windows平台上可能叫math.dll，而Linux平台上可能叫math.so，但是都是动态库，因为我们在CMakelists.txt文件里配置的就是动态库。\n从上面的流程来看，CMake的工作流程不复杂。但是我们使用的是默认配置，也就是最终生成的库只能用在编译的平台上。要使用CMake编译Android库，我们就需要在生成工程时，手动告诉CMake一些配置，而不是让CMake去猜。\nCMake的交叉编译 #配置参数从哪来 #虽然我们不知道完成交叉编译的最少配置是什么，但是我们可以猜一下。\n首先要完成源码的编译，编译器和链接器少不了，前面也知道了,Android平台上有专门的编译器和链接器，所以至少有个配置应该是告诉CMake用哪一个编译器和链接器。\n其次Android的系统版本和架构也是必不可少的，毕竟对于Android开发来说，这个对于Android应用都很重要。\n还能想到其他参数吗，好像想不到了。不过，好消息是，Google替我们想好了，那就是直接使用CMAKE——TOOLCHAIIIN_FILE。这个选项是CMake 提供的，使用的时候把配置文件路径设置为它的值就可以了，CMake会通过这个路径查找到目标文件，使用目标文件里面的配置代替它的自己靠猜的参数。而这个配置文件，就是刚才提到过的两个重要文件夹之一的build/camke,我们的配置文件就是该文件夹下面的android.toolchain.cmake。\nGoogle的CMake配置文件 #android.toolchain.cmake扮演了一个包装器的作用，它会利用提供给它的参数，和默认的配置，共同完成CMake的配置工作。其实这个文件还是个很好的CMake学习资料，可以学到很多CMake的技巧。现在，我们先不学CMake相关的，先来看看我们可用的参数有哪些。在文件的开头，Google就把可配置的参数都列举出来了\nANDROID_TOOLCHAIN ANDROID_ABI ANDROID_PLATFORM ANDROID_STL ANDROID_PIE ANDROID_CPP_FEATURES ANDROID_ALLOW_UNDEFINED_SYMBOLS ANDROID_ARM_MODE ANDROID_ARM_NEON ANDROID_DISABLE_FORMAT_STRING_CHECKS ANDROID_CCACHE 这些参数其实不是CMake的参数，在配置文件被执行的过程中，这些参数会被转换成真正的CMake参数。我们可以通过指定这些参数的值，让CMake完成不同的构建需求。假如都不指定，则会使用默认值，不同的NDK版本，默认值可能会不一样。\n我们来着重看看最关键的ANDROID_ABI和ANDROID_PLATFORM。前面这个是指当前构建的包运行的CPU指令集是哪一个，可选的值有arneabi-v7a，arn64-v8a，x86，x86_64，mips，mips64。后一个则是指构建包的Android版本。它的值有两种形式，一种就是直接android-[version]的形式[version]在使用时替换成具体的系统版本，如android-23，代表最低支持的系统版本是Android 23。另一种形式是字符串latest。这个值就如这个单词的意思一样，用最新的。\n那么我们怎么知道哪个参数可以取哪些值呢，有个简单方法：先在文件头确定要查看的参数，然后全局搜索，看set和if相关的语句就能确定它支持的参数形式了。\n使用配置文件完成交叉编译 #说了那么一大堆，回到最开始的例子上来。现在我们有了CMakelists.txt，还有了math.cpp，又找到了针对Android的配置文件android.toolchin.cmake。那么怎样才能把三者结合起来呢，这就不得不提到CMake的参数配置了。\n在前面，我们直接使用\ncmake .. 就完成了工程文件的生成配置，但是其实它是可以传递参数的。***CMake的参数都是以-D开头，用空白符分割的键值对。***而CMake缺省的参数都是以CMAKE为开头的，所以大部分情况下参数的形式都是-DCMAKE_XXX这种。如给CMake传递toolchain文件的形式就是\ncmake -DCMAKE_TOOLCHAIN_FILE=/home/Andy/Android/Sdk/ndk/21.4.7075529/build/cmake/android.toolchain.cmake 这个参数的意思就是告诉CMake，使用=后面指定的文件来配置CMake的参数。\n然而，完成交叉编译，我们还少一个选项——-G。这个选项是交叉编译必需的。因为交叉编译CMake不知道该生成什么形式的工程，所以需要使用这个选项指定生成工程的类型。一种是传统形式的Make工程，指定形式是\ncmake -G \u0026#34;Unix Makefiles\u0026#34; 可以看出，这种形式是基于Unix平台下的Make工程的，它使用make作为构建工具，所以指定这种形式以后，还需要指定make的路径，工程才能顺利完成编译。而另一种Google推荐的方式是Ninja，这种方式更简单，因为不需要单独指定Ninja的路径，它默认就随CMake安装在同一个目录下，所以可以减少一个传参。Ninja也是一种构建工具，但是专注速度，所以我们这一次就使用Ninja。它的指定方式是这样的\ncmake -GNinja 结合以上两个参数，就可以得到最终的编译命令\ncmake -GNinja -DCMAKE_TOOLCHAIN_FILE=/home/Andy/Android/Sdk/ndk/21.4.7075529/build/cmake/android.toolchain.cmake .. 生成工程后再执行编译\ncmake --build . 我们就得到了最终能运行在Android上的动态库了。用我这个NDK版本编译出来的动态库支持的Android版本是21,指令集是armeabi-v7a。当然根据前面的描述我们可以像前面传递toolchain文件一下传递期望的参数，如以最新版的Android版本构建x86的库，就可以这样写\ncmake -GNinja -DCMAKE_TOOLCHAIN_FILE=/home/Andy/Android/Sdk/ndk/21.4.7075529/build/cmake/android.toolchain.cmake -DANDROID_PLATFORM=latest -DANDROID_ABI=x86 .. 这就给我们个思路，假如有些第三方库没有提供编译指南，但是是用CMake管理的，我们就可以直接套用上面的公式来编译这个第三方库。\nJNI #前面在CMake的帮助下，我们已经得到了libmath.so动态库,但是这个库还是不能被Android应用直接使用，因为Android应用是用Java（Kotlin）语言开发的，而它们都是JVM语言，代码都是跑在JVM上的。要想使用这个库，还需要想办法让库加载到JVM中，然后才有可能访问得到。它碰巧的是，JVM还真有这个能力，它就是JNI。\nJNI基本思想 #JNI能提供Java到C/C++的双向访问，也就是可以在Java代码里访问C/C++的方法或者数据，反过来也一样支持，这过程中JVM功不可没。所以要理解JNI技术，需要我们以JVM的角度思考问题。\nJVM好比一个货物集散中心，无论是去哪个地方的货物都需要先来到这个集散中心，再通过它把货物分发到目的地。这里的货物就可以是Java方法或者C/C++函数。但是和普通的快递不一样的是，这里的货物不知道自己的目的地是哪里，需要集散中心自己去找。那么找的依据从哪里来呢，也就是怎样保证集散中心查找结果的唯一性呢，最简单的方法当然就是货物自己标识自己，并且保证它的唯一性。\n显然对于Java来说，这个问题很好解决。Java有着层层保证唯一性的机制。\n包名可以保证类名的唯一性； 类名可以保证同一包名下类的唯一性； 同一个类下可以用方法名保证唯一性； 方法发生重载的时候可以用参数类型和个数确定类的唯一性。 而对于C/C++来说，没有包名和类名，那么用方法名和方法参数可以确定唯一性吗？答案是可以，只要我们把包名和类名作为一种限定条件。\n而添加限定条件的方式有两种，一种就是简单粗暴，直接把包名类名作为函数名的一部分，这样JVM也不用看其他的东西，直接粗暴地将包名，类名，函数名和参数这些对应起来就能确定对端对应的方法了。这种方法叫做静态注册。其实这和Android里面的广播特别像：广播的静态注册就是直接粗暴地在AndroidManifest文件中写死了，不用在代码里配置，一写了就生效。对应于静态注册，肯定还有个动态注册的方法。动态注册就是用写代码的方式告诉JVM函数间的对应关系，而不是让它在函数调用时再去查找。显然这种方式的优势就是调用速度更快一点，毕竟我们只需要一次注册，就可以在后续调用中直接访问到对端，不再需要查找操作。但是同样和Android中广播的动态注册一样，动态注册要繁琐得多，而且动态注册还要注意把握好注册时机，不然容易造成调用失败。我们继续以前面的libmath.so为例讲解。\nJava使用本地库 #Java端访问C/C++函数很简单，一共分三步：\nJava调用System.loadLibrary()方法载入库\nSystem.loadlibrary(\u0026#34;math.so\u0026#34;); 这里有个值得注意的地方，CMake生成的动态库是libmath.so，但是这里只写了math.so，也就是说不需要传递lib这个前缀。这一步执行完后，JVM就知道有个plus函数了。\nJava声明一个和C++函数对应的native方法。这里对应指的是参数列表和返回值要保持一致，方法名则可以不一致。\npublic native int nativePlus(int left,int right); 通常，习惯将native方法添加native的前缀。\n在需要的地方直接调用这个native方法。调用方法和普通的Java方法是一致的，传递匹配的参数，用匹配的类型接收返回值。\n把这几步融合到一个类里面就是这样\npackage hongui.me; import android.os.Bundle; import androidx.annotation.Nullable; import androidx.appcompat.app.AppCompatActivity; import hongui.me.databinding.ActivityMainBinding; public class MainActivity extends AppCompatActivity { static { System.loadLibrary(\u0026#34;me\u0026#34;); } ActivityMainBinding binding; private native int nativePlus(int left,int right); @Override protected void onCreate(@Nullable Bundle savedInstanceState) { super.onCreate(savedInstanceState); binding = ActivityMainBinding.inflate(getLayoutInflater()); setContentView(binding.getRoot()); // Example of a call to a native method binding.sampleText.setText(\u0026#34;1 + 1 = \u0026#34;+nativePlus(1,1)); } } C/C++端引入JNI #JNI其实对于C/C++来说是一层适配层，在这一层主要做函数转换的工作，不做具体的功能实现，所以，通常来说我们会新建一个源文件，用来专门处理JNI层的问题，而JNI层最主要的问题当然就是前面提到的方法注册问题了。\n静态注册 #静态注册的基本思路就是根据现有的Java native方法写一个与之对应的C/C++函数签名，具体来说分四步。\n先写出和Java native函数一模一样的函数签名 int nativePlus(int left,int right) 在函数名前面添加包名和类名。因为包名在Java中是用.分割的，而C/C++中点通常是用作函数调用，为了避免编译错误，需要把.替换成_。 hongui_me_MainActivity_nativePlus(int left,int right) 转换函数参数。前面提到过所有的操作都是基于JVM的，在Java中，这些是自然而然的，但是在C/C++中就没有JVM环境，提供JVM 环境的形式就只能是添加参数。为了达到这个目的，任何JNI的函数都要在参数列表开头添加两个参数。而Java里面的最小环境是线程，所以第一个参数就是代表调用这个函数时，调用方的线程环境对象JNIEnv，这个对象是C/C++访问Java的唯一通道。第二个则是调用对象。因为Java中不能直接调用方法，需要通过类名或者某个类来调用方法，第二个参数就代表那个对象或者那个类，它的类型是jobjet。从第三个参数开始，参数列表就和Java端一一对应了，但是也只是对应，毕竟有些类型在C/C++端是没有的，这就是JNI中的类型系统了，对于我们当前的例子来说Java里面的int值对应着JNI里面的jint,所以后两个参数都是jint类型。这一步至关重要，任何一个参数转换失败都可能造成程序崩溃。 hongui_me_MainActivity_nativePlus( JNIEnv* env, jobject /* this */, jint left, jint right) 添加必要前缀。这一步会很容易被忽略，因为这一部分不是那么自然而然。首先我们的函数名还得加一个前缀Java,现在的函数名变成了这样Java_hongui_me_MainActivity_nativePlus。其次在返回值两头需要添加JNIEXPORT和JNICALL，这里返回值是jint，所以添加完这两个宏之后是这样JNIEXPORT jint JNICALL。最后还要在最开头添加extern \u0026quot;C\u0026quot; 的兼容指令。至于为啥要添加这一步，感兴趣的读者可以去详细了解，简单概括就是这是JNI的规范。 经过这四步，最终静态方法找函数的C/C++函数签名变成了这样\n#include \u0026#34;math.h\u0026#34; extern \u0026#34;C\u0026#34; JNIEXPORT jint JNICALL Java_hongui_me_MainActivity_nativePlus( JNIEnv* env, jobject /* this */, jint left, jint right){ return plus(left,right); } 注意到，这里我把前面的math.cpp改成了math.h，并在JNI适配文件（文件名是native_jni.cpp）中调用了这个函数。所以现在有两个源文件了，需要更新一下CMakeList.txt。\ncmake_minimum_required(VERSION 3.18。1) project(math) add_library(${PROJECT_NAME} SHARED native_jni.cpp) 可以看到这里我们只把最后一行的文件名改了，因为CMakeLists.txt当前所在的目录也是include的查找目录，所以不需要给它单独设置值，假如需要添加其他位置的头文件则可以使用include_directories(dir)添加。\n现在使用CMake重新编译，生成动态库，这次Java就能直接不报错运行了。\n动态注册 #前面提到过动态注册需要注意注册时机，那么什么算是好时机呢？在前面Java使用本地库这一节，我们知道，要想使用库，必须先载入，载入成功后就可以调用JNI方法了。那么动态注册必然要发生在载入之后，使用之前。JNI很人性化的想到了这一点，在库载入完成以后会马上调用jint JNI_OnLoad(JavaVM *vm, void *reserved)这个函数，这个方法还提供了一个关键的JavaVM对象，简直就是动态注册的最佳入口了。确定了注册时机，现在我们来实操一下。***注意：动态注册和静态注册都是C/C++端实现JNI函数的一种方式，同一个函数一般只采用一种注册方式。***所以，接下来的步骤是和静态注册平行的，并不是先后关系。\n动态注册分六步\n新建native_jni.cpp文件，添加JNI_OnLoad()函数的实现。 extern \u0026#34;C\u0026#34; JNIEXPORT jint JNICALL JNI_OnLoad(JavaVM *vm, void *reserved) { return JNI_VERSION_1_6; } 这就是这个函数的标准形式和实现，前面那一串都是JNI函数的标准形式，关键点在于函数名和参数以及返回值。要想这个函数在库载入后自动调用，函数名必须是这个，而且参数形式也不能变，并且用最后的返回值告诉JVM当前JNI的版本。也就是说，这些都是模板，直接搬就行。\n得到JNIEnv对象 前面提到过，所有的JNI相关的操作都是通过JNIEnv对象完成的，但是现在我们只有个JavaVM对象，显然秘诀就在JavaVM身上。 通过它的GetEnv方法就可以得到JNIEnv对象\nJNIEnv *env = nullptr; vm-\u0026gt;GetEnv(env, JNI_VERSION_1_6); 找到目标类 前面说过，动态注册和静态注册都是要有包名和类名最限定的，只是使用方式不一样而已。所以动态注册我们也还是要使用到包名和类名，不过这次的形式又不一样了。静态注册包名类名用_代替.，这一次要用/代替.。所以我们最终的类形式是hongui/me/MainActivity。这是一个字符串形式，怎样将它转换成JNI中的jclass类型呢，这就该第二步的JNIEnv出场了。\njclass cls=env-\u0026gt;FindClass(\u0026#34;hongui/me/MainActivity\u0026#34;); 这个cls对象就和Java里面那个MainActivity是一一对应的了。有了类对象下一步当然就是方法了。\n生成JNI函数对象数组。 因为动态注册可以同时注册一个类的多个方法，所以注册参数是数组形式的，而数组的类型是JNINativeMethod。这个类型的作用就是把Java端的native方法和JNI方法联系在一起，怎么做的呢，看它结构。\ntypedef struct { const char* name; const char* signature; void* fnPtr; } JNINativeMethod; name对应Java端那个native的方法名，所以这个值应该是nativePlus。 signature对应着这个native方法的参数列表外加函数类型的签名。 什么是签名呢，就是类型简写。在Java中有八大基本类型，还有方法，对象，类。数组等，这些东西都有一套对应的字符串形式，好比是一张哈希表，键是类型的字符串表示，值是对应的Java类型。如jint是真正的JNI类型，它的类型签名是I，也就是int的首字母大写。\n函数也有自己的类型签名(paramType)returnType这里的paramType和returnType都需要是JNI类型签名，类型间不需要任何分隔符。\n综上，nativePlus的类型签名是(II)I。两个整型参数，返回另一个整型。\nfnPtr正如它名字一样，它是一个函数指针，值就是我们真正的nativePlus实现了（这里我们还没有实现，所以先假定是jni_plus）。 综上，最终函数对象数组应该是下面这样\nJNINativeMethod methods[] = { {\u0026#34;nativePlus\u0026#34;,\u0026#34;(II)I\u0026#34;,reinterpret_cast\u0026lt;void *\u0026gt;(jni_plus)} }; 注册 现在有了代表类的jclass对象，还有了代表方法的JNINativeMethod数组，还有JNIEnv对象，把它们结合起来就可以完成注册了\nenv-\u0026gt;RegisterNatives(cls,methods,sizeof(methods)/sizeof(methods[0])); 这里第三个参数是代表方法的个数，我们使用了sizeof操作法得出了所有的methods的大小，再用sizeof得出第一个元素的大小，就可以得到methods的个数。当然，这里直接手动填入1也是可以的。\n实现JNI函数 在第4步，我们用了个jni_plus来代表nativePlus的本地实现，但是这个函数实际上还没有创建，我们需要在源文件中定义。现在这个函数名就可以随便起了，不用像静态注册那样那么长还不能随便命名，只要保持最终的函数名和注册时用的那个名字一致就可以了。但是这里还是要加上extern \u0026quot;C\u0026quot;的前缀，避免编译器对函数名进行特殊处理。参数列表和静态注册完全一致。所以，我们最终的函数实现如下。\n#include \u0026#34;math.h\u0026#34; extern \u0026#34;C\u0026#34; jint jni_plus( JNIEnv* env, jobject /* this */, jint left, jint right){ return plus(left,right); } 好了，动态注册的实现形式也完成了，CMake编译后你会发现结果和静态注册完全一致。所以这两种注册方式完全取决于个人喜好和需求，当需要频繁调用native方法时，我觉得动态注册是有优势的，但是假如调用次数很少，完全可以直接用静态注册，查找消耗完全可以忽略不记。\nOne more thing #前面我提到CMake是管理C/C++项目的高手，但是对于Android开发来说，Gradle才是YYDS。这一点Google也意识到了，所以gradle的插件上直接提供了CMake和Gradle无缝衔接的丝滑配置。在android这个构建块下，可以直接配置CMakeLists.txt的路径和版本信息。\nexternalNativeBuild { cmake { path file(\u0026#39;src/main/cpp/CMakeLists.txt\u0026#39;) version \u0026#39;3.20.5\u0026#39; } } 这样，后面无论是修改了C/C++代码，还是修改了Java代码，都可以直接点击运行，gradle会帮助我们编译好相应的库并拷贝到最终目录里，完全不再需要我们手动编译和拷贝库文件了。当然假如你对它的默认行为还不满意，还可以通过defaultConfig配置默认行为，它的大概配置可以是这样\nandroid { compileSdkVersion 29 defaultConfig { minSdkVersion 21 targetSdkVersion 29 testInstrumentationRunner \u0026#34;androidx.test.runner.AndroidJUnitRunner\u0026#34; consumerProguardFiles \u0026#39;consumer-rules.pro\u0026#39; externalNativeBuild { cmake { cppFlags += \u0026#34;-std=c++1z\u0026#34; arguments \u0026#39;-DANDROID_STL=c++_shared\u0026#39; abiFilters \u0026#39;armeabi-v7a\u0026#39;, \u0026#39;arm64-v8a\u0026#39; } } } } 这里cppFlags是指定C++相关参数的，对应的还有个cFlags用来指定C相关参数。arguments则是指定CMake的编译参数，最后一个就是我们熟悉的库最终要编译生成几个架构包了，我们这里只是生成两个。\n有了这些配置，Android Studio开发NDK完全就像开发Java一样，都有智能提示，都可以即时编译，即时运行，纵享丝滑。\n总结 #NDK开发其实应该分为两部分，C++开发和JNI开发。 C++开发和PC上的C++开发完全一致，可以使用标准库，可以引用第三方库，随着项目规模的扩大，引入了CMake来管理项目，这对于跨平台项目来说优势明显，还可以无缝衔接到Gradle中。 而JNI开发则更多的是关注C/C++端和Java端的对应关系，每一个Java端的native方法都要有一个对应的C/C++函数与之对应，JNI提供 静态注册和动态注册两种方式来完成这一工作，但其核心都是利用包名，类名，函数名，参数列表来确定唯一性。静态注册将包名，类名体现在函数名上，动态注册则是使用类对象，本地方法对象，JNIENV的注册方法来实现唯一性。 NDK则是后面的大BOSS，它提供编译器，链接器等工具完成交叉编译，还有一些系统自带的库，如log,z,opengl等等供我们直接使用。\n","date":"6 March 2022","permalink":"/post/Android-NDk%E5%BC%80%E5%8F%91%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5.html","section":"Posts","summary":"\u003cp\u003e在Android开发中,有时候出于安全，性能，代码共用的考虑，需要使用C/C++编写的库。虽然在现代化工具链的支持下，这个工作的难度已经大大降低，但是毕竟万事开头难，初学者往往还是会遇到很多不可预测的问题。本篇就是基于此背景下写的一份简陋指南，希望能对刚开始编写C/C++库的读者有所帮助。同时为了尽可能减少认知断层，本篇将试着从一个最简单的功能开始，逐步添加工具链，直到实现最终功能，真正做到知其然且之所以然。\u003c/p\u003e","title":"Android-NDK开发——基本概念"},{"content":"","date":null,"permalink":"/tags/jni/","section":"Tags","summary":"","title":"JNI"},{"content":"","date":null,"permalink":"/tags/ndk/","section":"Tags","summary":"","title":"NDK"},{"content":"","date":null,"permalink":"/categories/ndk/","section":"Categories","summary":"","title":"NDK"},{"content":"","date":null,"permalink":"/tags/linux/","section":"Tags","summary":"","title":"Linux"},{"content":"","date":null,"permalink":"/categories/linux/","section":"Categories","summary":"","title":"Linux"},{"content":"前言 #在项目初创阶段，经常会遇到各种文件操作，拷贝头文件，库，批量重命名等。文件结构一复杂，这就将是个无聊的工作。\n查找文件 #find可以在目录结构中搜索文件，这是它在man里面的作用描述。那么怎么搜索呢？有多种方式，按文件时间，大小，按文件名，路径名，按文件类型，权限，按用户。而这些方式又可以通过与或非的逻辑相互组合，完成更苛刻的查找工作，简直是文件查找的福音。 通常介绍一种命令都会以命令形式开始，find的格式如下\nfind [-H] [-L] [-P] [-D debugopts] [-Olevel] [starting-point...] [expression] [-H] [-L] [-P] [-D debugopts] [-Olevel]这一些统统不重要， [-H] [-L] [-P]是针对软连接的，不常用。[-D debugopts]是显示运行期间的额外信息，信息太乱太杂，用处不大。[-Olevel]则是用于优化查找的，默认的已经够用，所以也没必要深究。 find的最大魔法在最后的[expression],下面将以实例的形式讲解这个[expression]到底该怎么玩，原始的文件结构如下\n├── alice.h ├── andy │ ├── jack │ │ └── mary.h │ ├── mark.cpp │ ├── mark.h │ └── pony.txt ├── andy.c ├── bill.cpp ├── bill.h ├── mark.h └── mary 现在，我想找到以andy命名的文件，命令该怎么写呢。直觉告诉我们应该是\nfind andy 但是直觉对吗，我们来看输出\nandy andy/mark.cpp andy/jack andy/jack/mary.h andy/pony.txt andy/mark.h 它只找到了andy目录，甚至都没找到andy.c，那么看来我们需要一种方式告诉find，我们找的东西是文件，不是目录，这个选项就是-type。 -type后面需要紧跟一个参数，常用取值是d代表目录,f代表文件。现在我们需要找到文件，那么就应该加个-type f的选项。但这就够了吗？执行命令会发现报错了，因为后面的andy被认为是路径，而我们要找的是文件名啊。所以，这又需要另一个选项的帮忙，-name。-name后面可以跟具体的名字或者正则。结合这两个条件，我们得出了最终的命令\nfind -type f -name \u0026#34;andy*\u0026#34; 这里有两点值得注意，首先-type和-name其实是两个独立选项，可以单独使用，也可以联合使用，当联合使用时，他们之间不使用操作符（-o(Or)，-a(AND),-not）连接时，就会把-a单做连接符，也就是所有的条件都满足才回出现在最终的结果中。由此，可以延伸出一种反向的查找方法，\nfind -type f -not -name \u0026#34;andy*\u0026#34; 这个命令就会查找出所有不以andy开头的文件。\n./andy/mark.cpp ./andy/jack/mary.h ./andy/pony.txt ./andy/mark.h ./bill.h ./bill.cpp ./mark.h ./alice.h 另一个值得注意的点是\u0026quot;andy*\u0026quot;加了双引号，因为*是特殊字符，所以需要用双引号转椅一下，假如没有特殊字符是不需要添加双引号的。回到最初的命令，为啥第一条我们想当然的命令竟然没有找到我们期盼的目标呢？因为find是严格匹配的，我们只写了andy，而遗漏了后缀.c，这是最容易发生错误的地方。 其实，到这里，我们已经学习了这个命令的50%，那剩下的有什么内容呢？记得find的主要功能吗，里面提到了个目录结构。对的，find还可以控制查找范围。 新需求来了，怎样找到某个目录下所有的直接子.h文件呢？这里的直接和子合起来的意思是查找范围只能是当前目录，不能查找到当前目录的子目录。在解决这个问题前，我们需要知道一个前置知识——两个目录之间存在两种相互关系，兄弟或者父子。兄弟目录深度相同，父子目录深度相差1。知道了这点，再来看需求——.h文件很简单，使用-name \u0026quot;*.h\u0026quot;就能满足。但是，这样会找到andy目录下的.h文件，所以我们需要一种控制目录查找层级的东西，他们就是-mindepth，maxdepth。这两个参数和前面的不一样，他们属于Global options。什么是Global options呢，就是他们的作用是全局性的，并且它们总是返回true,也就是它们和其他的选项连起来一起查找的时候，只用考虑其他选项的条件。并且，为了凸显它们的全局性，它们在命令书写时，必须写在最前面，否则会触发警告。如下，就是写在了-name \u0026quot;*.h\u0026quot;前面。\nfind -maxdepth 1 -name \u0026#34;*.h\u0026#34; 这两个参数有点反直觉，可以这样理解——最多查找到哪里，有个最多，就是maxdepth,反过来就是从哪里才开始查找，才就是mindepth。\n聊完了目录结构，名字这些显眼的部分，文件还有访问（access）创建（create）、修改（modiffy）时间，权限（permission），大小（size）这些没有涉及到，而这些也同样可以作为find的查找条件，在开始之前，有一些小规则可以对这些选项做个快速分组——选项会以属性的英文首字母作为开始，如\n时间相关的选项有time和min，分别表示某个事件发生的前n天和n分钟，这里的某个事件可以用访问a（access）c创建（create）、m修改（modiffy）替代，它们组合起来就是一个完整的选项，如mmin n就表示查找修改时间在n分钟以内的文件。 以此类推，i代表大小写敏感，如iname,l代表link文件 当然，这些都可能用得不多，实际使用到再查可能还更方便点，但是有两个很好用的选项不得不讲。 考虑以下情况，某天老本发来一堆用户日志文件，让你给这些用户根据使用频次分级，你该怎么办呢？首先，我们可以把日志文件大小作为依据，根据最大最小划分好区间，如（0-100M)，然后用定好的级别(如5级）划分出每级区间（0-20，20-40，\u0026hellip;）,这样我们多次运行命令，就能得到所有的分级情况了。想法是美好的，但是find提供了这种选项了吗？它提供了-size n。我们来试着查找一下0-20区间的文件\nfind -size 20M 回车，你会发现结果貌似不完全正确，它可能确实找出了一些满足条件的文件，但是有一些满足的却没有找出，问题出现在哪里呢？原来-size n中的n是严格匹配，就是你输入的是20M，它就只找到恰好是20M的文件，而不是我们期望的20M和20M一下的文件。那么有解决方法吗，当然有，就是数字前面加上+，-号，+代表大于等于这个值，-代表小于。所以我们查找20M以下的文件的命令应该是\nfind -size -20M 解决了符号问题，还有单位问题值得注意，也就是-20M中的M。其实-size的标准形式是-size [+-]n[cwbkMG]。[+-]和n都说过了，后面的则单位。它们是以大小递增顺序排列的，说明如下\nc：字节 w：双字节，也就是word b：512字节构成的块，数字n后面没加单位的话，这个是默认值 k：1024个字节，也就是kb M：1024 * 1024个字节，也就是Mb c：1024 * 1024 * 1024个字节，也就是Gb 说完了单位的事，我们接着来出来20——40的分级，直接把20改为40吗？当然不，改为40找到的就是小于等于40M的文件了，所以我们需要一种区间标定法，find没有提供直接的选项支持，但是前面说过，选项是可以组合的，也就是我们可以重复使用-size来标识一个区间。也就是\nfind -size +20M -size -40M 按照这种方法，多次改变值，就可以完成任务啦。 其实上面的方案还有一点小纰漏，就是没有找出直接没用过的用户，也就是size为0的，那把数字改为0，可以吗？答案是可以，但是假如我们想找的是空目录，而不是空文件呢，-size就不能解决了，因为通常空目录的大小不为0.所以，find又提供了个检测文件是否为空的选项-empty，它不仅可以找到空文件，还可以找到空目录。在我们的实例中，使用 find -size 0找到的结果是\n./andy/mark.cpp ./andy/jack/mary.h ./andy/pony.txt ./andy/mark.h ./andy.c ./alice.h 没有找出空目录mary。而使用find -empty查找后，结果是\n./mary ./andy/mark.cpp ./andy/jack/mary.h ./andy/pony.txt ./andy/mark.h ./andy.c ./alice.h 不仅找到了mary空目录，其他的空文件也找出来了。 至此，find相关的东西已经了解得差不多了。但是，很多时候仅仅找到并不能完全满足我们的需求，我们可能需要把找到的文件复制到其他地方或者删除之类的，能否把这些操作合起来呢？这就要请我们的xargs登场了。\nxargs #xargs只有一个简单的功能，就是从标准输入读入内容，构建并执行命令。怎么理解呢？假设我们在执行find命令，find命令执行肯定是有过程，有逻辑的。按照一定的逻辑和过程，find对文件进行逐一评估，假如满足条件，就输出结果。随着命令的执行，结果可能越来越多。假如我们需要对产生的每个结果都执行一条命令呢，这该怎么办？按照一般的思路，当然是将结果保存起来，然后再写个脚本，读取每一条记录，然后执行相应。但是有了xargs，我们不用这么麻烦了，可以一步到位。我们利用管道符将结果从终端连接到xargs中，xargs接收到一条信息，就会将它作为构建命令的参数，就好像我们手动输入了命令那样，构建完成后还会自动执行。最终的结果就是，没产生一个输出，就会产生一条以这个输出为参数的命令，并且这条命令还自动执行，最终的效果就是实现了一条命令实现了多个功能。\n将find和xargs结合起来 #现在我们挑战升级了，有个需求，需要提取目录下的所有头文件到另一个目录。这个需求可以分为两部分，一部分是找到头文件，这可以用find命令完成。另一部分是复制找到的头文件，这就需要xargs的参与了。\n首先是找到头文件。头文件就是以.h结尾的文件（暂不考虑.hpp)，这个后缀是出现在名字里的，所以我们可以使用-name \u0026quot;*。h\u0026quot;选项,同时为了避免某些目录名的干扰，我们把类型也做个限定-type f，只查找文件。这第一步就完成了。 第二布就是复制文件啦。复制文件的标准写法是\ncp [OPTION]... SOURCE... DIRECTORY 根据这个命令格式，我们需要确定几个参数，源文件当然就是我们查找到的文件啦，这暂时按下不表。目标文件夹，就是我们拷贝到哪里，我们这里暂时就新建一个test的目录吧，目标文件夹就是test。这就结束了吗，还没有。头文件往往需要和他的父目录组成一个依赖路径，所以我们把所有的头文件直接一股脑都拷贝到test目录下是不可取的，这会打乱头文件的依赖关系，我们还得拷贝和头文件相关的父目录。恰巧的是，cp提供了这样的一个选项-parents——它可以拷贝源文件的完成文件名，也就是包含目录。所以问题的关键就来到了源文件这个参数上了。\n","date":"18 February 2022","permalink":"/post/Linux%E6%89%B9%E9%87%8F%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E2%80%94%E2%80%94%E5%9F%BA%E4%BA%8Efind,xargs.html","section":"Posts","summary":"前言 #在项目初创阶段，经常会遇到各种文件操作，拷贝头文件，库，批量重命名等。文件结构一复杂，这就将是个无聊的工作。\n查找文件 #find可以在目录结构中搜索文件，这是它在man里面的作用描述。那么怎么搜索呢？有多种方式，按文件时间，大小，按文件名，路径名，按文件类型，权限，按用户。而这些方式又可以通过与或非的逻辑相互组合，完成更苛刻的查找工作，简直是文件查找的福音。 通常介绍一种命令都会以命令形式开始，find的格式如下\nfind [-H] [-L] [-P] [-D debugopts] [-Olevel] [starting-point...] [expression] [-H] [-L] [-P] [-D debugopts] [-Olevel]这一些统统不重要， [-H] [-L] [-P]是针对软连接的，不常用。[-D debugopts]是显示运行期间的额外信息，信息太乱太杂，用处不大。[-Olevel]则是用于优化查找的，默认的已经够用，所以也没必要深究。 find的最大魔法在最后的[expression],下面将以实例的形式讲解这个[expression]到底该怎么玩，原始的文件结构如下\n├── alice.h ├── andy │ ├── jack │ │ └── mary.h │ ├── mark.cpp │ ├── mark.h │ └── pony.txt ├── andy.c ├── bill.cpp ├── bill.","title":"Linux批量文件操作——基于find,xargs"},{"content":"","date":null,"permalink":"/tags/shell/","section":"Tags","summary":"","title":"shell"},{"content":"","date":null,"permalink":"/tags/%E5%91%BD%E4%BB%A4%E8%A1%8C/","section":"Tags","summary":"","title":"命令行"},{"content":"","date":null,"permalink":"/tags/css/","section":"Tags","summary":"","title":"CSS"},{"content":"","date":null,"permalink":"/tags/%E5%89%8D%E7%AB%AF/","section":"Tags","summary":"","title":"前端"},{"content":"","date":null,"permalink":"/categories/%E5%89%8D%E7%AB%AF/","section":"Categories","summary":"","title":"前端"},{"content":"前言 #前不久，在我的一个项目中，需要展示一个横向滚动的标签页，它支持鼠标横向拖动和点击切换。在实现的过程中，我发现这个小功能需要同时用到前端的三辆马车，但是实现难度不高，而且最终效果还不错，是个难得的初学者项目，于是萌生了写这篇文章的想法，希望对初学者有所帮助。同时为了避免初学者学习框架，我打算用纯原生的方式实现它。\n我们最终的效果应该类似于下面： 需求分析 #需求分析就是细化我们需要完成的功能，某个功能的完成需要哪些技术的参与。对于初学者，需求分析至关重要，它可以帮助我们理清思路，找到解决问题的突破口，所以应该引起足够的重视。以本篇目标为例，标签页的需求分析就可以像下面这样：\n我们的展示主体是标签页，HTML就是实现主体的主要技术； 标签页需要可以拖动和点击，这涉及到鼠标事件的监听和处理，是JS的主场； 既然标签页可以拖动了，那是否要隐藏那个丑陋的滚动条，加个活动指示器，给鼠标变一个样式？很明显，这些都是CSS的优势。 如上，通过对展示，操作，样式的划分，我们进一步明确了HTML，JS，CSS需要完成的工作，甚至连实现都明朗了，所以对需求拆分得越详细，对实现就越有掌控力。\n基本框架 #对于前端来说，HTML始终是万物之源，所以一言不合先构筑个标准的HTML页面总是没错的。为了便于演示，我将所有的内容都放在一个HTML文件中，文件结构如下\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Tab演示\u0026lt;/title\u0026gt; \u0026lt;!-- 这里是样式区，后续css代码会添加到这里 --\u0026gt; \u0026lt;style type=\u0026#34;text/css\u0026#34;\u0026gt; \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;!-- 这里是页面区，后续HTML代码会添加到这里 --\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;!-- 这里是脚本区，后续JS代码会添加到这里,放在这里是因为方便写代码 --\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; \u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; 这里和以往不同，我将script放到了最后，这是因为我想在写脚本的时候，页面标签直接可用，减少对页面加载的监听，降低复杂性。\n实现基本功能 #有了基本结构，下一步当然是画页面啦。从效果图中不难看出，页面主要包括一个一个的选项卡，对于HTML来说，这不就是列表嘛。于是，突破口就出现了，我们先往HTML里面加入列表\n\u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;肖申克的救赎\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;霸王别姬\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;阿甘正传\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;泰坦尼克号\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;这个杀手不太冷\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;美丽人生\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;千与千寻\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;辛德勒的名单\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;盗梦空间\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;忠犬八公的故事\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; 于是，我们有了原始的标签页。但是标签页是竖向的，并且有着丑陋的小黑点，不符合需求。 发现了这些问题，下一步当然解决这些问题了，这当然就是CSS的强项啦。首要问题就是让列表横过来。横过来就是改变了元素的相对位置，也就是对应CSS的布局功能。那说起布局，CSS的布局方式有很多，像float,position等等。标签页是横向多个紧密排列的，一个挨着一个，这当然是用flex啦。至于讨厌的小黑点，这是新东西，需要百度一下。查阅文档发现，ul有个属性list-style-type，只需把它设置为none就可以去除小黑点。 此时，页面上的所有选项卡都紧密排列了。为了让它更像一个选项卡，需要给它居中，限制一下宽度，加个背景色，加点padding。下面就是改完样式的代码\nul{ display: flex; justify-content: center; align-content: center; list-style-type: none; background-color: #2397f3; width: 600px; overflow-x: scroll; } li{ padding: 16px; flex-shrink: 0; } 值得注意的地方有两点。在ul的样式中，由于给ul加了宽度限制，导致它的内容超出了内容区，所以要给ul加上overflow-x的属性。同样由于宽度的原因，flex子项在宽度不够的情况下会默认缩小，表现在标签上就是文字换行啦，flex-shrink: 0;就是让子项保留原有大小。此时，再来刷新页面，可以看到选项卡的基本雏形已经出来了。虽然简陋，但是可以拖动滚动条左右滚动了。下一步，我们的目标就是去除这个丑陋的滚动条。网上搜索一番，发现火狐，IE和Chrome的方式不尽相同，为了兼容性，我们就都给写上。\nul{ scrollbar-width: none; /* Firefox */ -ms-overflow-style: none; /* IE 10+ */ } ul::-webkit-scrollbar { display: none; /* Chrome Safari */ } 滚动条去除后，UI好看了，但是新问题出现了——选项卡滚动不了了。别着急，下一步就是添加鼠标拖动功能。\n实现交互 #在浏览器中，HTML标签有对系统事件的监听能力，响应这些事件，可以使页面实时响应用户的操作。通过对不同的事件的组合，可以实现各种丰富、有趣的功能，标签页也一样。\n标签页的首要功能是可以随着鼠标的拖动而滚动元素，那么，首要任务就是监听鼠标的移动事件啦。但是光监听移动还不行，因为通常来说，用户在鼠标左键按下后才希望真正拖动，鼠标左键抬起后结束拖动。所以，这个拖动动作其实需要组合鼠标按下（mousedown），移动（mousemove），抬起（mouseup）三个事件。那么这三个方法加在哪，怎么加呢？\n在Web API中，JS操作HTML的入口点是Document对象，Document提供了操作（增删改查）HTML元素的API。这一过程是有标准流程的。\n通过Document查找目标元素； 对目标元素进行元素，样式变更等操作； 变更完成； 这一过程是重复且繁杂的，为了减少编写这样的样板代码，加快开发速度，一大堆前端框架应运而生。所以，在学习前端框架时，牢记这一基本步骤，有助于快速理解框架的运行原理。毕竟无论框架怎么变，最终都是要落实到这一过程上。\n算法明确后，接下来就是具体实现。\n查找目标元素 #在查找目标前，需要首先明确目标是谁。用户肯定不希望在页面的其他地方拖动鼠标，标签页跟着滚动了，这很奇怪。所以我们的目标元素应该是无序列表。那么，怎样通过Document知道无序列表呢，查阅Document的API，发现它有个querySelector的方法，这个方法会从上到下查找满足条件的选择器，并返回第一个满足条件的元素，参数则是选择器的名称。上面已经明确过我们的目标是无序列表，所以查找目标元素的最终代码如下\nconst ul=document.querySelector(\u0026#39;ul\u0026#39;); 让列表滚起来 #每一个HTML元素，在JS中都是Element的对象。上一步我们已经得到了一个Element对象ul,注意，这里的ul对象和ul标签不尽相同。一个是JS的对象对HTML标签的表示，一个是HTML标签。现在有了一个对象，那么就可以通过调用合适的方法来操作这个对象了。通过查阅Element对象的API，发现它有个addEventListener()的方法，这个方法可以完成该对象表示的HTML标签对某些事件的监听。这个方法接收两个参数，第一个参数是事件名称，这在上一节已经说过。第二个参数则是对这个事件的处理，这也是我们实现魔法的地方。\n首先，在用户按下鼠标左键后，开始记录鼠标移动情况。在鼠标左键抬起后，停止记录。所以按下和抬起的主要功能就是维护记录开关，控制标签滚动的动作得在鼠标移动的回调里处理。\n但在真正写逻辑前，还有两个问题没有处理。 1、怎样让标签滚动？ 2、滚动的逻辑怎样写？ 问题一当然需要查阅Element的API啦。搜索滚动相关的，发现两个相关性比较大的方法——scrollBy()，scrollTo()，都可以滚动内容。唯一的区别是前者的参数是滚动的偏移，后者是最终值。由于鼠标移动是一点一点的，所以选择前者会更方便一点。确定了方法，也就解答了问题一。对于问题二，简单来说就是怎样提供问题一所需的参数。scrollBy()需要两个参数，横向和纵向的滚动偏移值，由于我们只希望标签页可以横向滚动，所以纵向的偏移始终是0，那么横向的呢？通常事件回调都会传递一个事件对象，称作MouseEvent，我们去查查事件对象的API，发现里面带有好几个关于坐标的属性——clientX，movementX，screenX。movementX直接就满足我们的需求，它代表上一次鼠标移动到这一次移动间的偏移，而刚好scrollBy()需要的参数就是偏移，妥了。 综上，得出以下代码\nconst ul=document.querySelector(\u0026#39;ul\u0026#39;); let isMouseDown=false; ul.addEventListener(\u0026#39;mousedown\u0026#39;,(e)=\u0026gt;{ isMouseDown=true; }) ul.addEventListener(\u0026#39;mousemove\u0026#39;,(e)=\u0026gt;{ if(isMouseDown){ ul.scrollBy(-e.movementX,0); } }) ul.addEventListener(\u0026#39;mouseup\u0026#39;,(e)=\u0026gt;{ isMouseDown=false; }) 可以看到，在mousemove的处理上，偏移加了个负号。因为在HTML页面中左上角为坐标原点，右边为X轴正方向。一直往右，则X坐标是增大的，而movementX的值是当前鼠标坐标与上一次坐标点的差值，上一次肯定比这一次小，两者的差值肯定是正值。基于同样的原因，scrollBy()参数正值代表增大X值，也就是显示右边的内容，隐藏左边的内容。两者结合的效果就是，鼠标往右拖，标签页右边隐藏的内容展示了出来，这和直觉相悖。通常我们希望鼠标往右拖，页面展示左边的内容，隐藏右边的。基于这样的分析，我们需要给movementX的值取反。\n显示当前选中的标签页 #现在，标签页可以滚动了，但是还不能选中。我希望点击某个标签时，标签下方出现一个小横条表示选中状态。很明显，显示小横条是一个CSS的问题，而点击标签切换小横条是JS的问题，这一次我们需要同时处理JS和CSS的问题。\n首先来显示小横条。显示小横条有两个思路，一种是在HTML中搞个div标签，另一种是使用::after伪元素。我选择后一种，这样可以保持HTML的干净。 接下来需要确定小横条的样式\n覆盖在选中的标签上 位置是标签底部 和标签一样长 我们知道正常的HTML文档流是从左到右，从上到下的，新加的元素会追加到已有元素的右边或者下边。小横条需要覆盖在标签上，那么就要改变这一默认行为，position属性就是实现这个功能的关键。absolute，fixed都可以脱离正常文档流，使元素覆盖在祖先元素上，不同的是前者是相对于最近的定位祖先，后者是相当于视口的。小横条是跟随着标签显示的，显然要使用前者。确定了位置，还有大小和样式。既然使用了绝对定位，那么bottom,left',right相应就能限定它的位置和大小了，小横条的样式就直接用border-bottom吧。于是，小横条的样式就出来了\n.current::after{ content: \u0026#34;\u0026#34;; position: absolute; border-bottom: 4px solid #FFC109; border-radius: 2px; bottom: 0; left: 0; right: 0; } 结束了吗，还没有！使用了绝对定位，必须时刻记得给绝对定位的元素找个锚点，也就是参照，不然top,left，right，bottom去参考谁呢？那么怎样告诉绝对定位的参照物呢，还是position属性。只不过这一次它要出现在参照物的CSS里面。而由前面的样式分析，小横条始终跟着标签页走，也就是说小横条的参照物就是标签页。所以，还要在标签页的样式上加上position的属性。当然，为了区分更明显，我还改变了一下颜色。\n.current{ color: white; position: relative; } 至此，小横条可以正常显示出来了。\n小横条跟随鼠标点击显示 #有了前面拖动功能的经验支持，这一次轻车熟路了，鼠标点击某个标签页，小横条显示在对应的标签页下方。这一次事件的对象变成了单个标签页，所以点击事件要加在单个标签页上。但是这一次标签页太多了，我们不能还是按照之前的查找-设置方法，这样太繁杂了。巧合的是，前面我们已经得到了ul对象了，通过它的children属性，可以得到所有的li，这不就妥了吗。 小横条要切换到不同的标签页上显示，也就是小横条这个样式要根据点击对象的不同而动态增加或者删除。查阅Element的API，发现有个className的属性，改变它的值就可以增减样式了。\nlet last=null; for(let l of ul.children){ l.addEventListener(\u0026#39;click\u0026#39;,(e)=\u0026gt;{ if(last){ last.className=\u0026#39;\u0026#39;; } e.target.className=\u0026#39;current\u0026#39;; last=e.target; }) } 代码的实现中，多了个last对象。因为通常标签页只能同时选中一个，当新的标签页被选中之后，上一个选中的标签页应该恢复原始样式，这就是last对象的作用。我们先取消选中上一个元素，然后再选中当前点击的对象，这样就完成了小横条跟随点击选中的效果了。\n总结 #总的来说，这个项目的难点不在于实现有多难，而是新。很多初学者，面对这种新问题往往束手无策，找不到切入点。本篇尝试以例子的形式，以初学者的思维方式分析需求，拆解问题，提炼方法，最终解决问题。从最朴素的直觉出发，引导思考，找到一条易于接受和理解的方法。\n所以，遇到新问题不要慌，对问题拆解后，看能不能找到突破口，如果找不到，再从涉及到的几个主要对象中寻找灵感，通常都会有所收获。最后就是多逛逛MDN，关键时刻真能派上大用场。\n最后，情人节快乐，祝有情人终成眷属！\n参考\n[1] 使用CSS隐藏元素滚动条 [2] Element [3] 事件参考 [4] MouseEvent ","date":"12 February 2022","permalink":"/post/%E7%94%A8%E7%BA%AFHTML%EF%BC%8CJS%EF%BC%8CCSS%E5%AE%9E%E7%8E%B0%E6%A8%AA%E5%90%91%E6%BB%9A%E5%8A%A8%E6%A0%87%E7%AD%BE%E9%A1%B5.html","section":"Posts","summary":"\u003ch3 id=\"前言\" class=\"relative group\"\u003e前言 \u003cspan class=\"absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100\"\u003e\u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\" style=\"text-decoration-line: none !important;\" href=\"#%e5%89%8d%e8%a8%80\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\u003c/span\u003e\u003c/h3\u003e\u003cp\u003e前不久，在我的一个项目中，需要展示一个横向滚动的标签页，它支持鼠标横向拖动和点击切换。在实现的过程中，我发现这个小功能需要同时用到前端的三辆马车，但是实现难度不高，而且最终效果还不错，是个难得的初学者项目，于是萌生了写这篇文章的想法，希望对初学者有所帮助。同时为了避免初学者学习框架，我打算用纯原生的方式实现它。\u003c/p\u003e","title":"用纯HTML，JS，CSS实现横向滚动标签页"},{"content":"什么是JNI开发 #JNI的全称是Java Native Interface，顾名思义，这是一种解决Java和C/C++相互调用的编程方式。它其实只解决两个方面的问题，怎么找到和怎么访问。 弄清楚这两个话题，我们就学会了JNI开发。需要注意的是，JNI开发只涉及到一小部分C/C++开发知识，遇到问题的时候我们首先要判断是C/C++的问题还是JNI的问题，这可以节省很多搜索和定位的时间。\n用JVM的眼光看函数调用 #我们知道Java程序是不能单独运行的，它需要运行在JVM上的，而JVM却又需要跑在物理机上，所以它的任务很重，既要处理Java代码，又要处理各种操作系统，硬件等问题。可以说了解了JVM，就了解了Java的全部，当然包括JNI。所以我们先以JVM的身份来看看Java代码是怎样跑起来的吧（只是粗略的内容，省去了很多步骤，为了突出我们在意的部分）。\n运行Java代码前，会先启动一个JVM。在JVM启动后，会加载一些必要的类，这些类中包含一个叫主类的类，也就是含有一个静态成员函数，函数签名为public static void main(String[] args)的方法。资源加载完成后，JVM就会调用主类的main方法，开始执行Java代码。随着代码的执行，一个类依赖另一个类，层层依赖，共同完成了程序功能。这就是JVM的大概工作流程，可以说JVM就好比一座大桥，连接着Java大山和native大山。\n现在问题来了，在Java程序中，某个类需要通过JNI技术访问JVM以外的东西，那么它需要怎样告诉我（我现在是JVM）呢？需要一种方法　把普通的Java方法标记成特殊，这个标记就是native关键字（使用Kotlin时虽然也可以使用这个关键字，但是Kotlin有自己的关键字external）。当我执行到这个方法时，看到它不一样的标记，我就会从其他地方而不是Class里面寻找执行体，这就是一次JNI调用。也就是说对于Java程序来说，只需要将一个方法标记为native，在需要的地方调用这个方法，就可以完成JNI调用了。但是对于我，该怎样处理这一次JNI调用呢？其实上面的寻找执行体的过程是一个跳转问题，在C/C++的世界，跳转问题就是指针问题。那么这个指针它应该指向哪里呢？\nC/C++代码是一个个函数（下文会将Java方法直接用方法简称，而C/C++函数直接用函数简称）组合起来的，每一个函数都是一个指针，这个特性恰好满足我的需要。但是对于我，外面世界那么大，我并不知道从哪里，找什么东西，给我的信息还是不够。为了限定范围，我规定，只有通过System.loadLibrary(“xxx”)加载的函数，我才会查找，其余的我直接罢工（抛错）。这一下子减轻了我的工作量，至少我知道从哪里找了。\n确定了范围，下一步就是在这个范围里确定真正的目标了。Java世界里怎样唯一标识一个类呢，有的人会脱口而出——类名，其实不全对，因为类名可能会重名，我们需要全限定的类名，也就是包名加类名，如String的全限定类名就是java.lang.String。但是这和我们查找native的方法有什么联系呢。当然有联系，既然一个全限定的类名是唯一的，那么它的方法也是唯一的，那么假如我规定以这个类的全限定类名加上方法名作为native函数的函数名，这样我是不是就可以通过函数名的方式找到native的函数看呢，答案是肯定的，但是有瑕疵，因为Java系统支持方法重载，也就是一个类里面，同名的方法可能有多个。那么构成重载的条件是什么呢，是参数列表不同。所以，结果就很显然了，我在前面的基础上再加上参数列表，组合成查找条件，我是不是就可以唯一确定某一个native函数了呢，这就是JNI的静态注册。\n不过，既然我只需要确定指针的指向，那么我能不能直接给指针赋值，而不是每次都去查找呢，虽然我不知道累，但是还是很耗费时间的。对于这种需求，我当然也是满足的啦，你直接告诉我，我就不找了，我还乐意呢。而且，既然你都给我找到了，我就不需要下那么多规定了，都放开，你说是我就相信你它是。这就是JNI的动态注册。\nJNI的函数注册 #上一节我们通过化身JVM的方式了解了JNI函数注册的渊源，并且引出了两种函数注册方式。从例子上，我们也可以总结出两种注册方式的特点\n注册类型 优点 缺点 静态注册 JVM自动查找 实现简单 函数名贼长，限制较多 查找耗时 动态注册 运行快 对函数名无限制 实现复杂 那么具体怎么做呢？我们接着往下说。\n静态注册 #虽然静态注册限制比较多，但是都是一些浅显的规则，更容易实施，所以先从静态注册开始讲解。\n静态注册有着明确的开发步骤\n编写Java类，声明native方法; 使用java xxx.java将Java源文件编译为class文件 使用javah xxx生成对应的.h文件 构建工具中引入.h文件 实现.h文件中的函数 上面的这个步骤是静态开发的基本步骤，但是其实在如今强大的IDE面前，这些都不需要我们手动完成了，在Android Studio中，定义好native方法后，在方法上按alt + enter就可以生成正确的函数签名，直接写函数逻辑就可以了。但是学习一门学问，我们还是要抱着求真，求实的态度，所以我用一个例子来阐述一下这些规则，以加深读者的理解。\nTest.java\npackage me.hongui.demo public class Test{ native String jniString(); } native-lib.cpp\n#include \u0026lt;jni.h\u0026gt; extern \u0026#34;C\u0026#34; jstring Java_me_hongui_demo_Test_jniString(JNIEnv *env, jobject thiz) { // TODO: implement jniString() } 上面就是一个JNI函数在两端声明的例子，不难发现\n函数签名以Java_为前缀 前缀后面跟着类的全路径，也就是包含包名和类名 以_作为路径分隔符 函数的第一个参数永远是JNIEnv *类型，第二个参数根据函数类型的不同而不同，static类型的方法，对应的是jclass类型，否则对应的是jobject类型。类型系统后面会详细展开。 为什么Java方法对应到C/C++函数后，会多两个参数呢。我们知道JVM是多线程的，而我们的JNI方法可以在任何线程调用，那么怎样保证调用前后JVM能找到对应的线程呢，这就是函数第一个参数的作用，它是对线程环境的一种封装，和线程一一对应，也就是说不能用一个线程的JNIEnv对象在另一个线程里使用。另外，它是一个C/C++访问Java世界的窗口，JNI开发的绝大部分时间都是和JNIEnv打交道。\n动态注册 #同样按照开发过程，我们一步一步来完成。 我们把前面的Java_me_hongui_demo_Test_jniString函数名改成jniString（当然不改也可以，毕竟没限制），参数列表保持不变，这时，我们就会发现Java文件报错了，说本地方法未实现。其实我们是实现了的，只是JVM找不到。为了让JVM能找到，我们需要向JVM注册。 那么怎么注册，在哪注册呢，似乎哪里都可以，又似乎都不可以。 前面说过，JVM只会查找通过System.loadLibrary(“xxx”); 加载的库，所以要想使用native方法，首先要先加载包含该方法的库文件，之后，才可使用。加载了库，说明Java程序要开始使用本地方法了。在加载库之后，调用方法之前，理论上都是可以注册方法的，但是时机怎么确定呢，JNI早就给我们安排好了。JVM在把库加载进虚拟机后，会调用函数jint JNI_OnLoad(JavaVM *vm, void *reserved)，以确认JNI的版本，版本信息会以返回值的形式传递给JVM，目前可选的值有JNI_VERSION_1_1,JNI_VERSION_1_2,JNI_VERSION_1_4,JNI_VERSION_1_6。假如库没有定义这个函数，那么默认返回的是JNI_VERSION_1_1，库将会加载失败，所以，为了支持最新的特性我们通常返回较高的版本。既然有了这么好的注册时机，那么下一步就是实现注册了。\n但事情并没有这么简单。由JNI_OnLoad函数参数列表可知，目前，可供使用的只有JVM，但是查阅JVM的API，我们并没有发现注册的函数——注册函数是写在JNIEnv类里面的。恰巧的是，JVM提供了获取JNIEnv对象的函数。\nJVM有多个和JNIEnv相关的函数，在Android开发中，我们需要使用AttachCurrentThread来获取JNIEnv对象，这个函数会返回执行状态，当返回值等于JNI_OK的时候，说明获取成功。有了JNIEnv对象，我们就可以注册函数了。\n先来看看注册函数的声明——jint RegisterNatives(jclass clazz, const JNINativeMethod* methods,jint nMethods。返回值不用多说，和AttachCurrentThread一样，指示执行状态。难点在参数上，第一个参数是jclass类型，第二个是JNINativeMethod指针，都是没见过的主。\n为什么需要这么多参数呢，JVM不只需要一个函数指针吗。还是唯一性的问题，记得前面的静态注册吗，静态注册用全限定类型和方法，参数列表，返回值的组合确定了函数的唯一性。但是对于动态注册，这些都是未知的，但是又是必须的。为了确定这些值，只能通过其他的方式。jclass就是限定方法的存在范围，获取jclass对象的方式也很简单，使用JNIEnv的jclass FindClass(const char* name)函数。参数需要串全限定符的类名，并且把.换成/，也就是类似me/hongui/demo/Test的形式，为啥这样写，后面会单独拿一节出来细说。\n第二个和第三个参数组合起来就是常见的数组参数形式。先来看看JNINativeMethod的定义。\ntypedef struct { char *name; char *signature; void *fnPtr; } JNINativeMethod; 有个编写诀窍，按定义顺序，相关性是从Java端转到C/C++端，怎么理解呢？name是只的Java端对应的native函数的名字，这是纯Java那边的事，Java那边取啥名，这里就是啥名。第二个signature代表函数签名，签名信息由参数列表和返回值组成，形如(I)Ljava/lang/String;,这个签名就是和两边都有关系了。首先Java那边的native方法定义了参数列表和返回值的类型，也就是限定了签名的形式。其次Java的数据类型对应C/C++的转换需要在这里完成，也就是参数列表和返回值要写成C/C++端的形式，这就是和C/C++相关了。最后一个fnPtr由名字也可得知它是一个函数指针，这个函数指针就是纯C/C++的内容了，代表着Java端的native方法在C/C++对应的实现，也就是前文所说的跳转指针的。知道了这些，其实我们还是写不出代码，因为，我们还有JNI的核心没有说到，那就是类型系统。\nJNI的类型系统 #由于涉及到Java和C/C++两个语言体系，JNI的类型系统很乱，但并非无迹可寻。首先需要明确的是，两端都有自己的类型系统，Java里的boolean，int，String,C/C++的bool,int,string等等，遗憾的是，它们并不一一对应。也就是说C/C++不能识别Java的类型。既然类型不兼容，谈何调用呢。这也就是JNI欲处理的问题。\nJNI类型映射 #为了解决类型不兼容的问题，JNI引入了自己的类型系统，类型系统里定义了和C/C++兼容的类型，并且还对Java到C/C++的类型转换关系做了规定。怎么转换的呢，这里有个表\nJava类型 C/C++类型 描述 boolean jboolean unsigned 8 bits byte jbyte signed 8 bits char jchar unsigned 16 bits short jshort signed 16 bits int jint signed 32 bits long jlong signed 64 bits float jfloat 32 bits double jdouble 64 bits void void N/A 乍一看，没什么特别的，不过就是加了j前缀（除了void)，但是，这只是基本类型，我们应该没忘记Java是纯面向对象的语言吧。各种复杂对象才是Java的主战场啊。而对于复杂对象，情况就复杂起来了。我们知道在Java中，任何对象都是Object类的子类。那么我们是否可以把除上面的基本类型以外的所有复杂类型都当作Object类的对象来处理呢，可是可以，但是不方便,像数组，字符串，异常等常用类，假如不做转换使用起来比较繁琐。为了方便我们开发，JNI又将复杂类型分为下面这几种情况\njobject (所有的Java对象) | |--jclass (java.lang.Class) |--jstring (java.lang.String) |--jarray (数组) | | | |-- jobjectArray (Object数组) | |-- jbooleanArray (boolean数组) | |-- jbyteArray (byte数组) | |-- jcharArray (char数组) | |-- jshortArray (short数组) | |-- jintArray (int数组) | |-- jlongArray (long数组) | |-- jfloatArray (float数组) | |-- jdoubleArray (double数组) |--jthrowable (java.lang.Throwable异常) 两个表合起来就是Java端到C/C++的类型转换关系了。也就是说，当我们在Java里声明native代码时，native函数参数和返回值的对应关系，也是C/C++调用Java代码参数传递的对应关系。但是毕竟两套系统还是割裂的，类型系统只定义了兼容方式，并没有定义转换方式，双方的参数还是不能相互识别，所以，JNI又搞了个类型签名，欲处理类型的自动转换问题。\nJNI的类型签名 #类型签名和类类型映射类似，也有对应关系，我们先来看个对应关系表\n类型签名 Java类型 Z boolean B byte C char S short I int J long F float D double L fully-qualified-class ; fully-qualified-class [type type[] (arg-types)ret-type method type 对于基本类型，也很简单，就是取了首字母，除了boolean(首字母被byte占用了)，long（字母被用作了符合对象的前缀标识符）。 着重需要注意的是复合类型，也就是某个类的情况。它的签名包含三部分，前缀L，中间是类型的全限定名称，跟上后缀;,三者缺一不可,并且限定符的分隔符要用/替换, 。 注意，类型签名和类型系统不是一个概念。类型通常是纯字符串的，用在函数注册等地方，被JVM使用的。类型系统是和普通类型一样的，可以定义变量，作为参数列表，被用户使用的。 另外，数组对象也有自己的类型签名，也是有着类型前缀[，后面跟着类型的签名。最后的方法类型，也就是接下来我们着重要讲的地方，它也是由三部分组成()和包含在()里面的参数列表，()后面的返回值。这里用到的所有类型，都是指类型签名。\n我们来看个例子\nlong f (int n, String s, boolean[] arr); 它的类型签名怎么写呢？我们来一步一步分析\n确定它在Java里面的类型，在表中找出对应关系，确定签名形式。 用步骤1的方法确定它的组成部分的类型。 将确定好的签名组合在一起 此例是方法类型，对应表中最后一项，所以签名形式为(参数)返回值。该方法有三个参数，我们按照步骤1的方式逐一确定。\nint n对应int类型，签名是I; String s对应String类型，是复合类型，对应表中倒数第三项，所以它的基本签名形式是L全限定名;。而String的全限定名java.lang.String，用/替换,后变成java/lang/String。按步骤3，将它们组合在一起就是Ljava/lang/String;; boolean[] arr对应数组类型，签名形式是[类型，boolean的签名是Z。组合在一起就是[Z; 最后来看返回值，返回值是long类型，签名形式是J。 按照签名形式将这些信息组合起来就是(ILjava/lang/String;[Z)J，注意类型签名和签名之间没有任何分割符，也不需要，类型签名是紧密排列的。\n再看动态注册 #有了JNI的类型系统的支持，回过头来接着看动态注册的例子，让我们接着完善它。\n用JVM对象获取JNIEnv对象，即auto status=vm-\u0026gt;AttachCurrentThread(\u0026amp;jniEnv, nullptr); 用步骤1获取的JNIEnv对象获取jclass对象，即auto cls=jniEnv-\u0026gt;FindClass(\u0026quot;me/hongui/demo/Test\u0026quot;); 定义JNINativeMethod数组，即JNINativeMethod methods[]={{\u0026quot;jniString\u0026quot;, \u0026quot;()Ljava/lang/String;\u0026quot;,reinterpret_cast\u0026lt;void *\u0026gt;(jniString)}};，这里的方法签名可以参看上一节。 调用JNIEnv的RegisterNatives函数。即status=jniEnv-\u0026gt;RegisterNatives(cls,methods,sizeof(methods)/sizeof(methods[0]));。 当然，别忘了实现对应的native函数，即这里的jniString——JNINativeMethod的第三个参数。 这五步就是动态注册中JNI_OnLoad函数的实现模板了，主要的变动还是来自jclass的获取参数和JNINativeMethod的签名等，必须做到严格的一一对应。如下面的例子\nextern \u0026#34;C\u0026#34; jint JNI_OnLoad(JavaVM *vm, void *reserved){ JNIEnv* jniEnv= nullptr; auto status=vm-\u0026gt;AttachCurrentThread(\u0026amp;jniEnv, nullptr); if(JNI_OK==status){ JNINativeMethod methods[]={{\u0026#34;jniString\u0026#34;, \u0026#34;()Ljava/lang/String;\u0026#34;,reinterpret_cast\u0026lt;void *\u0026gt;(jniString)}}; auto cls=jniEnv-\u0026gt;FindClass(\u0026#34;me/hongui/demo/Test\u0026#34;); status=jniEnv-\u0026gt;RegisterNatives(cls,methods,sizeof(methods)/sizeof(methods[0])); if(JNI_OK==status) { return JNI_VERSION_1_6; } } return JNI_VERSION_1_1; } 在JNI中使用数据 #前面磨磨唧唧说了这么一大片，其实才讲了一个问题——怎么找到。虽然繁杂，但好在有迹可循，大不了运行奔溃。下面要讲的这个问题就棘手多了，需要一点点耐性和细心。这一部分也可以划分成两个小问题——***访问已知对象的数据，创建新对象。有一点还是要提一下，这里的访问还创建都是针对Java程序而言的，也就是说，对象是存在JVM虚拟机的堆上的，我们的操作都是基于堆对象的操作。***而在C/C++的代码里，操作堆对象的唯一途径就是通过JNIenv提供的方法。所以，这部分其实就是对JNIenv方法的应用讲解。\nJava对象的访问 #在面向对象的世界中，我们说访问对象，通常指两个方面的内容，访问对象的属性、调用对象的方法。这些操作在Java世界中，很好实现，但是在C/C++世界却并非如此。在JNI的类型系统那一节，我们也了解到，Java中的复杂对象在C/C++中都对应着jobject这个类，显然，无论Java世界中，那个对象如何牛逼，在C/C++中都是一视同仁的。为了实现C/C++访问Java的复杂对象，结合访问对象的方式，JNIEnv提供了两大类方法，一类是对应属性的，一类是对应方法的。借助JNIEnv，C/C++就能实现访问对象的目标了。而且它们还有一个较为统一的使用步骤：\n根据要访问的内容准备好对应id（fieldid或者methodid）。 确定访问的对象和调用数据 通过JNIEnv的方法调用完成对象访问 可以看出来，这使用步骤和普通面向对象的方式多了一些准备阶段（步骤1，2）。之前提到过，这部分的内容需要的更多的是耐心和细心，不需要多少酷炫的操作，毕竟发挥空间也有限。这具体也体现在上面的步骤1，2。正是这个准备阶段让整个C/C++的代码变得丑陋和脆弱，但是——又不是不能用，是吧。\n看一个例子，Java里定义了一个Person类，类定义如下\npublic class Person(){ private int age; private String name; public void setName(String name){ return this.name=name; } } 现在，我们在C/C++代码里该怎么访问这个类的对象呢。假定需要读取这个对象的age值，设置这个对象的name值。根据上面的步骤，我们有以下步骤\n准备好age的fieldid,setName的methodid。根据JNIEnv的方法，我们可以看到四个相关的，fieldid,methodid各两个，分普通的和静态的。我们这里都是普通的，所以确定的方法是GetFieldID和GetMethodID。第一个参数就是jclass对象，获取方法前面已经说过,即通过JNIEnv的FindClass方法，参数是全限定类名，以/替换.。后面两个参数对应Java端的名称和类型签名，age属于field，int的类型签名是I，setName属于method，签名形式是(参数)返回值，这里参数的签名是Ljava/lang/String;，返回值的签名是V，组合起来就是\u0026quot;(Ljava/lang/String;)V\u0026quot;。 假定我们已经有了Person对象obj,通过Java传过来的。 分别需要调用两个方法，age是整形属性，要获取它的值，对应就需要使用GetIntField方法。setName是返回值为void的方法。所以应该使用CallVoidMethod。 通过上面的分析，得出下面的示例代码。\nauto cls=jniEnv-\u0026gt;FindClass(\u0026#34;me/hongui/demo/Person\u0026#34;); auto ageId=jniEnv-\u0026gt;GetFieldID(cls,\u0026#34;age\u0026#34;,\u0026#34;I\u0026#34;); auto nameId=jniEnv-\u0026gt;GetMethodID(cls,\u0026#34;setName\u0026#34;,\u0026#34;(Ljava/lang/String;)V\u0026#34;); jint age=jniEnv-\u0026gt;GetIntField(obj,ageId); auto name=jniEnv-\u0026gt;NewStringUTF(\u0026#34;张三\u0026#34;); jniEnv-\u0026gt;CallVoidMethod(obj,nameId,name); 从上面的分析和示例来看，耐心和细心主要体现在\n对要访问的属性或者方法要耐心确定类型和名称，并且要保持三个步骤中的类型要一一对应。即调用GetFieldID的类型要以GetXXXField的类型保持一致，方法也是一样。 对属性或方法的静态非静态修饰也要留心，通常静态的都需要使用带有static关键字的方法，普通的则不需要。如GetStaticIntField就是对应获取静态整型属性的值，而GetIntField则是获取普通对象的整型属性值。 属性相关的设置方法都是类似于SetXField的形式，里面的X代表着具体类型，和前面的类型系统中的类型一一对应，假如是复杂对象，则用Object表示，如SetObjectField。而访问属性只需要将前缀Set换成Get即可。对于静态属性，则是在Set和X之间加上固定的Static，即SetStaticIntField这种形式。 方法调用则是以Call为前缀，后面跟着返回值的类型，形如CallXMethod的形式。这里X代表返回值。如CallVoidMethod就表示调用对象的某个返回值为void类型的方法。同样对应的静态方法则是在Call和X之间加上固定的Static,如CallStaticVoidMethod。 向Java世界传递数据 #向Java世界传递数据更需要耐心。因为我们需要不断地构造对象，组合对象，设置属性。而每一种都是上面Java对象的访问的一种形式。\n构造Java对象 #C/C++构造Java对象和调用方法类似。但是，还是有很多值得关注的细节。根据前面的方法，我们构造对象，首先要知道构造方法的id，而得到id，我们需要得到jclass，构造方法的名字和签名。我们知道在Java世界里，构造方法是和类同名的，但是在C/C++里并不是这样，它有着特殊的名字——\u0026lt;init\u0026gt;，注意，这里的\u0026lt;\u0026gt;不能少。***也就是说无论这个类叫什么，它的构造函数的名字都是\u0026lt;init\u0026gt;。***而函数签名的关键点在于返回值，构造方法的返回值都是void也就是对应签名类型V。\n接前面那个Person类的例子，要怎样构造一个Person对象呢。\n通过JNIEnv的FindClass得到就jclass对象。记得将'替换成/。 根据需要得到合适的构造方法的id。我没有定义构造方法，那么编译器会为它提供一个无参的构造方法。也就是函数签名为()V。调用JNIEnv的GetMethodID得到id。 调用JNIEnv的NewObject创建对象，记得传递构造参数。我这里不需要传递。 综上分析，这个创建过程类似于如下示例\nauto cls=env-\u0026gt;FindClass(\u0026#34;me/hongui/demo/Person\u0026#34;); auto construct=env-\u0026gt;GetMethodID(cls,\u0026#34;\u0026lt;init\u0026gt;\u0026#34;,\u0026#34;()V\u0026#34;); auto age=env-\u0026gt;GetFieldID(cls,\u0026#34;age\u0026#34;,\u0026#34;I\u0026#34;); auto name=env-\u0026gt;GetFieldID(cls,\u0026#34;name\u0026#34;,\u0026#34;Ljava/lang/String;\u0026#34;); auto p=env-\u0026gt;NewObject(cls,construct); auto nameValue=env-\u0026gt;NewStringUTF(\u0026#34;张三\u0026#34;); env-\u0026gt;SetIntField(p,age,18); env-\u0026gt;SetObjectField(p,name,nameValue); return p 上面的示例有个有意思的点，其实示例中创建了两个Java对象，一个是Person对象，另一个是String对象。因为在编程中，String出境的概率太大了，所以JNI提供了这个简便方法。同样特殊的还有数组对象的创建。并且因为数组类型不确定，还有多个版本的创建方法，如创建整型数组的方法是NewIntArray。方法签名也很有规律，都是NewXArray的形式，其中X代表数组的类型，这些方法都需要一个参数，即数组大小。既然提到了数组，那么数组的设置方法就不得不提。设置数组元素的值也有对应的方法，形如SetXArrayRegion，如SetIntArrayRegion就是设置整型数组元素的值。和Java世界不同的是，这些方法都是支持同时设置多个值的。整形数组的签名是这样——void SetIntArrayRegion(jintArray array,jsize start, jsize len,const jint* buf)第二个参数代表设置值的开始索引，第三个参数是数目，第四个参数是指向真正值的指针。其余类型都是类似的。\n让数据访问更进一步 #有些时候，我们不是在调用native方法时访问对象，而是在将来的某个时间。这在Java世界很好实现，总能找到合适的类存放这个调用时传递进来的对象引用，在后面使用时直接用就可以了。native世界也是这样吗？从使用流程上是一样的，但是从实现方式上却是很大不同。\nJava世界是带有GC的，也就是说，将某个临时对象X传递给某个对象Y之后，X的生命周期被转移到了Y上了，X不会在调用结束后被销毁，而是在Y被回收的时候才会一同回收。这种方式在纯Java的世界里没有问题,但是当我们把这个临时对象X传递给native世界，试图让它以Java世界那样工作时，应用却崩溃了，报错JNI DETECTED ERROR IN APPLICATION: native code passing in reference to invalid stack indirect reference table or invalid reference: 0xxxxx。为什么同样的操作在Java里面可以，在native却不行呢。问题的根源就是Java的GC。GC可以通过各种垃圾检测算法判断某个对象是否需要标记为垃圾。而在native世界，不存在GC，为了不造成内存泄漏，只能采取最严格的策略，默认调用native方法的地方就是使用Java对象的地方。所以在native方法调用的作用域结束后，临时对象就被GC标记为垃圾，后面想再使用，可能已经被回收了。还好，强大的JNIEnv类同样提供了方法让我们改变这种默认策略——NewGlobalRef。对象只需要通过这种方式告诉JVM，它想活得更久一点，JVM在执行垃圾检测的时候就不会把它标记为垃圾，这个对象就会一直存。在，直到调用DeleteGlobalRef。这里NewGlobalRef，DeleteGlobalRef是一一对应的，而且最好是再不需要对象的时候就调用DeleteGlobalRef释放内存，避免内存泄漏。\n总结 #JNI开发会涉及到Java和C/C++开发的知识，在用C/C++实现JNI时，基本思想就是用C/C++语法写出Java的逻辑，也就是一切为Java服务。JNI开发过程中，主要要处理两个问题，函数注册和数据访问。\n函数注册推荐使用动态注册，在JNI_OnLoad函数中使用JNIEnv的RegisterNatives注册函数，注意保持Java的native方法和类型签名的一致性，复合类型不要忘记前缀L、后缀;，并将.替换为/。\n数据访问首先需要确定访问周期，需要在多个地方或者不同时间段访问的对象，记得使用NewGlobalRef阻止对象被回收，当然还要记得DeleteGlobalRef。访问对象需要先拿到相应的id，然后根据访问类型确定访问方法。设置属性通常是SetXField的形式，获取属性值通常是GetXField的形式。调用方法，需要根据返回值的类型确定调用方法，通常是CallXMethod的形式。当然，这些都是针对普通对象的，假如需要访问静态属性或者方法，则是在普通版本的X前面加上Static。这里的所有X都是指代类型，除了基本类型外，其他对象都用Object替换。\n在注册函数和访问数据的时候需要时刻关注的就是数据类型。C/C++数据类型除了基本类型外都不能直接传递到Java里，需要通过创建对象的方式传递。一般的创建对象方式NewObject可以创建任何对象，而对于使用频繁的字符串和数组有对应的快速方法NewStringUTF，NewXArray。向Java传递字符串和数组，这两个方法少不了。\n青山不改，绿水长流，咱们下期见！\n","date":"12 September 2021","permalink":"/post/Android-JNI%E5%BC%80%E5%8F%91%E6%A6%82%E8%AE%BA.html","section":"Posts","summary":"\u003ch1 id=\"什么是jni开发\" class=\"relative group\"\u003e什么是JNI开发 \u003cspan class=\"absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100\"\u003e\u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\" style=\"text-decoration-line: none !important;\" href=\"#%e4%bb%80%e4%b9%88%e6%98%afjni%e5%bc%80%e5%8f%91\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\u003c/span\u003e\u003c/h1\u003e\u003cp\u003eJNI的全称是Java Native Interface，顾名思义，这是一种解决Java和C/C++相互调用的编程方式。\u003cem\u003e\u003cstrong\u003e它其实只解决两个方面的问题，怎么找到和怎么访问。\u003c/strong\u003e\u003c/em\u003e 弄清楚这两个话题，我们就学会了JNI开发。\u003cem\u003e\u003cstrong\u003e需要注意的是，JNI开发只涉及到一小部分C/C++开发知识，遇到问题的时候我们首先要判断是C/C++的问题还是JNI的问题，这可以节省很多搜索和定位的时间。\u003c/strong\u003e\u003c/em\u003e\u003c/p\u003e","title":"Android-JNI开发概论"},{"content":"","date":null,"permalink":"/tags/cmake/","section":"Tags","summary":"","title":"CMake"},{"content":"前言 #CMake是一个构建工具，通过它可以很容易创建跨平台的项目。通常使用它构建项目要分两步，通过源代码生成工程文件，通过工程文件构建目标产物（可能是动态库，静态库，也可能是可执行程序）。使用CMake的一个主要优势是在多平台或者多人协作的项目中，开发人员可以根据自己的喜好来使选择IDE，不用受其他人工程配置的影响，它有点像跨平台的IDE，通过它配置好相关设置之后，可以在多个平台无缝衔接，提高开发效率。\n最简单的CMake工程 #项目搭建 #一个用CMake来管理的项目，其项目根目录通常会包含一个CMakeLists.txt的文件，当然子目录可能也有，这种情况我们稍后再说。我们先从最简单的项目开始。以下就是一个最简单的工程示例：\nCMakeProject | CMakeLists.txt | main.cpp 这就是完整的可以跑起来的最小项目了。按照顺序，我们来看看文件里的内容\nCMakeLists.txt\n# 设置版本号 cmake_minimum_required(VERSION 3.10) # 设置项目名 project(CMakeProject) # 设置产物和源码的关联 add_executable(${CMAKE_PROJECT_NAME} main.cpp) 说明：\nCMake中命令不区分大小写 以#开始的是备注 引用变量语法${变量名} 所以文档中真正的有效内容就三行，\ncmake_minimum_required(VERSION 3.10)设置了CMake支持的最低版本，VERSION是参数名，后面是版本号，可以根据自己的需要修改。 注意参数名和参数是以空白符分隔的，不是逗号， 不然会报错。 project(CMakeProject)CMake中字符串可以带引号或者不带，效果是一致的，这一行就是配置了项目名，如生成的Visual Studio的工程名就是依据这个名字来的。 add_executable(${CMAKE_PROJECT_NAME} main.cpp) 才是真正管理源码和目标产物的地方，这里我们使用了引用变量的写法，而文件中没有定义这个变量，说明这个变量存在于CMake中，在CMake还有很多预定义的变量，我们可以直接通过这种方式引用，上面的写法是将项目名设置为产物的名字，当然也可以直接填字符串，取个另外的名字都是可以的。后面的main.cpp则是用来生成产物的源码路径，这就是CMake最灵活的地方。源码路径可以是多样的，查找出来的，直接写的，相对路径，绝对路径都可以。 多个源码的话就用空白符分隔，依次写就行了。 在上面的配置文件中，我们配置了它的源文件为main.cpp，我们想通过它来生成一个可执行的程序，内容也很简单: #include \u0026lt;iostream\u0026gt; int main() { std::cout\u0026lt;\u0026lt;\u0026#34;hello CMake\u0026#34;\u0026lt;\u0026lt;std::endl; return 0; } 项目编译与执行 #准备工作已经做完，接下来我们就要使用CMake生成可执行文件了。\n第一步当然是要安装CMake啦，这是下载地址!Download，根据自己的平台选择下载即可，安装完成之后需要把它添加到环境变量中，便于我们在任何地方都能方便使用。 安装了CMake以后，打开命令行工具，进入到刚才创建的项目根目录，也就是进入到存着CMakeLists.txt和main.cpp的目录，下一步准备生成项目。\n通常为了不影响和污染当前的工作环境，我们会选择新建一个目录来存放生成的工程文件，以下我主要以Windows平台为主要平台讲解，其他平台基本一致。\nmkdir build #创建文件夹，存储工程文件； cd build #切换cmake工作目录; cmake .. #生成项目文件； 这三步执行完后，我们就可以在build文件夹下看到里面已经生成了一个Visual Studio的工程，我们可以直接用Visual Studio打开这个工程，按照我们的习惯执行编译和调试。当然，假如想最快地生成可执行文件，我还是推荐使用CMake。\n使用CMake执行编译，只需要在上一步的基础上（也就是已经成功执行了上面的三个步骤）再执行一个命令cmake --build .就可以了。这里切记不能少第三个英文句号，它代表在当前的工作目录中执行CMake的编译。 假如上面的四步都一切顺利的话，那么，我们就可以在build/debug目录下看到以add_executable的第一个参数命名的可执行文件（这里就是CMakeProject.exe），双击或者把它拖到命令行就可以执行它了。\n项目扩展 #在前面的例子中，生成工程文件，我们使用了两个命令，其实，这里可以直接用一个命令就可以完成——cmake build -S . -B build。这个命令的意思是以当前路径为工作路径，以build目录为生成目录，生成工程文件，也就是不需要我们手动创建build文件夹了。其中 -S参数配置的是源路径，-B配置的是生成路径。\n另外，由于CMake没有清理方法，所以每次修改CMake的配置（也就是新增或者删除CMakeLists.txt中的代码），需要重新生成工程文件的时候，需要我们手动清理生成目录，保证它是空目录，假如不这样做，那么项目可能生成失败或者新配置不起作用。假如只是修改了源代码的内容的话，则不需要重新生成，直接进行第四步即可。 虽然上面的操作已经足够简单，但是考虑到长期的修改和验证需要，还是太繁琐枯燥了，尤其是要反复切换工作目录，还是比较烦人的。所以我推荐使用批处理来完成这些操作。结合清理生成目录和切换工作目录这几个步骤，最终的批处理文件可能是这样的\n@echo off rd /s /q build mkdir build cd build cmake .. cmake --build . cd debug CMakeProject cd ../.. 按顺序依次解释一下:\n第一行是关闭了命令行的回显功能，因为我们不希望它的回显干扰到CMake的信息输出，以造成不必要的混乱，而且通常我们也只关心它最后有没有完成工作而不是看它在干什么。\n第二行则是用了Windows上的删除文件夹命令（Linux，MacOS上对应的是rmdir),/s是配置它清除文件夹中所有的内容，包括子文件夹，不配置命令就会执行失败，/q则是让命令直接执行删除，不需要我们手动确认，这个参数很重要，不然我们需要一个一个地确认删除，完全失去了自动化的作用。然后后面的四句就是我们上面讲的内容了，不再赘述。\n一直来到倒数第二句，这里我直接写了可执行文件的名字（需要替换为你自己的名字），为的就是直接在编译完成之后运行可执行文件，这对有些会生成文件的应用来说很有用。\n执行结束后，再将目录切回到项目根目录，这就是最后一行的作用，由于我们再编译的时候已经切换了目录到生成目录了，而编译的可执行文件又是在生成目录的子目录中，所以回到根目录，我们需要回退两次，这是保证下次我们能胜利执行批处理的关键。\n把上面的内容保存为bat结尾的文件，然后下次就可以直接在命令行输入bat文件名来一次性完成生成和构建了，简直爽歪歪。 以上就是CMake项目我们所需要知道的了。当然实际项目远比这个复杂得多，接下来我将以我踩过的坑为基础，逐一增加项目的复杂度，慢慢形成对CMake的工作流程的理解。\n多源码项目 #个人感悟 #在开始之前，我先讲一讲我对CMake项目或者说CMakeLists.txt文件的理解。我们不能单独的以某一个配置为理解对象，我们需要对这些命令进行分类甚至提炼出它的核心工作模式。我是以c++文件的编译链接为线索梳理的。 我们都知道一个c++源文件要想生成可执行代码，需要分三步\n预处理器处理，拷贝头文件的内容到源文件，宏替换等； 编译器将源文件编译为.o的对象文件； 链接器以.o文件和其他库为输入，链接生成可执行文件。 我们按照这个思路来理解CMake就简单多了。假如CMake报错，我们就可以根据报错信息定位到是哪个阶段出了问题，进而快速找到解决办法。另外我们也可以依据这些信息对CMake的配置分类，我自己理解的粗略分类如下:\n配置CMake基本信息的：cmake_minimum_required； 源码管理的：file,aux_source_directory； 库管理的：find_libraray； 头文件管理的：include_directories； 链接库管理的：link_directories； 子项目管理的：add_subdirectory； 生成物管理的：add_executable,add_library； 当然，这些只是很少的一部分，但是对我们理解和搜索问题的解决思路提供了较好的方向。\nCMake管理子目录 #很多时候，我们会引入第三方包来减少重复编码的工作，通常这种代码我们需要放在其他目录中，于是我新建了一个子目录，用于模拟存放的第三方代码。对于这种情况，我们有两种包含形式——子模块和子目录。\n先说简单一些的子目录吧。子目录的意思就是将第三方代码看作我们代码的一部分，一起合并编译，这种方式可以使我们的项目看起来更紧凑。如以下的项目结构\nCMakeProject | auto.bat | CMakeLists.txt //修改 | main.cpp //修改 | \\---3rd //新增 lib.h 我新建了一个子文件夹，用来模拟第三方代码，现在我们把它引入到main.cpp中，编译，就会发现报错了，信息为fatal error C1083: 无法打开包括文件: “lib.h”: No such file or directory，这很正常。结合上面我举的例子。这个报错信息是和头文件相关的，查看CMake文档，我发现了CMake有个include_directories的指令，它的意思就是添加文件头的目录，以便让CMake找到头文件。于是，我在CMakeLists.txt文件中添加了include_directories(3rd)，然后再次执行编译，项目又正确跑起来了。来看看这时的main.cpp\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;lib.h\u0026gt; int main() { int a=1,b=1; std::cout\u0026lt;\u0026lt;\u0026#34;hello CMake\u0026#34;\u0026lt;\u0026lt;std::endl; std::cout\u0026lt;\u0026lt;\u0026#34;a + b = \u0026#34;\u0026lt;\u0026lt;sum(a,b)\u0026lt;\u0026lt;std::endl; return 0; } 注意：这里的include_directories和cpp中的include是一一对应的，就是说，假如include_directories里面配置的目录是.（当前目录，CMake没有把当前目录添加到include路径），则对应cpp的include要写成3rd/lib.h这种形式，简单来说，就是include_directories被设置为了include的根目录。 另一种情况就是子模块。\nCMake管理子模块 #子模块的意思是，模块可以单独编译，单独提供给其他库使用，而不是和主项目共生的，适用于和主模块耦合不大的情况。为了满足这个条件，我们修改刚才的目录结构为下面这种\nCMakeProject | auto.bat | CMakeLists.txt //修改 | main.cpp | \\---3rd CMakeLists.txt //新增 lib.cpp //新增 lib.h //修改 我把lib.h中的函数改为声明，实现放在了lib.cpp文件中。最大的变化是新建了3rd目录下的CMakeLists.txt文件，用它统一管理3rd目录下的所有源文件（假如文件很多的话，这里是模拟）,使用了add_library把3rd目录下打包成了子模块。\nproject(sum) add_library(${PROJECT_NAME} lib.cpp) add_library在名字和源代码中间还可以指定构建类型，默认是STATIC，也就是静态库，假如想构建动态库需要手动指定为SHARED（add_library(${PROJECT_NAME} SHARED lib.cpp)）。\n重要的改变来自主目录下的CMakeLists.txt\n# 设置版本号 cmake_minimum_required(VERSION 3.10) # 设置项目名 project(CMakeProject) # 指定3rd为include的查找目录 include_directories(3rd) # 子模块 add_subdirectory(3rd) # 设置产物和源码的关联 add_executable(${PROJECT_NAME} main.cpp) target_link_libraries(${PROJECT_NAME} sum) 新增了add_subdirectory，它的作用是将指定目录下的源码作为一个模块编译，前提是这个目录下要有CMakeLists.txt文件。另一个改变就是target_link_libraries的添加，它的作用是将子模块链接进主模块，假如没有这一句，在链接的时候会报错error LNK2019: 无法解析的外部符号。模块的名字需要和子模块中add_library中第一个参数保持一致。\n交叉编译 #在前面的示例中，项目的复杂度表现在多目录，多源码，而在使用CMake进行交叉编译的过程中，项目的主要复杂度表现在环境配置。尽管CMake可以几乎不修改CMakeLists.txt的情况下，实现交叉编译，但是对于新手，面对陌生的配置，往往会无从下手，企图找到一键就完成配置的简便方法。对于CMake,确实没有这种快捷方法，但是，只要我们理解了交叉编译就是正确配置属性值的过程。 这一实质之后，问题就会变得明朗起来。所以，上面的问题就会转化为我们熟悉的问题了——需要配置哪些属性，这些属性有哪些合适的值，这些值怎样传递给CMake等等，这就是交叉编译的全部了。正如之前提到的一样，CMake有很多预设的变量，我们需要从这些预设变量中找到一些，设置一些值，然后让CMake按照这些配置完成工作，这就是我们接下来需要做的事。下面我将以Windows交叉编译Android为例说明这个过程。\n前期准备 #在Windows平台上，默认会使用Visual Studio作为C，C++的编译器，这对于编译Android的库来说可能会报错。所以在执行cmake命令的时候，需要使用 -G \u0026quot;Unix Makefiles\u0026quot;来改变这一行为。但这还不够，因为CMake编译是需要指定编译器的。而Android上的C,C++编译器通常以NDK的方式提供，所以，我们需要下载好NDK。在NDK中，会同时为我们提供两种工具，一种就是编译器，另一种就是android.toolchain.cmake,这也是CMake命令构成的文件，里面为我们交叉编译指定了很多预设值，能大大减轻我们的工作。\n编写编译脚本 #前面说了，交叉编译就是改变CMake预设值，而改变这预设值的方式有两种，我们要结合起来使用。一种是通过NDK提供的android.toolchain.cmake文件。 android.toolchain.cmake中以设置了绝大部分的值，但是这些配置也是很灵活的，还有很大的配置空间。因此，根据用户的需求不同，我们还需要在执行CMake命令时动态传递一些值，以使CMake能正确完成工作。这就是另一种方式——选项。传递选项会以-D开头，后面跟着某个CMake的预定义变量由于选项很多，而且大多比较复杂，所以，最好还是通过脚本文件来记录并且修改。以下就是Windows平台上编译Android代码需要指定的几个选项，我将逐个介绍这些必要的配置。\n-DCMAKE_SYSTEM_NAME=Android这个配置是告诉CMake需要生成Android平台的库，也就是执行交叉编译。 -DANDROID_ABI=x86这个配置是告诉CMake生成库适用的架构平台。熟悉Android开发的读者应该不会陌生，支持的值会根据NDK的变化而有所变化，如早期的armeabi已经在 NDK r17中移除了，现在主流的还有四种armeabi-v7a，arm64-v8a，x86，x86_64.根据需要把值替换就行。 -DANDROID_PLATFORM=android-28,这个值其实不是特别必要，因为有预设值，但是为了可控，还是需要指定一个。它是用来确定库支持的最低系统版本的。 -DCMAKE_TOOLCHAIN_FILE=C:/Users/Leroene/AppData/Local/Android/Sdk/ndk/21.0.6113669/build/cmake/android.toolchain.cmake，这是上面提到的预设文件。需要注意的是，NDK中有多个以这个名字命名的文件，假如指定错误，可能会导致CMake出错，所以我的经验就是，更改版本号（C:/Users/Leroene/AppData/Local/Android/Sdk/ndk/21.0.6113669）及前面的路径，后面的保持不变。 -DCMAKE_MAKE_PROGRAM=C:/Users/Leroene/AppData/Local/Android/Sdk/ndk/21.0.6113669/prebuilt/windows-x86_64/bin/make最后一个参数是指定make程序的路径，由于我们指定生成了make项目的代码，而Windows通常没有make可执行文件，所以我们需要让CMake找到make文件以完成编译。这里我的经验也是保持后面的不变，修改前面的，并保持版本一致以避免BUG。 -DCMAKE_BUILD_TYPE=Release，指定构建类型，这应该很常见了。 至此Windows交叉编译Android库的所有配置都讲解完了。让我们来看看它完整的例子\n@echo off rd /s /q build mkdir build cd build cmake -G \u0026#34;Unix Makefiles\u0026#34; ^ -DCMAKE_TOOLCHAIN_FILE=C:/Users/Leroene/AppData/Local/Android/Sdk/ndk/21.0.6113669/build/cmake/android.toolchain.cmake ^ -DCMAKE_MAKE_PROGRAM=C:/Users/Leroene/AppData/Local/Android/Sdk/ndk/21.0.6113669/prebuilt/windows-x86_64/bin/make ^ -DANDROID_PLATFORM=android-28 ^ -DCMAKE_SYSTEM_NAME=Android ^ -DANDROID_ABI=x86 ^ -DCMAKE_BUILD_TYPE=Release ^ ../3rd cmake --build . 从上面可以看到，这些选项后面都跟着一个^符号，这不是cmake的一部分，只是为了我们阅读方便，特意书写成这样的，这是在Windows平台上批处理使用的命令换行符，它的作用就是告诉命令解析器，这个命令还没有结束，接着往下面解析，该功能在Linux,MacOS上对应于\\。现在有了这些配置之后，该怎么使用呢？其实也很简单，只需要将这些命令存储在android.bat文件中，在CMD中切换到当前目录，执行这个文件就能在build目录中找到以libsum.a命名的静态库文件了。下一步，我们试着用这个库文件运行在模拟器中。\n在Android项目中使用CMake #在Android平台中，也使用CMake来管理jni的项目，配合Gradle一起完成构建工作。这和普通的CMake项目最大的不同是，我们通常需要引用多个Android相关的库，如log,android等.这些库通常是由NDK提供的，我们仿照默认生成的CMakeLists.txt文件编写就可。\n目录结构 #接下来，为了描述方便，我们先来看一下现在的目录结构（为了避免混乱，这里只列出比较有代表性的文件）\nCMakeProject │ android.bat │ CMakeLists.txt │ main.cpp │ ├─3rd │ CMakeLists.txt │ lib.cpp │ lib.h │ └─Android │ build.gradle │ ├─app │ │ build.gradle │ │ │ ├─libs │ └─src │ ├─main │ │ │ AndroidManifest.xml │ │ │ │ │ ├─cpp │ │ │ CMakeLists.txt │ │ │ native-lib.cpp │ │ │ │ │ ├─java │ │ │ └─me │ │ │ └─hongui │ │ │ └─cmakesum │ │ │ MainActivity.kt │ │ │ │ │ ├─jniLibs │ │ │ └─x86 │ │ │ libsum.a 在原来的目录根目录下新建了Android子目录，该目录是一个Android C++工程，所以相比其他普通Android工程，它多了个cpp目录，后面我们主要的修改都是发生在该目录下。\n原来的根目录，为了不增加复杂度，我们只作为生成静态库的功能存在，所以和上面的示例相比，没有任何修改。\n构建静态库 #首先，我们回到根目录。使用根目录下的android.bat批处理生成Android上可用的静态库，也可以修改android.bat文件中的-DANDROID_ABI选项的值，生成其他架构的静态库，但这需要和jniLibs目录下的目录要一一对应，否则可能链接失败。如我生成的libsum.a文件是x86的架构。那么就需要在jniLibs目录下新建x86的目录下，然后再把libsum.a放到该目录下。至此，静态库的构建工作就算结束了。\n使用静态库 #把静态库放到合适的位置后，我们需要配置app目录下的build.gradle和cpp目录下的CMakeLists.txt文件，完成静态库的引入。\n配置Gradle #首先说build.gradle，该文件主要涉及到修改ABI的问题，因为不指定的话，Gradle默认生成的ABI可能找不到对应的静态库文件来链接，从而导致链接失败。该文件主要的修改如下\nandroid { defaultConfig { externalNativeBuild { cmake { cppFlags \u0026#34;\u0026#34; abiFilters \u0026#34;x86\u0026#34; } } } } 也就是把abiFilters的值指定为刚才构建的静态库相同的值。\n配置CMake #而CMakeLists.txt文件就复杂一些了，它需要完成两个工作，找到静态库和静态库的头文件，链接静态库。\n找到头文件 #在文章的第二部分我们已经知道了让CMake找到头文件的include_directories命令，把参数设置为3rd目录就行了。值得注意的是，CMake是以当前的CMakeLists.txt文件为工作目录的，所以，要指定到3rd文件，我们需要一直回退目录到根项目，最终就有了include_directories(../../../../../3rd)这样的配置。尽量使用相对路径，可以在多人协同的情况下，不用修改配置。\n找到静态库 #下一步要让CMake找到我们的静态库。说到库，都是和add_library相关的，不同的只是参数。使用源码添加库的时候，我们需要指定库的名称和源码位置，而引用第三方库，则是需要指定库的名称和类型，外加一个IMPORTED的指示参数，告诉CMake这个库是导入的。所以就有了add_library(addSum STATIC IMPORTED)这样的配置。\n但是，这里我们只告诉了CMake库的名字，库存储在哪里，还不知道，所以我们还需要另一个命令告诉CMake库的存储位置。涉及到配置参数的，通常就是set_target_properties命令了，可以多次调用这个命令设置多种配置。set_target_properties(addSum PROPERTIES IMPORTED_LOCATION ${CMAKE_CURRENT_SOURCE_DIR}/../jniLibs/${ANDROID_ABI}/libsum.a),第一个参数和上一条的第一个参数是一一对应的，可以随便取。其实add_library相当于生成了一种目标产物，用第一个参数来指代这种产物，所以才让我们的set_target_properties找得到合适的目标设置属性。第二个参数则是配置属性的标准写法，第三个代表属性变量，第四个是属性值，配置库路径的变量就是IMPORTED_LOCATION，而值这里就有个坑了，Android下的CMake限定值必须是绝对路径，不能是相对路径。而这与使用CMake的初衷背道而驰，幸好，我们有几个预设值可以用，CMAKE_CURRENT_SOURCE_DIR就是其中之一，它代表着当前这个CMakeLIsts.txt文件的绝对路径，有了这个，再加上目录的回退功能，我们就能找到任何合适的目录了。至此，又出现了第二个问题，当有多个架构的静态库需要配置时，我们引入的目录是不一样的，而且会出现很多重复的配置。还好有ANDROID_ABI的帮助，它指代了当前编译的某个架构，随着编译的进行，这个值会被设置为合适的值，并且是和正在编译的架构是一一对应的。所以，尽管它们有点奇怪，但是这给我带来了灵活和简单。\n链接静态库 #现在头文件有了，库也有了，但是C++的编译是分成两步的，目前为止，我们的工作只做完了编译的事情，还没涉及到链接的事情，当然，相比前面的配置，这就简单多了，无疑就是在target_link_libraries命令里添加一个参数就可，如\ntarget_link_libraries( native-lib ${log-lib} addSum ) 只需哟注意名字和add_library时配置的名字一一对应就可。\n在源码中使用 #经过漫长的等待，现在我们终于能在native-lib.cpp文件中引入addsum的头文件，并且使用里面的函数完成工作了。我打算让函数返回一个包含加法运算结果的字符串。最终实现如下\n#include \u0026lt;jni.h\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;lib.h\u0026gt; extern \u0026#34;C\u0026#34; JNIEXPORT jstring JNICALL Java_me_hongui_cmakesum_MainActivity_stringFromJNI( JNIEnv* env, jobject /* this */) { std::string hello = std::to_string(sum(1,1)); return env-\u0026gt;NewStringUTF(hello.c_str()); } 至此，点击工具栏上的run按钮，我们终于可以在Android的模拟器上看到我们的静态库工作的成果啦。\n扩展 #其实除了引用静态库的方式之外，我们还可以直接通过配置CMakeLists.txt文件来引用源码，这样可以随时随地对源码进行定制，但是也降低了编译速度，而且可能会增加CMakeLists.txt的复杂度。所以我还是推荐直接使用静态库的方式。\n总结 #CMake其实还有很多很多命令，我们这里涉及到的只是很少的一部分。但是，我觉得理解CMake有这些内容差不多就可以了，后续有需要再针对性学习就行了。学习一门技术，切忌不能贪多，贪细。先要抓住主干，理清脉络，后面的细节就是水到渠成的事。对于CMake，我觉得就是以C++代码编译为二进制的过程为主干就够了。源码从哪里来，头文件在那里，库文件在哪里，怎么组织编译，参与链接的库有哪些，生成什么产物，还有一些完成这些工作的通用操作，复制文件啊，目录信息啊等，这些操作的集合就构成了CMake的主体。另外，CMake其实只是一种构建工具，它本身不是编译器和链接器，有些问题可能不仅仅会涉及到cmake，还可能会涉及到编译器和连接器。当然，这些都是后面深入了解之后才可能碰到的问题了。\n","date":"9 August 2021","permalink":"/post/CMake%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3%E5%92%8C%E4%BD%BF%E7%94%A8.html","section":"Posts","summary":"\u003ch1 id=\"前言\" class=\"relative group\"\u003e前言 \u003cspan class=\"absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100\"\u003e\u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\" style=\"text-decoration-line: none !important;\" href=\"#%e5%89%8d%e8%a8%80\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\u003c/span\u003e\u003c/h1\u003e\u003cp\u003eCMake是一个构建工具，通过它可以很容易创建跨平台的项目。通常使用它构建项目要分两步，通过源代码生成工程文件，通过工程文件构建目标产物（可能是动态库，静态库，也可能是可执行程序）。使用CMake的一个主要优势是在多平台或者多人协作的项目中，开发人员可以根据自己的喜好来使选择IDE，不用受其他人工程配置的影响，它有点像跨平台的IDE，通过它配置好相关设置之后，可以在多个平台无缝衔接，提高开发效率。\u003c/p\u003e","title":"CMake个人理解和使用"},{"content":"","date":null,"permalink":"/tags/kotlin/","section":"Tags","summary":"","title":"Kotlin"},{"content":" 上一篇文章，我介绍了Kotlin协程的创建，使用，协作等内容。本篇将引入更多的使用场景，继续带你走进协程世界。\n使用协程处理异步数据流 #常用编程语言都会内置对同一类型不同对象的数据集表示，我们通常称之为容器类。不同的容器类适用于不同的使用场景。Kotlin的Flow就是在异步计算的需求下引入的，用于表示异步的数据流。\nFlow #“问渠哪得清如许，为有源头活水来”，异步数据流的基本就是以某种方式获得异步数据。Kotlin提供了多种种方式，比较常用的就是Kotlin协程包的asFlow扩展和flow构造器。前者是对普通数据集的Flow化封装，没有更多可言，我们着重来看后者。 flow构造器的主要目标就是产生一个异步数据流，它是一个泛型函数，参数是一个挂起函数，并且是FlowCollector是扩展函数。这个接口只有一个emit方法，就是为创建的Flow提供异步计算的数据的，因为它是挂起函数，所以我们能在里面使用其他挂起函数计算异步值，然后通过emit方法将值发送出去，如此反复就能为下游操作提供源源不断的数据流了。 事情还没完，上面的步骤我们只是规定了创建数据的方式，并没有真正执行，也就是建好了道路，但是还没有车上路。那么，怎样才能让车在路上跑呢，查看Flow的接口会发现，它提供了collect方法来处理数据。collect接收一个挂起函数作为处理逻辑，但是同时，collect方法本身也是挂起函数，所以，这个方法只能在挂起函数中运行。有了这些知识，我们就可以写出最简单的异步数据流了。\n1uspend fun compute():Int{ delay(123) return 1024 } viewModelScope.launch { val flow=flow\u0026lt;Int\u0026gt; { emit(9527) emit(compute()) delay(256) emit(256) } flow.collect { println(it) } } 在flow构造器里面随意做各种操作，只要在必要的时候传递结果就行了，但是需要注意的是，emit方法只能运行在同一个协程里。乍一看，这样分开写和写在一起并没有本质上的差别，但Flow还能做到更多。\n该给Flow换个工作环境了 #上一节，我们那个简单的示例，假如把构造器里面的数据获取方法换成网络请求，应用就歇菜了。因为它们都是运行在主线程里面的。那么这个时候，看过上一篇文章的小伙伴马上就会反应过来，用withContext方法在构造器里面切换线程就行了哇。思路是很对，因为Flow的默认配置就是构造器和collect方法工作在同一线程，既然现在主线程不让运行，那就把构造器的线程切换一下就行了呗。然后事实并不是这样，这样写出来的代码根本无法运行。因为官方提供了唯一的flowOn方法来切换构造器的执行线程。使用也很简单，就是对创建好的Flow对象配置一次flowOn方法就行了。\nval flow=[\u0026#34;1.jpg\u0026#34;,\u0026#34;2.jpg\u0026#34;].asFlow() flow.map { decode(it) } .flowOn(Dispatchers.IO) viewModelScope.launch { flow.collect{ adapter.add(it) } 有些中间处理逻辑 #熟悉RxJava的小伙伴可能有疑问了，这些操作RxJava也能完成，甚至还有更多的操作符来支持中间状态的处理，那么异步数据流能做到这些吗。毫无疑问，它可以。普通的数据集有map,filter等操作方法，对于异步数据流来说，这些方法同样适用。而且这些方法参数都是挂起函数，都可以执行异步操作。而且它还有个更灵活的transform方法，这个方法可以定制自己的操作符，实现更灵活的数据操作。\n当然，上面那些操作符都只能实现单一异步流的操作，对于多数据流的支持，它也同样不在话下。zip可以将两个两个数据源两两合并起来，合成的数据流长度为两个数据流中最短的那个数据流的长度。combine则与zip不同，它会将两个数据流最近的发送数据作为输入，也就是说，假如一块一慢的两个数据源，慢的数据源的元素可能会被多次取到，从而最终的数据流比最短的那个都长。\nval flow = flowOf(1, 2).delayEach(10) val flow2 = flowOf(\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;).delayEach(15) flow.combine(flow2) { i, s -\u0026gt; i.toString() + s }.collect { println(it) // Will print \u0026#34;1a 2a 2b 2c\u0026#34; } 结束状态跟踪 #上一节提到，由于数据源和处理逻辑不在同一个地方，所以很难确定最终的数据流大小，进而不知道数据流什么时候处理结束。而且中间操作也可能会改变数据流的大小，由此就更加难以确定数据处理结束的时机了。但是我们有的时候却需要在数据处理完成后做一些操作，该怎么办呢？这个时候当然是该onCompletion方法上场了。这个方法有一个可为空的Throwable类型参数，很显然，这可以同时指示两种处理结果，成功或者失败，失败就会将异常对象传递进来。\n多个协程共同工作 #很多时候，避免不了让多个协程共同工作。对于返回单个值的协程，上一篇我们也提到过了，可以传递async构造器的返回对象Deferred，但是局限性就是这个对象只能传递一个值。针对多值传递的情况，Kotlin提供了Channel的解决方法。Channel类似于阻塞队列，数据通过send方法发送出去，在另外的地方使用receive方法接收。通过这种方法，我们可以极大提供协程的工作效率。利用它就可以轻松实现生产者和消费者模型。\nval chanel=Channel\u0026lt;Int\u0026gt;() viewModelScope.launch(Dispatchers.IO) { for (i in 1..5){ delay(1000) chanel.send(i) } } viewModelScope.launch { for (i in chanel){ println(\u0026#34;Handle ${i}\u0026#34;) } } 当然，这只是最简单的用法，还可以加入更多的生产者，或者不再需要数据时取消，甚至还有专门的product构造器，直接获得返回多个值的协程对象。\n总结 #Kotlin协程有很多有用的API，这些API覆盖了大部分异步使用的场景。所以在使用协程的时候，我们首先需要明确使用场景，再根据使用场景确定使用哪一套API，这可以使我们避免陷入API恐惧症。为此，我根据这两篇文章的内容，整理出了一份情景表格，实际开发中可以参照使用。 Kotlin协程构造器\nAPI 使用场景 launch 执行耗时操作，不需要返回值 async 需要获取耗时操作的单个返回值 produce 需要获取耗时操作的多个返回值 Kotlin协程协同工具\nAPI 使用场景 Flow 操作异步数据流 Channel 协程间通信 青山不改，绿水长流，咱们下期见！\n","date":"30 March 2021","permalink":"/post/Kotlin%E5%8D%8F%E7%A8%8B-%E4%BB%8E%E4%B8%80%E5%88%B0%E5%A4%9A.html","section":"Posts","summary":"上一篇文章，我介绍了Kotlin协程的创建，使用，协作等内容。本篇将引入更多的使用场景，继续带你走进协程世界。\n使用协程处理异步数据流 #常用编程语言都会内置对同一类型不同对象的数据集表示，我们通常称之为容器类。不同的容器类适用于不同的使用场景。Kotlin的Flow就是在异步计算的需求下引入的，用于表示异步的数据流。\nFlow #“问渠哪得清如许，为有源头活水来”，异步数据流的基本就是以某种方式获得异步数据。Kotlin提供了多种种方式，比较常用的就是Kotlin协程包的asFlow扩展和flow构造器。前者是对普通数据集的Flow化封装，没有更多可言，我们着重来看后者。 flow构造器的主要目标就是产生一个异步数据流，它是一个泛型函数，参数是一个挂起函数，并且是FlowCollector是扩展函数。这个接口只有一个emit方法，就是为创建的Flow提供异步计算的数据的，因为它是挂起函数，所以我们能在里面使用其他挂起函数计算异步值，然后通过emit方法将值发送出去，如此反复就能为下游操作提供源源不断的数据流了。 事情还没完，上面的步骤我们只是规定了创建数据的方式，并没有真正执行，也就是建好了道路，但是还没有车上路。那么，怎样才能让车在路上跑呢，查看Flow的接口会发现，它提供了collect方法来处理数据。collect接收一个挂起函数作为处理逻辑，但是同时，collect方法本身也是挂起函数，所以，这个方法只能在挂起函数中运行。有了这些知识，我们就可以写出最简单的异步数据流了。\n1uspend fun compute():Int{ delay(123) return 1024 } viewModelScope.launch { val flow=flow\u0026lt;Int\u0026gt; { emit(9527) emit(compute()) delay(256) emit(256) } flow.collect { println(it) } } 在flow构造器里面随意做各种操作，只要在必要的时候传递结果就行了，但是需要注意的是，emit方法只能运行在同一个协程里。乍一看，这样分开写和写在一起并没有本质上的差别，但Flow还能做到更多。\n该给Flow换个工作环境了 #上一节，我们那个简单的示例，假如把构造器里面的数据获取方法换成网络请求，应用就歇菜了。因为它们都是运行在主线程里面的。那么这个时候，看过上一篇文章的小伙伴马上就会反应过来，用withContext方法在构造器里面切换线程就行了哇。思路是很对，因为Flow的默认配置就是构造器和collect方法工作在同一线程，既然现在主线程不让运行，那就把构造器的线程切换一下就行了呗。然后事实并不是这样，这样写出来的代码根本无法运行。因为官方提供了唯一的flowOn方法来切换构造器的执行线程。使用也很简单，就是对创建好的Flow对象配置一次flowOn方法就行了。\nval flow=[\u0026#34;1.jpg\u0026#34;,\u0026#34;2.jpg\u0026#34;].asFlow() flow.map { decode(it) } .flowOn(Dispatchers.IO) viewModelScope.launch { flow.collect{ adapter.add(it) } 有些中间处理逻辑 #熟悉RxJava的小伙伴可能有疑问了，这些操作RxJava也能完成，甚至还有更多的操作符来支持中间状态的处理，那么异步数据流能做到这些吗。毫无疑问，它可以。普通的数据集有map,filter等操作方法，对于异步数据流来说，这些方法同样适用。而且这些方法参数都是挂起函数，都可以执行异步操作。而且它还有个更灵活的transform方法，这个方法可以定制自己的操作符，实现更灵活的数据操作。\n当然，上面那些操作符都只能实现单一异步流的操作，对于多数据流的支持，它也同样不在话下。zip可以将两个两个数据源两两合并起来，合成的数据流长度为两个数据流中最短的那个数据流的长度。combine则与zip不同，它会将两个数据流最近的发送数据作为输入，也就是说，假如一块一慢的两个数据源，慢的数据源的元素可能会被多次取到，从而最终的数据流比最短的那个都长。\nval flow = flowOf(1, 2).","title":"Kotlin协程-从一到多"},{"content":"","date":null,"permalink":"/tags/%E5%8D%8F%E7%A8%8B/","section":"Tags","summary":"","title":"协程"},{"content":"","date":null,"permalink":"/categories/%E5%8D%8F%E7%A8%8B/","section":"Categories","summary":"","title":"协程"},{"content":" 上一篇文章从理论上对Kotlin协程进行了部分说明，本文将在上一篇的基础上，从实战出发，继续协程之旅。\n从源头说起 #在Kotlin中，要想使用协程，首先需要使用协程创建器创建，但还有个前提——协程作用域(CoroutineScope)。在早期的Kotlin实现中，协程创建器是一等函数，也就是说我们随时随地可以通过协程创建器创建协程。但在协程正式发布以后，协程创建器需要在协程作用域对象上才能创建了，Kotlin添加了协程作用域来实现结构化并发。什么是结构化并发呢，通俗地说就是正确实施多个协程监控、管理的能力。在实际业务中，我们可能需要创建多个协程对象来完成不同的工作。为了对这些不相关的协程管理起来，Kotlin引入了协程作用域，通过某个协程作用域创建的协程都会被它管理着，在条件满足的时候，执行每个协程的取消工作或者结束自己。\n为了方便我们直接上手，官方提供了MainScope和GlobalScope供我们使用。正如名字那样，他们分别有不同的应用场景，前者比较适合用在UI相关的类中，而后者适用于在整个应用生命周期中都需要存活的类中。当然，对于Android开发者，其实我们有更好的选择——使用ViewModel的Kotlin扩展，它不仅有着全部的协程作用域功能，开箱即用，而且还在onCleared方法中实现了自动取消。\n创建协程 #有了协程作用域，那我们来创建一个最简单的协程吧。\nviewModelScope.launch{ //这里就是协程代码啦啦啦啦 delay(2000) System.out.println(\u0026#34;Hello World\u0026#34;) } launch创建并启动了一个协程，协程启动两秒后，在控制抬打印了Hello World，然后协程就结束了（协程是有完整生命周期的）。这个协程完成的工作有限，我们可以使用线程完成相同的功能:\nthread { Thread.sleep(2000) System.out.println(\u0026#34;Hello World\u0026#34;) } 我们可以看到，除去构建函数，两段代码唯一的区别就是延迟函数——delay和Thread.sleep.从功能上看他们都是让后面的代码延迟执行，但是效果却是不一样的，前者不会阻塞线程。这段代码其实是放在主线程里面执行的，但是它不会影响到UI的绘制，而后者假如把它放在主线程执行的话，应用会出现两秒的无响应。Kotlin把这种不会阻塞当前线程执行的函数称之为挂起函数，挂起函数可以在挂起点断开与当前线程的联系，让线程空闲下来完成其他的操作，当条件满足后，挂起函数重新在挂起点恢复，接着往下执行后面的代码。\n还有个小问题没有解决，在上一篇文章中，我曾经说过，挂起函数只能在挂起函数中执行，既然delay是挂起函数，那么反推，我们的代码块也应该是个挂起函数，而这个挂起函数就是所谓的协程体。\n让协程跨线程工作 #如果你看到上面的代码，然后转手在协程体里面写个网络请求的话，你会发现，你的应用崩溃了，这是怎么回事呢？因为协程虽然不会阻塞主线程，但是主线程是不允许进行网络请求的。如果这时你就急着下了协程没啥用的结论，那么你就肤浅了。让我们稍微改一改上面的代码，让它运行在子线程吧。\nviewModelScope.launch (Dispatchers.IO){ //这里就是协程代码啦啦啦啦 delay(2000) System.out.println(\u0026#34;Hello World\u0026#34;) } 很好，现在协程体里面的网络请求可以顺利执行了，但是很快有读者就会发现新问题了——我怎么把网络请求的结果传回主线程呢，难不成还搞个Handler,那和直接使用线程有什么区别，辣鸡协程。嘿，别急，这个协程其实也为客官处理好了。让我们再次改造一下代码：\nviewModelScope.launch (Dispatchers.IO){ //这里就是协程代码啦啦啦啦，这里是在子线程执行的代码哦 //假装这个是网络请求吧 delay(2000) withContext(Dispatchers.Main) { //哦豁豁，这里竟然运行在主线程哦 System.out.println(\u0026#34;Hello World\u0026#34;) } } 很好，我们可以愉快地使用协程处理网络请求了，那么这些魔法是怎么发生的呢，停下脚步，我们来重新审视一下上面的代码。\n首先，相比于最开始的代码，我们的代码里多了两个对象，一个方法调用。首先我们来看那两个对象，从名字中我们不难猜到它就是调度线程的。 Kotlin提供了四个常用的实现\nDefault,它是标准协程构建者默认使用的调度器，使用共享的线程池工作，适用于计算型的任务；\nMain,它是代表UI线程的调度器，通常来说只有一个线程，使用这个调度器就可以直接在协程中操作UI;\nUnconfined,它没有限定线程范围，它在哪个线程中被调用就会在哪个线程里执行完初始的代码，直到遇到挂起函数，随后它会使用挂起函数指定的调度器恢复，这个过程可以一直持续下去。\nIO,是用来承载阻塞的IO操作的，如文件读写，网络连接等，是我们比较常用的调度器。\n所以那两个调度器对象是让协程切换工作环境的魔法。接下来还有一个方法调用没有解释。withContext的作用是将当前的协程调度器切换到指定的调度器上，用这个调度器接着执行构建块中的代码。同时它也是一个挂起函数。提到挂起函数，我们就该想到，它是可恢复的。所以当这个挂起函数的代码块执行完成之后，它会自动恢复成原来的调度器，接着往下执行。\n用协程串联两个异步操作 #在项目开发中，还有一种常见的应用场景，客户端需要先请求一些配置信息，然后利用配置信息再请求真正的内容信息。这个过程描述起来是串行的，但是代码写起来却是割裂的，需要在第一个网络请求的回调中处理和发起第二个请求，然后在第二个回调中获取真正需要展示的数据，可能这个过程还会加个存库，或者触发另外请求的工作，那么完了，这代码没法看了。这放在以前，这种情况通常会使用RxJava，但是RxJava的代码可读性也还是差点意思。那么Kotlin协程可以写成什么样呢？\nviewModelScope.launch(Dispatchers.IO) { val retrofit=Retrofit.Builder().build() val apiUser=retrofit.create(APIUser::class.java) val user=api.current() val detail=api.userDetail(user.id) withContext(Dispatchers.Main) { userLiveData.value=detail } } 这和我们写一般的同步代码一摸一样，没有回调，也不需要付出其他代价，这个过程甚至可以一直加下去。其实我觉得这个才是协程的真正威力。\n让多个协程一起工作 #我们继续复杂化使用场景——我在做一个多端使用的笔记App，现在用户打开了某一个已存在的笔记，为了让用户能快速浏览到上一次的操作信息，一方面我需要从文件中读取上一次操作的结果，另一方面我要拉取远程的操作结果，然后对两个结果合并，决定最终的展示数据。考虑到这两个操作其实是并行的，上面我们让协程串联起来的思路已经不适用了，因为协程里面的操作都是串行的。既然一个协程解决不了，我们再加一个协程可不可以呢？看着好像是可以，但是，协程操作的结果我们怎么获取到呢？查阅API，我找到了另一个协程构建器async。它会返回一个协程对象，然后通过await方法获取到协程的计算结果。思路来了，我们马上动手\nval fileResult=viewModelScope.async(Dispatchers.IO) { //假装是读文件的代码吧 1 } val networkResult=viewModelScope.async(Dispatchers.IO) { //也是假装是网络请求的代码 2 } val fResult=fileResult.await() val rResult=networkResult.await() val result=if(fResult\u0026gt;rResult){ fResult }else{ networkResult } 然后你就会发现报错了，await是挂起函数。看来两个协程还完成不了，要三个，所以，让我们创建第三个协程吧\n//前面的两个协程不变 viewModelScope.launch { val fResult=fileResult.await() val rResult=networkResult.await() val result=if(fResult\u0026gt;rResult){ fResult }else{ networkResult } } 这就是协程间通信的基本写法啦，从这个基础之上，甚至还能衍生出更复杂的版本，但是万变不离其宗，都可以参考这种思路完成。\n协程的取消 #正如之前提到的一样，协程有着类似于线程的完整生命周期，包括创建，激活，完成中（取消中），已完成（已取消），刚才我们的示例都是正常状态，协程完成工作后会自动结束，但协程的另一条取消流程我们还没有提到。协程有自己的取消API——cancel可供使用，我们只需要保存好协程创建者返回的协程对象就行了。当然更常见的还是文章开篇提到的使用协程作用域取消。这个操作会取消所有的协程。\n总结 #本篇文章从协程创建开始，讲到了怎样用协程写出异步代码，怎么让多个协程共同工作，虽然覆盖了很大一部分使用场景，但是依然还有遗漏。由于篇幅限制，遗漏部分将在下一篇博文中继续讲解，希望大家持续关注。\n青山不改，绿水长流，咱们下期见！\n","date":"27 March 2021","permalink":"/post/Kotlin%E5%8D%8F%E7%A8%8B-%E4%BB%8E%E7%90%86%E8%AE%BA%E5%88%B0%E5%AE%9E%E6%88%98.html","section":"Posts","summary":"上一篇文章从理论上对Kotlin协程进行了部分说明，本文将在上一篇的基础上，从实战出发，继续协程之旅。\n从源头说起 #在Kotlin中，要想使用协程，首先需要使用协程创建器创建，但还有个前提——协程作用域(CoroutineScope)。在早期的Kotlin实现中，协程创建器是一等函数，也就是说我们随时随地可以通过协程创建器创建协程。但在协程正式发布以后，协程创建器需要在协程作用域对象上才能创建了，Kotlin添加了协程作用域来实现结构化并发。什么是结构化并发呢，通俗地说就是正确实施多个协程监控、管理的能力。在实际业务中，我们可能需要创建多个协程对象来完成不同的工作。为了对这些不相关的协程管理起来，Kotlin引入了协程作用域，通过某个协程作用域创建的协程都会被它管理着，在条件满足的时候，执行每个协程的取消工作或者结束自己。\n为了方便我们直接上手，官方提供了MainScope和GlobalScope供我们使用。正如名字那样，他们分别有不同的应用场景，前者比较适合用在UI相关的类中，而后者适用于在整个应用生命周期中都需要存活的类中。当然，对于Android开发者，其实我们有更好的选择——使用ViewModel的Kotlin扩展，它不仅有着全部的协程作用域功能，开箱即用，而且还在onCleared方法中实现了自动取消。\n创建协程 #有了协程作用域，那我们来创建一个最简单的协程吧。\nviewModelScope.launch{ //这里就是协程代码啦啦啦啦 delay(2000) System.out.println(\u0026#34;Hello World\u0026#34;) } launch创建并启动了一个协程，协程启动两秒后，在控制抬打印了Hello World，然后协程就结束了（协程是有完整生命周期的）。这个协程完成的工作有限，我们可以使用线程完成相同的功能:\nthread { Thread.sleep(2000) System.out.println(\u0026#34;Hello World\u0026#34;) } 我们可以看到，除去构建函数，两段代码唯一的区别就是延迟函数——delay和Thread.sleep.从功能上看他们都是让后面的代码延迟执行，但是效果却是不一样的，前者不会阻塞线程。这段代码其实是放在主线程里面执行的，但是它不会影响到UI的绘制，而后者假如把它放在主线程执行的话，应用会出现两秒的无响应。Kotlin把这种不会阻塞当前线程执行的函数称之为挂起函数，挂起函数可以在挂起点断开与当前线程的联系，让线程空闲下来完成其他的操作，当条件满足后，挂起函数重新在挂起点恢复，接着往下执行后面的代码。\n还有个小问题没有解决，在上一篇文章中，我曾经说过，挂起函数只能在挂起函数中执行，既然delay是挂起函数，那么反推，我们的代码块也应该是个挂起函数，而这个挂起函数就是所谓的协程体。\n让协程跨线程工作 #如果你看到上面的代码，然后转手在协程体里面写个网络请求的话，你会发现，你的应用崩溃了，这是怎么回事呢？因为协程虽然不会阻塞主线程，但是主线程是不允许进行网络请求的。如果这时你就急着下了协程没啥用的结论，那么你就肤浅了。让我们稍微改一改上面的代码，让它运行在子线程吧。\nviewModelScope.launch (Dispatchers.IO){ //这里就是协程代码啦啦啦啦 delay(2000) System.out.println(\u0026#34;Hello World\u0026#34;) } 很好，现在协程体里面的网络请求可以顺利执行了，但是很快有读者就会发现新问题了——我怎么把网络请求的结果传回主线程呢，难不成还搞个Handler,那和直接使用线程有什么区别，辣鸡协程。嘿，别急，这个协程其实也为客官处理好了。让我们再次改造一下代码：\nviewModelScope.launch (Dispatchers.IO){ //这里就是协程代码啦啦啦啦，这里是在子线程执行的代码哦 //假装这个是网络请求吧 delay(2000) withContext(Dispatchers.Main) { //哦豁豁，这里竟然运行在主线程哦 System.out.println(\u0026#34;Hello World\u0026#34;) } } 很好，我们可以愉快地使用协程处理网络请求了，那么这些魔法是怎么发生的呢，停下脚步，我们来重新审视一下上面的代码。\n首先，相比于最开始的代码，我们的代码里多了两个对象，一个方法调用。首先我们来看那两个对象，从名字中我们不难猜到它就是调度线程的。 Kotlin提供了四个常用的实现\nDefault,它是标准协程构建者默认使用的调度器，使用共享的线程池工作，适用于计算型的任务；\nMain,它是代表UI线程的调度器，通常来说只有一个线程，使用这个调度器就可以直接在协程中操作UI;","title":"Kotlin协程-从理论到实战"},{"content":" Kotlin的协程自推出以来，受到了越来越多Android开发者的追捧。另一方面由于它庞大的API，也将相当一部分开发者拒之门外。本篇试图从协程的几个重要概念入手，在复杂API中还原出它本来的面目，以全新的角度带读者走进Kotlin协程世界。\n什么是协程 #在很多有关协程的文章中，描述协程通常会用这样的一句描述——协程比线程更加轻量，是可取消的。这句话没有错，这两个都是协程的优点，但是并不是特点，它并没有解释协程是什么。那么什么是协程的特点呢，我觉得可以先用线程做个类比，解释一个概念最好的办法就是类比。 我不打算使用科学严谨的描述，我想给线程一个我自己的定义——线程是一个可供CPU调度的执行单元，它有自己的执行块，可以独立地执行逻辑。我特意将线程的三个关键特征列举出来了：\n线程由CPU调度 线程拥有自己的代码块 代码块需要才能调度执行 这是我对线程的直观感受，并且这些特点是能从代码上体现出来的。如Java中的Thread，它是线程的同时，也是一个实体对象，能通过API来认识它，使用它。而它的特别之处就是我上面列举的三点，这些都是线程特有的。我试着用相同的思路来给协程下一个自己的定义——协程是由线程调度执行的执行单元，它也有自己的执行块，可以独立或者协同执行逻辑。其实Kotlin中的协程也有自己对应实体和操作API，甚至和线程的还很像(如生命周期），但是由于Kotlin对协程的封装过于彻底，很多API没有暴露出来，以至于我对协程的认识一直处于盲人摸象的状态。另外，其实协程是有多种实现方式的，以下我的观点仅针对Kotlin的协程实现，可能与其他语言的实现不一致。\nKotlin中的协程对象本质上来讲就是个可执行的代码块， 执行的代码就是创建协程传递进去的。除此之外它还有个最大的特点——协程是不和线程绑定的。它可以在某个时刻断开当前的线程，然后在其他时候，附着到其他线程上。也就是说，它像一个乒乓球，线程就好比是球拍，它可以在球拍间反复横跳。所以，结合这两个特点，官方给协程的定义是 一个可挂起的计算实体。我觉得这个定义不算精确，它只体现了挂起这个概念，没有体现恢复的概念。我给它一个我自己的定义——一个可被调度的计算实体。\n协程中几个关键概念 #明白了协程是什么还不够，因为Kotlin的协程还涉及到很多方面，有几个关键概念需要理解。\n挂起函数 #提到Kotlin的协程就不得不提到挂起函数，这是Kotlin协程实现的最重要的概念之一。简单来说，挂起函数是一种异步实现方案，它是一个普通函数的前提下，还具备挂起和恢复的特性。 它是解决耗时计算和结果传递的一种方案。那么它和我们常见的基于回调的方案相比，有什么不同呢。在基于回调的方案中，计算过程和结果没有关系，结果需要通过另一个对象，在计算完成后由计算过程手动传递，而这一过程是可能被反复嵌套的，从而导致，一些本该是串行化的代码，被割裂成几个部分，分散到不同的代码块中。如以下读写文件的代码\n// asynchronously read into `buf`, and when done run the lambda inChannel.read(buf) { // this lambda is executed when the reading completes bytesRead -\u0026gt; ... ... process(buf, bytesRead) // asynchronously write from `buf`, and when done run the lambda outChannel.write(buf) { // this lambda is executed when the writing completes ... ... outFile.close() } } 同样的逻辑，将read和write实现为挂起函数后，能写成什么样呢？\nlaunch { // suspend while asynchronously reading val bytesRead = inChannel.aRead(buf) // we only get to this line when reading completes ... ... process(buf, bytesRead) // suspend while asynchronously writing outChannel.aWrite(buf) // we only get to this line when writing completes ... ... outFile.close() } 这是Kotlin官方给的一个例子，可以看出挂起函数的实现非常符合直觉，是和思考过程保持一致的，同时还减少了大量的嵌套。\n为了更好地解释挂起函数，我还需要引入了一个新的概念——挂起点。 挂起点是一个分界点，代表着从这个时刻之后，执行过程可能会转移到其他地方执行，然后在某个时刻，再从这个点恢复，继续往下执行。这个过程中，当前线程不会被阻塞。所以 挂起函数其实实现了异步非阻塞的通信模式。\n一句话总结，挂起函数是一种不阻塞当前线程，并能返回异步计算结果的函数。\n协程创建者 #前面提到的挂起函数虽然好，但是有个限制，普通方法是不能调用挂起函数的，只能通过挂起函数调用。那么就出现了先有鸡还是先有蛋的问题。解决这个问题的方法就是协程创建者。launch, future, sequence都是协程创建者。顾名思义，协程创建者是用来创建协程对象的，除此之外和普通函数没有区别。它们就是通往协程世界和挂起函数的大门。在这个大门里，我们可以尽情地使用挂起函数，简化我们的计算过程。当然，这些都不是固定不变的，这些函数都有多个配置参数，其中最重要的就是CoroutineContext。\nCoroutineContext #CoroutineContext的作用是提供协程的各种配置信息，本质上就是保存非重复元素的容器(Set)，里面的元素可以根据Key获取到（如调度器），称之为元素（Element）。这里，我忍不住想把它的接口定义放出来，因为实在是太美了。\ninterface CoroutineContext { operator fun \u0026lt;E : Element\u0026gt; get(key: Key\u0026lt;E\u0026gt;): E? fun \u0026lt;R\u0026gt; fold(initial: R, operation: (R, Element) -\u0026gt; R): R operator fun plus(context: CoroutineContext): CoroutineContext fun minusKey(key: Key\u0026lt;*\u0026gt;): CoroutineContext interface Element : CoroutineContext { val key: Key\u0026lt;*\u0026gt; } interface Key\u0026lt;E : Element\u0026gt; } 以上就是Kotlin中对CoroutineContext的定义，这些API每个都有其巧妙的用途，让人叹服\nget目的是根据Key获取对应的对象，这个方法的奇特之处就是查询参数。利用这个方法在执行某个操作之前判断CoroutineContext是否有某个配置对象，从而实现一种权限认证。\nfold其实就是一种迭代算法，可以对全部元素进行检查。\nplus这就很有意思了，它可以让两个对象合并起来，并且当key相同时使用右侧的对象覆盖左侧的对象。这在我们的协程使用中绝对是最灵活的API了。我们可以使用+替换调原本的调度器，使用我们给定的调度器，而且看起来是那么自然。\nminusKey返回不包含指定key的context，相当于一种取反操作，这在某些情境下非常有用。\n我觉得这应该算得上是对抽象的极致体现了，这个接口用简单的API抽象了增删改查四个操作，并且保留了强大的扩展性。在最开始接触协程的时候，我常常对协程复杂的工作机制和简单的参数配置产生了深深的怀疑，直到我看到了这个定义，我才明白它真正的强大之处，它不仅可以用系统默认的工作配置完成工作，还允许用户实现自己的CoroutineContext来随时替换掉默认配置，完成自己定制化的任务。\nContinuation #Continuation不是Kotlin特有的概念，它在维基上的解释是一种控制状态的抽象表示。而在Kotlin中，它是对协程在挂起点的一个状态抽象，这可能不太好理解，我们可以通过具体的API来将这个概念具体化。\ninterface Continuation\u0026lt;in T\u0026gt; { val context: CoroutineContext fun resumeWith(result: Result\u0026lt;T\u0026gt;) } 它有个关键的函数——resumeWith，它表示在挂起状态之后的某个时刻，通过这个状态对象从原来的位置恢复过来。这是挂起函数实现的关键。而这里面的控制状态就是由参数体现了，成功或者失败，所以它还有两个扩展方法：\nfun \u0026lt;T\u0026gt; Continuation\u0026lt;T\u0026gt;.resume(value: T) fun \u0026lt;T\u0026gt; Continuation\u0026lt;T\u0026gt;.resumeWithException(exception: Throwable) 总结 #协程是一个可被调度的计算实体，可通过协程创建者创建，在协程的代码块里可以使用挂起函数，它能必要的时候挂起，然后在条件满足后恢复，完成异步代码的串行化编程。\n以上就是理解协程的关键概念，在实际使用协程的过程中可能用不到很多，但是却会对我们理解其运作过程很有帮助，也是写出标准协程代码的关键。Kotlin协程并没有很多黑魔法，只是为了适用多种不同的使用场景，有了庞大的API，本篇文章就是对这些API的一个概括解释，后面将会针对各种场景再进行详细梳理，希望大家喜欢。\n青山不改，绿水长流，咱们下期见！\n","date":"26 March 2021","permalink":"/post/Kotlin%E5%8D%8F%E7%A8%8B-%E9%82%A3%E4%BA%9B%E7%90%86%E4%B8%8D%E6%B8%85%E4%B9%B1%E4%B8%8D%E6%98%8E%E7%9A%84%E5%85%B3%E7%B3%BB.html","section":"Posts","summary":"Kotlin的协程自推出以来，受到了越来越多Android开发者的追捧。另一方面由于它庞大的API，也将相当一部分开发者拒之门外。本篇试图从协程的几个重要概念入手，在复杂API中还原出它本来的面目，以全新的角度带读者走进Kotlin协程世界。\n什么是协程 #在很多有关协程的文章中，描述协程通常会用这样的一句描述——协程比线程更加轻量，是可取消的。这句话没有错，这两个都是协程的优点，但是并不是特点，它并没有解释协程是什么。那么什么是协程的特点呢，我觉得可以先用线程做个类比，解释一个概念最好的办法就是类比。 我不打算使用科学严谨的描述，我想给线程一个我自己的定义——线程是一个可供CPU调度的执行单元，它有自己的执行块，可以独立地执行逻辑。我特意将线程的三个关键特征列举出来了：\n线程由CPU调度 线程拥有自己的代码块 代码块需要才能调度执行 这是我对线程的直观感受，并且这些特点是能从代码上体现出来的。如Java中的Thread，它是线程的同时，也是一个实体对象，能通过API来认识它，使用它。而它的特别之处就是我上面列举的三点，这些都是线程特有的。我试着用相同的思路来给协程下一个自己的定义——协程是由线程调度执行的执行单元，它也有自己的执行块，可以独立或者协同执行逻辑。其实Kotlin中的协程也有自己对应实体和操作API，甚至和线程的还很像(如生命周期），但是由于Kotlin对协程的封装过于彻底，很多API没有暴露出来，以至于我对协程的认识一直处于盲人摸象的状态。另外，其实协程是有多种实现方式的，以下我的观点仅针对Kotlin的协程实现，可能与其他语言的实现不一致。\nKotlin中的协程对象本质上来讲就是个可执行的代码块， 执行的代码就是创建协程传递进去的。除此之外它还有个最大的特点——协程是不和线程绑定的。它可以在某个时刻断开当前的线程，然后在其他时候，附着到其他线程上。也就是说，它像一个乒乓球，线程就好比是球拍，它可以在球拍间反复横跳。所以，结合这两个特点，官方给协程的定义是 一个可挂起的计算实体。我觉得这个定义不算精确，它只体现了挂起这个概念，没有体现恢复的概念。我给它一个我自己的定义——一个可被调度的计算实体。\n协程中几个关键概念 #明白了协程是什么还不够，因为Kotlin的协程还涉及到很多方面，有几个关键概念需要理解。\n挂起函数 #提到Kotlin的协程就不得不提到挂起函数，这是Kotlin协程实现的最重要的概念之一。简单来说，挂起函数是一种异步实现方案，它是一个普通函数的前提下，还具备挂起和恢复的特性。 它是解决耗时计算和结果传递的一种方案。那么它和我们常见的基于回调的方案相比，有什么不同呢。在基于回调的方案中，计算过程和结果没有关系，结果需要通过另一个对象，在计算完成后由计算过程手动传递，而这一过程是可能被反复嵌套的，从而导致，一些本该是串行化的代码，被割裂成几个部分，分散到不同的代码块中。如以下读写文件的代码\n// asynchronously read into `buf`, and when done run the lambda inChannel.read(buf) { // this lambda is executed when the reading completes bytesRead -\u0026gt; ... ... process(buf, bytesRead) // asynchronously write from `buf`, and when done run the lambda outChannel.","title":"Kotlin协程-那些理不清乱不明的关系"},{"content":"","date":null,"permalink":"/tags/jetpack/","section":"Tags","summary":"","title":"Jetpack"},{"content":"","date":null,"permalink":"/tags/%E6%B2%89%E6%80%9D%E7%AF%87/","section":"Tags","summary":"","title":"沉思篇"},{"content":" ViewModel做为架构组件的三元老之一，是实现MVVM的有力武器。\nViewModel的设计目标 #ViewModel的基本功能就是管理UI的数据。其实，从职责上来说，这又是对Activity和Fragment的一次功能拆分。以前存储在它们内部的数据，需要它们自己处理创建，更新，存储，恢复的所有过程，同时它们还要处理UI的数据绑定，更新，动画等操作。职责的多元化就容易出现不好定位和调试的问题。另外，Activity和Fragment作为UI的承载者，很多时候需要共享数据和复用功能。而UI的差异让复用的粒度划分很难把控，容易写出扩展性差的代码。基于这些痛点，ViewModel被设计出来了。 同时ViewModel还将保存数据的功能强化了——它将设备配置变更后数据保存和恢复自动化了，在UI生命周期内都能保证数据的有效性，这大大减少了样板代码的编写，提高了开发效率。\nViewModel的架构设计 #*** ViewModel用了两种粒度划分来完成数据管理功能。*** 第一层是对ViewModel自身存储数据的管理。目标就是完成ViewModel的创建，对应的抽象实体是ViewModelProvider.Factory。第二层则是对已存在的ViewModel组的管理，目标就是保证意外情况下ViewModel的有效性，对应的抽象实体是ViewModelStore。当然，这些都只是概念上的抽象，还需要一个粘合剂把它们的抽象层级体现出来，这就是ViewModelProvider。这三个主体类共同搭建了ViewModel的体系框架。剩下的类都是对这三个概念的补充和完善。接下来我将分别以这些抽象为主线，逐层分析它们的实现逻辑。\nViewModel的组管理 #前面也提到过，ViewModelStore是完成组管理的，那么我们首先应该确定的是组的概念,也就是这些ViewModel都归属于谁的问题。这不难理解，要管理组，那就必须得找到组的主人啊，由此引申出了ViewModelStoreOwner，它代表着某个拥有组管理权限的对象，通过它提供的ViewModelStore对象就能对里面的ViewModel进行管理了，同时这些ViewModel也就共同形成了组。所以ViewModelStoreOwner其实就是组的抽象实体，它代表着某个组，也是管理分组的单位。 ViewModel有两个默认实现的组——ComponentActivity和Fragment。也就是说ComponentActivity和Fragment都实现了ViewModelStoreOwner这个接口。 先来看ComponentActivity的实现。根据接口，首先查看接口方法getViewModelStore的实现。里面主要涉及到两个对象，一个就是ViewModelStore的引用mViewModelStore，另一个就很有意思了，它是一个NonConfigurationInstances对象，这是一个简单类，就是保存ViewModelStore对象的。那么它特殊在什么地方呢？它是onRetainNonConfigurationInstance方法的返回对象。\n插一个课外知识科普，onRetainNonConfigurationInstance是Activity的一个方法，这个方法是设备配置发生变化（如横竖屏切换的时候）时被系统自动调用的，用于用户保存数据。只要这个方法返回的对象，在设备配置放生改变时都不会被销毁。稍后在重建完成后，可以通过getLastNonConfigurationInstance方法获取到。\n接着回到getViewModelStore的实现，刚才说到NonConfigurationInstances对象，它是通过调用getLastNonConfigurationInstance方法获得的。如果方法返回了有效的对象，说明Activity被重建了，就直接获取保存在NonConfigurationInstances对象中的值，然后更新mViewModelStore。否则就说明还没有有效的ViewModelStore对象，则直接创建。从这个逻辑不难看出，我们的ViewModel不会随着设备变化而重建，这正好满足了我们的设计目标。那么对于Fragment，它的实现又是怎样的呢。 Fragment的实现比较曲折，它直接委托给了FragmentManager,又委托给了FragmentManagerViewModel的getViewModelStore方法，方法实现也很简单，就是对HashMap查找，没有就创建新的。这显然不是我们想看到的，因为这里并没有和Activity类似的处理状态变更的逻辑。那么唯一的突破点就是那个HashMap对象了。搜索一圈发现，它会作为getSnapshot方法的返回值返回，有点Activity那味了。往上回溯，会发现它最终就是作为不销毁的对象，在Fragment销毁前保存下来了。 以上就是两种应用场景下ViewModelStore的创建逻辑，另外，还有清除逻辑没有讲到。这个逻辑本质上就是调用ViewModelStore的clear方法，唯一的问题就是确定调用时机。具体来说就是，Activity通过注册Lifecycle的状态监听，在Lifecycle.Event.ON_DESTROY的时候，调用了clear方法,而Fragment则是继续通过FragmentManager的desctory方法作为调用的入口点。在FragmentManagerViewModel里完成了方法调用。 总结一下，ViewModelStoreOwner是对ViewModel组的一种抽象。虽然对应着两个不同的实现，但是殊途同归，最终的目的就是保证在设备配置发生变化的时候对应ViewModelStore对象的有效性， 从而保证ViewModel对象的有效性。同时在真正需要销毁的时候做好清理工作。这就是这ViewModel的组管理功能。\nViewModel的创建管理 #ViewModel用ViewModelProvider.Factory来管理创建过程。具体来说就是怎样根据一个ViewModel子类的类信息创建对应的对象。这有两个难点——必要的依赖注入、数据的恢复。对于依赖注入，ViewModel还是耍了老把戏，和创建ViewModelStore类似，提供了HasDefaultViewModelProviderFactory的一个抽象，把依赖注入转移到了ComponentActivity和Fragment中。之所以这么做，是因为在创建ViewModel的过程中，可能需要使用到Application和Bundle等信息，而这些信息是只能在在Activity和Fragment中才能获取到的。数据恢复则是关注怎样利用现有的数据将对象恢复到原来的状态。当然这些过程其实都可以没有，不需要传递Application或者Bundle对象，不需要恢复ViewModel状态，则库提供了默认的实现。就是简单的调用反射创建对象而已。 针对刚才说的各种情况，ViewModelProvider.Factory有多个实现，那么实际上它到底是使用哪个实现呢，我们得从ViewModelProvider中寻找答案。在它的构造方法里，会对ViewModelStoreOwner做类型判断，假如它是HasDefaultViewModelProviderFactory的实例，则使用实例返回的对象，否则默认的实现。结合上面的分析，让我们继续到ComponentActivity和Fragment中寻找答案。不看不知道，一看吓一跳，它们竟然都是使用了SavedStateViewModelFactory类，那么我们一起来看看它是怎么实现的吧。 在构建SavedStateViewModelFactory对象的时候，会传入三个对象——Application,SavedStateRegistryOwner,Bundle,这三个对象中最重要的就是第二个，它的主要功能就是提供在SavedStateRegistry对象，这个对象会在合适的时候保存数据，然后在合适的时候再恢复过来。它也是生命周期感知的组件。在它的create方法里，也是通过反射构建ViewModel对象的，唯一的不同就是反射多了个参数。接着往下看，最终会利用这些信息构造出SavedStateHandle对象，这个对象就是真正对我们当前创建的ViewModel对象有用的信息。SavedStateHandle提供了根据键值对保存数据的方法，也提供了查询方法，所以ViewModel可以根据这个对象，恢复自己的LiveData数据，最重要的，这个类还提供了LiveData的另一个子类SavingStateLiveData，能自动处理数据保存的问题。 一句话总结，ComponentActivity和Fragment会使用SavedStateViewModelFactory对象作为ViewModelProvider中的Factory来创建ViewModel。只要ViewModel提供了带有Application或者SavedStateHandle的构造方法，就能享受从Bundle中恢复数据的便利。\nViewModel的粘合剂ViewModelProvider #为什么说ViewModelProvider是粘合剂呢？因为这个类就做了一件事，把ViewModelStore和ViewModelProvider.Factory组合起来，实现了一个叫get的方法，这个方法的内部实现就是有两个步骤。\n调用ViewModelStore的get方法查询是否有创建好的对象，如果有就返回，方法结束，否则进入步骤2。\n调用ViewModelProvider.Factory的create方法创建对象，并将之保存到ViewModelStore中。\n所以当我们要使用ViewModel的时候，通常是创建ViewModelProvider对象，然后调用get方法获取真正的ViewModel对象，这样，我们的对象就具备了正确处理设备配置变更的能力。\nViewModel的Fragment间通信功能 #根据前面的梳理，我们知道，ViewModelStore是管理某个ViewModel组的，只要我们保证ViewModelStore存在，我们就可以保证ViewModel存活。再反推一步，要保证ViewModelStore存活，我们就要保证ViewModelStoreOwner在不同的地方都能返回同一个ViewModelStore对象，而ComponentActivity和Fragment是都实现了这个接口的。结合Activity的生命周期通常是大于Fragment这一事实，不难得出结论——在某个Fragment里面，用Activity对象创建ViewModelProvider对象，就能保证获取到和Activity一样的ViewModelStore对象，也就能保证获取到相同的ViewModel对象。只要Activity没有销毁，该Activity下的所有Fragment都能获取到相同的ViewModel对象，然后通过更改状态能方式完成通信。\n到此，对ViewModel的分析告一段落了，对创建过程的两次抽象是我觉得最精彩的环节，另外对现有条件（Activity和Fragment的生命周期）的利用也是它独到之处，真的是受益匪浅。青山不改，绿水长流，咱们下期见！ ","date":"24 March 2021","permalink":"/post/%E6%B2%89%E6%80%9D%E7%AF%87-%E5%89%96%E6%9E%90Jetpack%E7%9A%84LiveData.html","section":"Posts","summary":"\u003cblockquote\u003e\n\u003cp\u003eViewModel做为架构组件的三元老之一，是实现MVVM的有力武器。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch1 id=\"viewmodel的设计目标\" class=\"relative group\"\u003eViewModel的设计目标 \u003cspan class=\"absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100\"\u003e\u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\" style=\"text-decoration-line: none !important;\" href=\"#viewmodel%e7%9a%84%e8%ae%be%e8%ae%a1%e7%9b%ae%e6%a0%87\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\u003c/span\u003e\u003c/h1\u003e\u003cp\u003eViewModel的基本功能就是管理UI的数据。其实，从职责上来说，这又是对Activity和Fragment的一次功能拆分。以前存储在它们内部的数据，需要它们自己处理创建，更新，存储，恢复的所有过程，同时它们还要处理UI的数据绑定，更新，动画等操作。职责的多元化就容易出现不好定位和调试的问题。另外，Activity和Fragment作为UI的承载者，很多时候需要共享数据和复用功能。而UI的差异让复用的粒度划分很难把控，容易写出扩展性差的代码。基于这些痛点，ViewModel被设计出来了。\n同时ViewModel还将保存数据的功能强化了——它将设备配置变更后数据保存和恢复自动化了，在UI生命周期内都能保证数据的有效性，这大大减少了样板代码的编写，提高了开发效率。\u003c/p\u003e","title":"沉思篇-剖析Jetpack的ViewModel"},{"content":"","date":null,"permalink":"/tags/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/","section":"Tags","summary":"","title":"源码剖析"},{"content":"","date":null,"permalink":"/categories/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/","section":"Categories","summary":"","title":"源码剖析"},{"content":" 上一篇我们讲到了架构组件中的Lifecycle，由于缺少具体的运用，可能缺少直观的感受，今天我们就用Lifecycle实战一回，看看Lifecycle是怎样运用到LiveData中的。\nLiveData的功能 #根据LiveData的类注释，我们可以知道，LiveData是一个实现了观察者模式的数据容器，并且是可感知生命周期的。由这个功能描述，我们就能知道LiveData是由两部分功能合并而来的，一部分是数据容器，一部分是响应生命周期。在阅读源码的时候，我觉得功能拆解是个很有用的手段，合理的功能拆解，就是有目的的省略，有助于快速理清功能实现逻辑。 接下来，我将以这两个功能为突破点，逐一梳理LiveData的实现思路。\nLiveData的数据容器功能 #数据容器的概念相信大家不会陌生，几乎每种语言都会有他们的身影，开发者用它们来保存数据对象。由于应用场景的不同，出现了各种各样的数据容器，如List,Set这些是保存数据集的，ThreadLocal是保存线程私有数据的。那么LiveData是保存什么数据的呢，它是保存可观察数据的。 对于数据容器的拆解，其实是有固定的模式可寻的，就是以添加数据为突破口，然后以数据流向为主线，逐步击破。所以我们就从LiveData添加数据的方法setValue开始分析。\nsetValue方法的逻辑很少，主要就是两个，增加mVersion的版本，保存数据，然后就是调用dispatchingValue进行分发了。mVersion是个关键点，后面还会讲到，这里主要是混个脸熟。我们先进入到下一步。 dispatchingValue的功能很清楚，从名字上就能看出来，就是分发数据的。但是它的实现却是很巧妙的。为了阐述这个实现，我们需要一个合适的场景。假设当前LiveData保存的数据变动频繁，并且观察对象很多的情况，我们怎样快速，准确地把数据传递给观察者呢？或者换种说法，当我们正在分发数据的时候，又有新数据来了怎么办？通常来说有两种方案，掐头去尾。掐头就是在数据更新的时候不管新数据，先把分发操作执行完之后再处理新数据。去尾就是新数据来了，取消上一次数据分发，重新分发新数据。LiveData采用的是去尾的方式。明白了这点，再看dispatchingValue就很清晰了，它用mDispatchingValue标识分发状态，用mDispatchInvalidated来标识新数据状态，然后在使用for循环分发数据的时候检测mDispatchInvalidated的状态是不是更新了，由此确定是不是需要取消此次分发，进行新一轮的分发。其他的就没有更多奥秘可言了。 considerNotify是分发给具体的观察者之后的处理逻辑。这一步就是在步骤2中的for循环里完成的。所以这里就是数据的最后一站了。这个方法需要根据观察者的两个状态来确定是不是要通知。一个就是步骤1中提到的mVersion，因为观察者也有一份自己的mLastVersion,假如mVersion比mLastVersion小的话就没必要通知了，因为每次通知之后，它两的值是一样的。另一个就是和生命周期扯上关系的mActive了。这个状态标示着当前的观察者是否处于激活状态。假如不是，则直接返回了。搞了这两个判断之后就是简单的更新mLastVersion和执行onChanged回调了。 以上三步就是LiveData的数据更新过程，重点在于处理分发这个步骤上，在以后的项目中，我们可以借鉴这种思想，当然具体问题是需要具体分析的。 在上面的步骤3中我们知道了观察者的mActive是决定LiveData响应生命周期的关键，那么接下来我们来看看这个状态是怎么更新的吧。 LiveData的生命周期感知 #联系上一篇文章沉思篇-剖析JetPack的Lifecycle,我们知道Lifecycle是专业干介个的（生命周期感知）。同时文章也提到了Lifecycle三个很重要的抽象，LifecycleOwner，Lifecycle，LifecycleObserver，这是引入生命周期感知三个很好的突破口。\nLifecycleOwner作为生命周期的动力源，是直接可以获得Lifecycle的，继而可以方便地读取状态和注册状态监听，由于出色的接口封装，不需要和其他类产生耦合，是个很好的引入对象。 Lifecycle作为Lifecycle的核心类，它完成了很多功能，是抽象类，只能继承使用。 LifecycleObserver，作为状态更新通知的最后一环，可以很方便地完成状态监听，但是需要注册到合适的Lifecycle上。 所以很显然，LiveData使用Lifecycle需要搞一个LifecycleOwner，用于引入生命周期的状态，还需要搞一个LifecycleObserver，用于响应状态更新。另外，由于我们是数据容器的定位，我们的数据是很可能供给给很多类使用的，所以假如将LifecycleOwner和LiveData绑定的话，一旦某个操作致使LiveData失活，其他所有的观察者就一摸黑了，啥也收不到了，这是有悖设计的。基于这个原因，LifecycleOwner只能和Observer绑定。结果就显而易见了，他们同时出现在了observe方法里，这也就解释了observe方法为啥需要两个参数。 很明显observe就是分析生命周期感知的突破口，我们再接再励，看看他们是怎么合力工作的。\n在observe内部，LifecycleOwner和Observer同时被LifecycleBoundObserver接收，用于构造对象了，逻辑继续转到LifecycleBoundObserver中.\n注意到LifecycleBoundObserver是实现了LifecycleEventObserver,并且继承自ObserverWrapper。ObserverWrapper不熟悉我们先放一边，上一篇中我们知道了LifecycleEventObserver是继承自LifecycleObserver的，它只有一个状态变更的回调。很显然，我们下一步就是去看看它是怎样处理状态变更的。\n来到onStateChanged方法，里面做了两件事，而且是互斥的，这就是说，其实它在某种条件下干一件事，其他条件干另一个事。先看简单的一件事，它在Lifecycle状态是DESTROYED``的时候移除了Observer，没有更多了。那么另一件事其实我们也能猜到了，就是状态不为DESTROYED的时候怎么搞。它委托给了父类ObserverWrapper`搞。\n逻辑来到ObserverWrapper的activeStateChanged方法里，里面就是对LiveData的状态进行设置而已，也就是根据现在是不是激活状态更新mActiveCount的值，并且在适当的条件下通知LiveData进入激活状态或者失活状态。另外就是上面我们心心念念的mActive了，这就接上了。当然，还有个极为关键的点，在激活状态下，会以自身为参数，进行一次数据数据，在某种情况下，这可能会引入数据问题。\n到这里，LiveData的生命周期感知就看完了.一句话就能总结，Lifecycle让LiveData有了在激活状态下分发数据，在失活后自动取消监听的能力。\n补充说明 虽然前面讲了那么多，还有一些内容是没有讲到的，比如数据的异步更新，Observer的注册过程，等等，但是已经不妨碍我们理解主流程了。为了加深印象，我还整理一个UML图，可以对照着图再次理解，回顾。 ","date":"23 March 2021","permalink":"/post/%E6%B2%89%E6%80%9D%E7%AF%87-%E5%89%96%E6%9E%90Jetpack%E7%9A%84LiveData.html","section":"Posts","summary":"\u003cblockquote\u003e\n\u003cp\u003e上一篇我们讲到了架构组件中的Lifecycle，由于缺少具体的运用，可能缺少直观的感受，今天我们就用Lifecycle实战一回，看看Lifecycle是怎样运用到LiveData中的。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch1 id=\"livedata的功能\" class=\"relative group\"\u003eLiveData的功能 \u003cspan class=\"absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100\"\u003e\u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\" style=\"text-decoration-line: none !important;\" href=\"#livedata%e7%9a%84%e5%8a%9f%e8%83%bd\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\u003c/span\u003e\u003c/h1\u003e\u003cp\u003e根据\u003ccode\u003eLiveData\u003c/code\u003e的类注释，我们可以知道，\u003ccode\u003eLiveData\u003c/code\u003e是一个实现了观察者模式的数据容器，并且是可感知生命周期的。由这个功能描述，我们就能知道\u003ccode\u003eLiveData\u003c/code\u003e是由两部分功能合并而来的，一部分是数据容器，一部分是响应生命周期。在阅读源码的时候，我觉得功能拆解是个很有用的手段，合理的功能拆解，就是有目的的省略，有助于快速理清功能实现逻辑。\n接下来，我将以这两个功能为突破点，逐一梳理\u003ccode\u003eLiveData\u003c/code\u003e的实现思路。\u003c/p\u003e","title":"沉思篇-剖析Jetpack的LiveData"},{"content":" 这几年，对于Android开发者来说，最时髦的技术当属Jetpack了。谷歌官方从19年开始，就在极力推动Jetpack的使用，经过这几年的发展，Jetpack也基本完成了当时的设计目标——简单，一致，专注。而使得这一切成为可能的基石，我觉得当属架构组件了。最初架构组件作为单独的库和support库并没有太多联系，随着Jetpack的成型，给架构组件也注入了新的活力。在Jetpack库中，建构组件的使用随处可见，扮演着越来越重要的角色。今天，我就以作为架构组件基石的Lifecycle开始，尝试对架构组件进行剖析，向大家展示谷歌开发者是怎样设计一个高内聚，低耦合的库的。\n前言 #要说阅读源码，我觉得和把大象装进冰箱的操作是一样的，就是再大的事，得分步骤。阅读源码的第一步就是站在库开发者的角度，提炼出库需要完成的功能。明确了功能，才能针对功能进行代码设计，这也是我们阅读源码的第二步，理清实现逻辑。我们可以通过画UML图的方式帮助理解。通常来说画完UML图，源码的理解也就七七八八了。这时我们就可以走到第三步，品读实现细节。有了前两步的基础，我们就可以针对性地选取一些感兴趣的内容研读实现了，而且可以做到收放自如，指哪打哪。 那我们开始吧！\nLifecycle的源码思路 #明确Lifecycle的设计目标 一句话概括，Lifecycle就是完成了生命周期感知的任务。生命周期感知是什么意思呢，就是一个类可以不依赖Activity或者Fragment的回调，正确处理状态更新的问题。那么我们为什么需要这样的一个类呢，这和我们直接在回调方法里面写逻辑有什么差别吗？为了回答这个问题，我们来设想一下这样一个场景：一个Activity需要获取用户实时的位置信息，同时需要使用相机，以往我们的做法是在Activity的某些回调里面设置位置，相机的监听及解监听。如果这时，Activity再加入其他的一些逻辑，它的代码就可能膨胀到不能忍受的地步，并且随着业务的增长，后续Activity的膨胀是不可预期的，这样是不利于调试和测试的，而且，从设计上来说，这样的设计也是脆弱的，耦合太紧了。但是我们的这些组件确确实实是需要响应生命周期回调的啊，那么怎样才能做到既能感知生命周期，又能降低耦合呢。计算机科学告诉我们这样一条真理，当找不到其他方法时，可以考虑加一层抽象。由此，Lifecycle诞生了。这就是Lifecycle的目标，很纯粹，就是生命周期感知，就是把专业的事情交给专业的去做。\nLifecycle的工作流程 #概括来说，Lifecycle就是完成了状态监听和状态分发的两个功能。为了完成这两个功能，Lifecycle抽象出了三个概念，也可以说是三个流程吧。\n拥有生命周期的对象，称为LifecycleOwner，这其实只是一个接口，只要能提供Lifecycle的都可以称为LifecycleOwner，这个类主要的功能就是提供原始的生命周期事件，供后续的操作提供数据，这是第一步——状态感知； 拥有生命周期状态，称为Lifecycle，这个类主要的功能就是提供状态抽象和提供状态信息，这是第二步——状态更新； 对生命周期状态感兴趣的观察者，称为LifecycleObserver，这个类主要的功能就是对状态信息进行响应，这是第三步——状态响应。 流程很简单，看着也很清晰的，就是观察者模式。但是Lifecycle库为了完成更好的解耦和提供更多的扩展，在这三个环节上衍生出了更多的类，这也是我以Lifecycle为剖析对象的原因。我觉得一个好的库，不仅仅要能够完成库的设计目标，同时还应该保持尽可能的扩展性和可读性。在这点上，Lifecycle无疑是我们很好的榜样。接下来，我们就一起以这三个阶段为主线，逐一剖析Lifecycle是怎样完成抽象，设计，及实现的。\nLifecycle的状态感知 #传统的状态感知就是重写Activity和Fragment的生命周期回调，在回调里面进行状态更新。这其实也是Lifecycle实现的基本思路，只是它将这些个回调抽象为了一个个的事件。那么怎么将生命周期转化为一个个事件呢？Lifecycle用了一个巧妙的方法，自定义了一个ReportFragment。ReportFragment作用很明确，就是监听生命周期，生成状态事件。 如图所示，本质上ReportFragment还是监听了Activity的生命周期，绑定关系就发生在injectIfNeededIn方法中。然后为了将监听到的状态传递出去给其他类使用，ReportFragment借助了dispatch方法。这里有个很巧妙的设计细节，dispatch并没有直接引用自己的组件，而是使用了Activity，但是为什么还是能将事件发送出去呢？因为这里面使用了动态类型判断及转换的操作，最终，转换成了分发器LifecycleRegistry来完成事件分发操作。从而顺利讲逻辑转到了第二阶段，状态更新。\nLifecycle的状态更新 #状态更新主要的逻辑还是放在了LifecycleRegistry类里，这个类是继承了Lifecycle的。 如图所示，这个类作为Lifecycle的子类完成了被观察对象的两个功能，接收和管理观察对象。其次作为核心类它又完成了状态更新的功能。事件在这里被转化为状态，保存了下来，然后通知给自己的观察者。从类缩略图中，我们也可以看出这些方法就是为了完成这两大功能而设计的。知道了这些，状态更新的步骤也就了解了。那么顺理成章的，我们马上进入第三个步骤。\nLifecycle的状态响应 #LifecycleObserver是个空接口，那么状态更新怎么做呢？这就还得从LifecycleRegistry开始看起。LifecycleRegistry在添加LifecycleObserver的时候做了包装，于是LifecycleObserver变成了多种LifecycleObserver的子类，在不同的子类里面其实都直接或者间接地继承自LifecycleEventObserver。所以最终状态是通过LifecycleEventObserver的onStateChanged方法通知给观察者的。但是我们很快发现不对劲，官方Demo是直接实现LifecycleObserver，并且只需要用注解对感兴趣的状态注册就可以了。这里完全没有体现哇。按照刚才的思路，我们还是从添加LifecycleObserver的方法开始，LifecycleObserver被包装成ObserverWithState对象，而在构造方法里面委托给了Lifecycling，所以最终的秘密藏在Lifecycling。Lifecycling里面对多种LifecycleObserver进行了处理，其中就包括了我们熟悉的注解的方式。所以，总结来看，我们通过注解定义LifecycleObserver观察者后，注册到LifecycleRegistry就会被包装成新的观察者对象。然后，在状态更新的时候，用过注解找到合适的方法来通知观察者。到这里其实整个Lifecycle的工作流程已经理清了，我根据这些整理出了一份UML图。 由UML图，我们可以直观地得出一句话的结论，LifecycleRegistry使用LifecycleOwner提供的Lifecycle，使用观察者的模式把状态传递给了LifecycleEventObserver，这就是我最开始说的三个抽象之间的联系。\n品读实现细节 #经过多次的品读，我发现了Lifecycle的多个小细节值得我们细细品味，其一就是Lifecycle强大的抽象。Lifecycle使用了LifecycleOwner抽象了生命周期这个概念，生命周期不一定是和Activity绑定的，用户可以自己定义自己的LifecycleOwner，定制满足自己业务需求的Lifecycle。其次LifecycleRegistry是一个很好的高内聚，低耦合的实现典范——LifecycleRegistry依赖的都是LifecycleOwner和LifecycleObserver这样的顶层接口，遵循了依赖倒置原则、LifecycleRegistry内部对LifecycleObserver的包装又委托给了Lifecycling，遵循了单一职责原则，就连LifecycleRegistry的方法都是严格遵守单一职责原则的，不得不叹服开发者对代码强大的掌控力。 当然，还有其他也很不错的实现细节，我没有一一展开，因为代码是读不完的，我们抓住我们感兴趣的就行了，有些细节就是用来忽略的，我们不得不承认这个事实。\n青山不改，绿水长流，咱们下期见！\n","date":"21 March 2021","permalink":"/post/%E6%B2%89%E6%80%9D%E7%AF%87-%E5%89%96%E6%9E%90JetPack%E7%9A%84Lifecycle.html","section":"Posts","summary":"\u003cblockquote\u003e\n\u003cp\u003e这几年，对于Android开发者来说，最时髦的技术当属Jetpack了。谷歌官方从19年开始，就在极力推动Jetpack的使用，经过这几年的发展，Jetpack也基本完成了当时的设计目标——简单，一致，专注。而使得这一切成为可能的基石，我觉得当属架构组件了。最初架构组件作为单独的库和support库并没有太多联系，随着Jetpack的成型，给架构组件也注入了新的活力。在Jetpack库中，建构组件的使用随处可见，扮演着越来越重要的角色。今天，我就以作为架构组件基石的Lifecycle开始，尝试对架构组件进行剖析，向大家展示谷歌开发者是怎样设计一个高内聚，低耦合的库的。\u003c/p\u003e\n\u003c/blockquote\u003e","title":"沉思篇-剖析JetPack的Lifecycle"},{"content":"","date":null,"permalink":"/tags/c/c++/","section":"Tags","summary":"","title":"C/C++"},{"content":"","date":null,"permalink":"/categories/c/c++/","section":"Categories","summary":"","title":"C/C++"}]